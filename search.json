[{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Description and usage of Spectra objects","text":"Spectra package provides scalable flexible infrastructure represent, retrieve handle mass spectrometry (MS) data. Spectra object provides user single standardized interface access manipulate MS data supporting, concept exchangeable backends, large variety different ways store retrieve mass spectrometry data. backends range mzML/mzXML/CDF files, simple flat files, database systems. vignette provides general examples descriptions Spectra package. Additional information tutorials available, SpectraTutorials, MetaboAnnotationTutorials, also (Rainer et al. 2022).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Description and usage of Spectra objects","text":"package can installed BiocManager package. install BiocManager use install.packages(\"BiocManager\") , , BiocManager::install(\"Spectra\") install Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"general-usage","dir":"Articles","previous_headings":"","what":"General usage","title":"Description and usage of Spectra objects","text":"Mass spectrometry data Spectra objects can thought list individual spectra, spectrum set variables associated . Besides core spectra variables (MS level retention time) arbitrary number optional variables can assigned spectrum. core spectra variables accessor method guaranteed value returned (NA information available). core variables data type (alphabetically ordered): acquisitionNum integer(1): index acquisition spectrum MS run. centroided logical(1): whether spectrum profile centroid mode. collisionEnergy numeric(1): collision energy used create MSn spectrum. dataOrigin character(1): origin spectrum’s data, e.g. mzML file read. dataStorage character(1): (current) storage location spectrum data. value depends backend used handle provide data. -memory backend like MsBackendDataFrame \"<memory>\", -disk backend MsBackendHdf5Peaks name HDF5 file spectrum’s peak data stored. intensity numeric: intensity values spectrum’s peaks. isolationWindowLowerMz numeric(1): lower m/z isolation window (MSn) spectrum measured. isolationWindowTargetMz numeric(1): target m/z isolation window (MSn) spectrum measured. isolationWindowUpperMz numeric(1): upper m/z isolation window (MSn) spectrum measured. msLevel integer(1): MS level spectrum. mz numeric: m/z values spectrum’s peaks. polarity integer(1): polarity spectrum (0 1 representing negative positive polarity, respectively). precScanNum integer(1): scan (acquisition) number precursor MSn spectrum. precursorCharge integer(1): charge precursor MSn spectrum. precursorIntensity numeric(1): intensity precursor MSn spectrum. precursorMz numeric(1): m/z precursor MSn spectrum. rtime numeric(1): retention time spectrum. scanIndex integer(1): index spectrum within (raw) file. smoothed logical(1): whether spectrum smoothed. details individual variables getter/setter function see help Spectra (?Spectra). Also note variables suggested, required characterize spectrum. Also, make sense MSn, MS1 spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"creating-spectra-objects","dir":"Articles","previous_headings":"General usage","what":"Creating Spectra objects","title":"Description and usage of Spectra objects","text":"simplest way create Spectra object defining DataFrame corresponding spectra data (using corresponding spectra variable names column names) passing Spectra constructor function. create object set 3 spectra providing MS level, polarity also additional annotations ID HMDB (human metabolome database) name. m/z intensity values spectrum provided list numeric values. Alternatively, possible import spectra data mass spectrometry raw files mzML/mzXML CDF format. create Spectra object two mzML files define use MsBackendMzR backend store data (note requires mzR package installed). backend, specifically designed raw MS data, keeps subset spectra variables memory reading m/z intensity values original data files demand. See section Backends details backends properties. Spectra object sps_sciex allows now access spectra data 1862 MS1 spectra uses MsBackendMzR backend (Spectra object sps created previous code block uses default MsBackendDataFrame).","code":"library(Spectra)  spd <- DataFrame(     msLevel = c(2L, 2L, 2L),     polarity = c(1L, 1L, 1L),     id = c(\"HMDB0000001\", \"HMDB0000001\", \"HMDB0001847\"),     name = c(\"1-Methylhistidine\", \"1-Methylhistidine\", \"Caffeine\"))  ## Assign m/z and intensity values. spd$mz <- list(     c(109.2, 124.2, 124.5, 170.16, 170.52),     c(83.1, 96.12, 97.14, 109.14, 124.08, 125.1, 170.16),     c(56.0494, 69.0447, 83.0603, 109.0395, 110.0712,       111.0551, 123.0429, 138.0662, 195.0876)) spd$intensity <- list(     c(3.407, 47.494, 3.094, 100.0, 13.240),     c(6.685, 4.381, 3.022, 16.708, 100.0, 4.565, 40.643),     c(0.459, 2.585, 2.446, 0.508, 8.968, 0.524, 0.974, 100.0, 40.994))  sps <- Spectra(spd) sps ## MSn data (Spectra) with 3 spectra in a MsBackendDataFrame backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ##  ... 18 more variables/columns. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE) sps_sciex <- Spectra(fls, backend = MsBackendMzR()) sps_sciex ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"accessing-spectrum-data","dir":"Articles","previous_headings":"General usage","what":"Accessing spectrum data","title":"Description and usage of Spectra objects","text":"detailed Spectra objects can contain arbitrary number properties spectrum (called spectra variables). available variables can listed spectraVariables method: two Spectra contain different set variables: besides \"msLevel\", \"polarity\", \"id\" \"name\", specified Spectra object sps, contains variables \"rtime\", \"acquisitionNum\" \"scanIndex\". part core variables defining spectrum accessor methods exist. use msLevel rtime access MS levels retention times spectra sps. specify retention times spectra sps thus NA returned . Spectra object sps_sciex contains many variables, extracted mzML files. extract retention times first spectra object. Note addition accessor functions also possible use $ extract specific spectra variable. extract name compounds sps can use sps$name, , extract MS levels sps$msLevel. also replace specific spectra variables using either dedicated method $. specify spectra sps represent centroided data. $ operator can also used add arbitrary new spectra variables Spectra object. add SPLASH key spectra. new spectra variable now listed additional variable result spectraVariables function can directly access content sps$splash. spectrum can different number mass peaks, consisting mass--charge (m/z) associated intensity value. can extracted mz intensity functions, return list numeric values. Peak data can also extracted peaksData function returns list matrices, columns \"mz\" \"intensity\" containing m/z intensity values one spectrum. Note get result using method coerce Spectra object list SimpleList: spectraData function returns DataFrame full data spectrum (except m/z intensity values), selected spectra variables (can specified columns parameter). extract spectra data variables \"msLevel\", \"id\" \"name\". Spectra one-dimensional objects storing spectra, even different files samples, single list. Specific variables thus used define originating file extracted sample measured. data origin spectrum can extracted dataOrigin function. sps, Spectra created DataFrame, NA specify data origin: dataOrigin sps_sciex, Spectra initialized data mzML files, contrast, returns originating file names: current data storage location spectrum can retrieved dataStorage variable, return arbitrary string Spectra use -memory backend file data stored -disk backends:","code":"spectraVariables(sps) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"dataStorage\"             \"dataOrigin\"              ##  [7] \"centroided\"              \"smoothed\"                ##  [9] \"polarity\"                \"precScanNum\"             ## [11] \"precursorMz\"             \"precursorIntensity\"      ## [13] \"precursorCharge\"         \"collisionEnergy\"         ## [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [17] \"isolationWindowUpperMz\"  \"id\"                      ## [19] \"name\" spectraVariables(sps_sciex) ##  [1] \"msLevel\"                  \"rtime\"                    ##  [3] \"acquisitionNum\"           \"scanIndex\"                ##  [5] \"dataStorage\"              \"dataOrigin\"               ##  [7] \"centroided\"               \"smoothed\"                 ##  [9] \"polarity\"                 \"precScanNum\"              ## [11] \"precursorMz\"              \"precursorIntensity\"       ## [13] \"precursorCharge\"          \"collisionEnergy\"          ## [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  ## [17] \"isolationWindowUpperMz\"   \"peaksCount\"               ## [19] \"totIonCurrent\"            \"basePeakMZ\"               ## [21] \"basePeakIntensity\"        \"ionisationEnergy\"         ## [23] \"lowMZ\"                    \"highMZ\"                   ## [25] \"mergedScan\"               \"mergedResultScanNum\"      ## [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   ## [29] \"injectionTime\"            \"filterString\"             ## [31] \"spectrumId\"               \"ionMobilityDriftTime\"     ## [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\" msLevel(sps) ## [1] 2 2 2 rtime(sps) ## [1] NA NA NA head(rtime(sps_sciex)) ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 sps$name ## [1] \"1-Methylhistidine\" \"1-Methylhistidine\" \"Caffeine\" sps$msLevel ## [1] 2 2 2 sps$centroided <- TRUE  centroided(sps) ## [1] TRUE TRUE TRUE sps$splash <- c(     \"splash10-00di-0900000000-037d24a7d65676b7e356\",     \"splash10-00di-0900000000-03e99316bd6c098f5d11\",     \"splash10-000i-0900000000-9af60e39c843cb715435\") mz(sps) ## NumericList of length 3 ## [[1]] 109.2 124.2 124.5 170.16 170.52 ## [[2]] 83.1 96.12 97.14 109.14 124.08 125.1 170.16 ## [[3]] 56.0494 69.0447 83.0603 109.0395 110.0712 111.0551 123.0429 138.0662 195.0876 intensity(sps) ## NumericList of length 3 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 pks <- peaksData(sps) pks[[1]] ##          mz intensity ## [1,] 109.20     3.407 ## [2,] 124.20    47.494 ## [3,] 124.50     3.094 ## [4,] 170.16   100.000 ## [5,] 170.52    13.240 as(sps, \"SimpleList\") ## List of length 3 spectraData(sps, columns = c(\"msLevel\", \"id\", \"name\")) ## DataFrame with 3 rows and 3 columns ##     msLevel          id              name ##   <integer> <character>       <character> ## 1         2 HMDB0000001 1-Methylhistidine ## 2         2 HMDB0000001 1-Methylhistidine ## 3         2 HMDB0001847          Caffeine dataOrigin(sps) ## [1] NA NA NA head(basename(dataOrigin(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" dataStorage(sps) ## [1] \"<memory>\" \"<memory>\" \"<memory>\" head(basename(dataStorage(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"filtering-subsetting-and-merging","dir":"Articles","previous_headings":"General usage","what":"Filtering, subsetting and merging","title":"Description and usage of Spectra objects","text":"Apart classical subsetting operations [ split, set filter functions defined Spectra objects (detailed help please see ?Spectra help): filterAcquisitionNum: retain spectra certain acquisition numbers. filterDataOrigin: subset spectra specific origins. filterDataStorage: subset spectra certain data storage files. filterEmptySpectra: remove spectra without mass peaks. filterMzRange: subset spectra keeping peaks m/z within provided m/z range. filterMzValues: subset spectra keeping removing peaks matching provided m/z value(s). filterIsolationWindow: keep spectra provided mz isolation window (m/z range). filterMsLevel: filter MS level. filterPolarity: filter polarity. filterPrecursorMzRange: retain (MSn) spectra precursor m/z within provided m/z range. filterPrecursorMzValues: retain (MSn) spectra precursor m/z value matching provided value(s) considering also tolerance ppm. filterPrecursorCharge: retain (MSn) spectra speified precursor charge(s). filterPrecursorScan: retain (parent children) scans acquisition number. filterRt: filter based retention time ranges. example select spectra measured second mzML file subsequently filter retain spectra measured 175 189 seconds measurement run. addition, Spectra support also subsetting [. perform filtering [ -based subsetting. equivalent using filter function shown , added benefit filtering recorded processing slot. Note use filter functions might efficient backends, depending implementation, (e.g. database-based backends translate filter function SQL condition perform subsetting already within database). Multiple Spectra objects can also combined single Spectra c concatenateSpectra function. resulting Spectra object contain union spectra variables individual objects. combine Spectra object sps additional object containing another MS2 spectrum Caffeine. Next combine two objects. resulting object contains now data 4 MS2 spectra union spectra variables objects. second object additional spectra variable instrument present sps spectra object thus get value NA variable. Sometimes spectra variables might required (e.g. also many empty). might specifically interesting also Spectra containing data large experiments, can significantly reduce object’s size memory. cases selectSpectraVariables function can used retain specified spectra variables.","code":"fls <- unique(dataOrigin(sps_sciex)) file_2 <- filterDataOrigin(sps_sciex, dataOrigin = fls[2]) length(file_2) ## [1] 931 sps_sub <- filterRt(file_2, rt = c(175, 189)) length(sps_sub) ## [1] 50 sps_sciex[sps_sciex$dataOrigin == fls[2] &           sps_sciex$rtime >= 175 &           sps_sciex$rtime <= 189] ## MSn data (Spectra) with 50 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           1   175.212       628 ## 2           1   175.491       629 ## 3           1   175.770       630 ## 4           1   176.049       631 ## 5           1   176.328       632 ## ...       ...       ...       ... ## 46          1   187.768       673 ## 47          1   188.047       674 ## 48          1   188.326       675 ## 49          1   188.605       676 ## 50          1   188.884       677 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML sps_sciex |>     filterDataOrigin(fls[2]) |>     filterRt(c(175, 189)) ## MSn data (Spectra) with 50 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           1   175.212       628 ## 2           1   175.491       629 ## 3           1   175.770       630 ## 4           1   176.049       631 ## 5           1   176.328       632 ## ...       ...       ...       ... ## 46          1   187.768       673 ## 47          1   188.047       674 ## 48          1   188.326       675 ## 49          1   188.605       676 ## 50          1   188.884       677 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select data origin(s) /__w/_temp/Library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML [Fri Apr  1 12:47:02 2022] ##  Filter: select retention time [175..189] on MS level(s) 1 [Fri Apr  1 12:47:02 2022] caf_df <- DataFrame(msLevel = 2L, name = \"Caffeine\",                     id = \"HMDB0001847\",                     instrument = \"Agilent 1200 RRLC; Agilent 6520 QTOF\",                     splash = \"splash10-0002-0900000000-413259091ba7edc46b87\",                     centroided = TRUE) caf_df$mz <- list(c(110.0710, 138.0655, 138.1057, 138.1742, 195.9864)) caf_df$intensity <- list(c(3.837, 32.341, 0.84, 0.534, 100))  caf <- Spectra(caf_df) sps <- concatenateSpectra(sps, caf) sps ## MSn data (Spectra) with 4 spectra in a MsBackendDataFrame backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Processing: ##  Merge 2 Spectra into one [Fri Apr  1 12:47:02 2022] spectraVariables(sps) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"dataStorage\"             \"dataOrigin\"              ##  [7] \"centroided\"              \"smoothed\"                ##  [9] \"polarity\"                \"precScanNum\"             ## [11] \"precursorMz\"             \"precursorIntensity\"      ## [13] \"precursorCharge\"         \"collisionEnergy\"         ## [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [17] \"isolationWindowUpperMz\"  \"id\"                      ## [19] \"name\"                    \"splash\"                  ## [21] \"instrument\" sps$instrument ## [1] NA                                     ## [2] NA                                     ## [3] NA                                     ## [4] \"Agilent 1200 RRLC; Agilent 6520 QTOF\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"data-manipulations","dir":"Articles","previous_headings":"General usage","what":"Data manipulations","title":"Description and usage of Spectra objects","text":"analyses require manipulation mass peak data (.e. m/z /intensity values). One example remove peaks spectrum intensity lower certain threshold. perform operation replaceIntensitiesBelow function replace peak intensities 10 spectrum sps value 0. result intensities 10 set 0 peaks. Zero-intensity peaks (peaks missing intensities) can removed filterIntensity function specifying lower required intensity level optionally also upper intensity limit. filterIntensity supports also user-provided function passed parameter intensity allow e.g. remove peaks smaller median peak intensity spectrum. See examples ?filterIntensity help page details. Note data manipulations Spectra objects immediately applied peak data. added called processing queue applied time peak data accessed (peaksData, mz intensity functions). Thanks processing queue data manipulation operations also possible read-backends (e.g. mzML-file based backends database-based backends). information number processing steps can seen (next Lazy evaluation queue). possible add also custom functions processing queue Spectra object. function must take peaks matrix first argument, ... function definition must return peaks matrix (peaks matrix numeric two-column matrix first column containing peaks’ m/z values second corresponding intensities). define function divides intensities peak value can passed argument y. Object sps_2 now 3 processing steps lazy evaluation queue. Calling intensity object now return intensities half intensities original objects sps. Alternatively define function returns maximum peak spectrum (note: use unname function remove names results): spectrum sps_2 thus contains single peak. parameter spectraVariables addProcessing function allows addition define spectra variables passed (addition peaks matrix) user-provided function. enable example calculate neutral loss spectra Spectra subtracting precursor m/z m/z spectrum. tool example precursor m/z values defined, thus first set arbitrary values. define function neutral_loss calculates difference precursor m/z fragment peak’s m/z. addition need ensure peaks resulting spectra ordered (delta) m/z values. Note , order able access precursor m/z spectrum within function, add parameter function name spectrum variable want access (case precursorMz). call addProcessing spectraVariables = \"precursorMz\" specify spectra variable passed along function. can see, precursor m/z subtracted m/z respective spectrum. better version function, calculates neutral loss spectra MS level 2 spectra neutral_loss function . Since accessing also spectrum’s MS level call addProcessing adding also spectra variable msLevel spectraVariables parameter. Note however msLevel spectra variable default renamed spectrumMsLevel prior passing function. thus use parameter called spectrumMsLevel neutral_loss function instead msLevel. Using concept also possible provide spectrum-specific user-defined value processing function. variable simply added first new spectra variable Spectra object variable passed along function way passed precursor m/z function . Since data manipulations change original intensity m/z values, possible restore original data. can done reset function empty lazy evaluation queue call reset method storage backend. call reset sps_2 object hence restore data original state. Finally, Spectra use writeable backend, MsBackendDataFrame MsBackendHdf5Peaks, possible apply processing queue peak data write back data storage applyProcessing function. use make data manipulations peak data sps_rep object persistent. applyProcessing lazy evaluation queue contained 2 processing steps, applied peak data written data storage. Note calling reset applyProcessing can longer restore data.","code":"sps_rep <- replaceIntensitiesBelow(sps, threshold = 10, value = 0) intensity(sps_rep) ## NumericList of length 4 ## [[1]] 0 47.494 0 100 13.24 ## [[2]] 0 0 0 16.708 100 0 40.643 ## [[3]] 0 0 0 0 0 0 0 100 40.994 ## [[4]] 0 32.341 0 0 100 sps_rep <- filterIntensity(sps_rep, intensity = c(0.1, Inf)) intensity(sps_rep) ## NumericList of length 4 ## [[1]] 47.494 100 13.24 ## [[2]] 16.708 100 40.643 ## [[3]] 100 40.994 ## [[4]] 32.341 100 sps_rep ## MSn data (Spectra) with 4 spectra in a MsBackendDataFrame backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Lazy evaluation queue: 2 processing step(s) ## Processing: ##  Merge 2 Spectra into one [Fri Apr  1 12:47:02 2022] ##  Signal <= 10 in MS level(s) 2 set to 0 [Fri Apr  1 12:47:02 2022] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Fri Apr  1 12:47:03 2022] ## Define a function that takes a matrix as input, divides the second ## column by parameter y and returns it. Note that ... is required in ## the function's definition. divide_intensities <- function(x, y, ...) {     x[, 2] <- x[, 2] / y     x }  ## Add the function to the procesing queue sps_2 <- addProcessing(sps_rep, divide_intensities, y = 2) sps_2 ## MSn data (Spectra) with 4 spectra in a MsBackendDataFrame backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Lazy evaluation queue: 3 processing step(s) ## Processing: ##  Merge 2 Spectra into one [Fri Apr  1 12:47:02 2022] ##  Signal <= 10 in MS level(s) 2 set to 0 [Fri Apr  1 12:47:02 2022] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Fri Apr  1 12:47:03 2022] intensity(sps_2) ## NumericList of length 4 ## [[1]] 23.747 50 6.62 ## [[2]] 8.354 50 20.3215 ## [[3]] 50 20.497 ## [[4]] 16.1705 50 intensity(sps_rep) ## NumericList of length 4 ## [[1]] 47.494 100 13.24 ## [[2]] 16.708 100 40.643 ## [[3]] 100 40.994 ## [[4]] 32.341 100 max_peak <- function(x, ...) {     unname(x[which.max(x[, 2]), , drop = FALSE]) }  sps_2 <- addProcessing(sps_rep, max_peak) lengths(sps_2) ## [1] 1 1 1 1 intensity(sps_2) ## NumericList of length 4 ## [[1]] 100 ## [[2]] 100 ## [[3]] 100 ## [[4]] 100 sps_rep$precursorMz <- c(150, 20, 30, 40)  neutral_loss <- function(x, precursorMz, ...) {     x[, \"mz\"] <- precursorMz - x[, \"mz\"]     x[order(x[, \"mz\"]), , drop = FALSE] } sps_3 <- addProcessing(sps_rep, neutral_loss, spectraVariables = \"precursorMz\") mz(sps_rep) ## NumericList of length 4 ## [[1]] 124.2 170.16 170.52 ## [[2]] 109.14 124.08 170.16 ## [[3]] 138.0662 195.0876 ## [[4]] 138.0655 195.9864 mz(sps_3) ## NumericList of length 4 ## [[1]] -20.52 -20.16 25.8 ## [[2]] -150.16 -104.08 -89.14 ## [[3]] -165.0876 -108.0662 ## [[4]] -155.9864 -98.0655 neutral_loss <- function(x, spectrumMsLevel, precursorMz, ...) {     if (spectrumMsLevel == 2L) {         x[, \"mz\"] <- precursorMz - x[, \"mz\"]         x <- x[order(x[, \"mz\"]), , drop = FALSE]     }     x } sps_3 <- addProcessing(sps_rep, neutral_loss,                        spectraVariables = c(\"msLevel\", \"precursorMz\")) mz(sps_3) ## NumericList of length 4 ## [[1]] -20.52 -20.16 25.8 ## [[2]] -150.16 -104.08 -89.14 ## [[3]] -165.0876 -108.0662 ## [[4]] -155.9864 -98.0655 sps_2_rest <- reset(sps_2)  intensity(sps_2_rest) ## NumericList of length 4 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 ## [[4]] 3.837 32.341 0.84 0.534 100 intensity(sps) ## NumericList of length 4 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 ## [[4]] 3.837 32.341 0.84 0.534 100 length(sps_rep@processingQueue) ## [1] 2 sps_rep <- applyProcessing(sps_rep) length(sps_rep@processingQueue) ## [1] 0 sps_rep ## MSn data (Spectra) with 4 spectra in a MsBackendDataFrame backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Processing: ##  Merge 2 Spectra into one [Fri Apr  1 12:47:02 2022] ##  Signal <= 10 in MS level(s) 2 set to 0 [Fri Apr  1 12:47:02 2022] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Fri Apr  1 12:47:03 2022] ##  ...1 more processings. Use 'processingLog' to list all."},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"visualizing-spectra","dir":"Articles","previous_headings":"General usage","what":"Visualizing Spectra","title":"Description and usage of Spectra objects","text":"Spectra package provides following functions visualize spectra data: - plotSpectra: plot spectrum Spectra panel. - plotSpectraOverlay: plot multiple spectra plot. use plotSpectra plot 4 spectra sps object using names (provided spectra variable \"name\") plot titles.  also possible label individual peaks plot. use m/z value peak label. example define function accesses information spectrum (z) returns character peak text used label. Parameters labelSrt, labelPos labelOffset define rotation label text position relative x y coordinates peak.  plots rather busy peaks m/z values overplotted. define label function indicate m/z peaks intensity higher 30.  Sometimes might interest plot multiple spectra plot (e.g. directly compare peaks multiple spectra). can done plotSpectraOverlay use create overlay-plot 4 example spectra, using different color spectrum.  Lastly, plotSpectraMirror allows plot two spectra mirror plot ideal visualize spectra comparison results. plot spectrum 1-Methylhistidine one Caffeine.  upper panel shows spectrum 1-Methylhistidine, lower one Caffeine. None peaks two spectra match. plot two spectra 1-Methylhistidine two Caffeine matching peaks ppm 50.  See also ?plotSpectra plotting options examples.","code":"plotSpectra(sps, main = sps$name) plotSpectra(sps, main = sps$name,             labels = function(z) format(mz(z)[[1L]], digits = 4),             labelSrt = -30, labelPos = 2, labelOffset = 0.1) mzLabel <- function(z) {     z <- peaksData(z)[[1L]]     lbls <- format(z[, \"mz\"], digits = 4)     lbls[z[, \"intensity\"] < 30] <- \"\"     lbls } plotSpectra(sps, main = sps$name, labels = mzLabel,             labelSrt = -30, labelPos = 2, labelOffset = 0.1) cols <- c(\"#E41A1C80\", \"#377EB880\", \"#4DAF4A80\", \"#984EA380\") plotSpectraOverlay(sps, lwd = 2, col = cols) legend(\"topleft\", col = cols, legend = sps$name, pch = 15) plotSpectraMirror(sps[1], sps[3]) par(mfrow = c(1, 2)) plotSpectraMirror(sps[1], sps[2], main = \"1-Methylhistidine\", ppm = 50) plotSpectraMirror(sps[3], sps[4], main = \"Caffeine\", ppm = 50)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"aggregating-spectra-data","dir":"Articles","previous_headings":"General usage","what":"Aggregating spectra data","title":"Description and usage of Spectra objects","text":"Spectra package provides combineSpectra function allows aggregate multiple spectra single one. main parameters function f, defines grouping spectra, FUN allows define function performs actual aggregation. default aggregation function combinePeaks (see ?combinePeaks details) combines multiple spectra single spectrum peaks input spectra (additional paramter peaks = \"union\"), peaks present certain proportion input spectra (parameter peaks = \"intersect\"; parameter minProp allows define minimum required proportion spectra peak needs present. use function combine spectra 1-methylhistidine caffeine single spectrum compound. use spectra variable $name, contains names compounds, define spectra grouped together. result, 4 spectra got aggregated two.  default, peaks present spectra reported. alternative, specifying peaks = \"intersect\" minProp = 1, combine spectra keeping peaks present input spectra.  results thus single peak 1-methylhistidine none caffeine - ? reason difference peaks’ m/z values larger default tolerance used peak grouping (defaults combinePeaks tolerance = 0 ppm = 0). however already see previous section reported peaks’ m/z values larger measurement error (likely fragment spectra measured different instruments different precision). Thus, next increase tolerance ppm parameters group also peaks larger difference m/z values.  Whether real analysis OK large tolerance however questionable. Note: m/z intensity reported aggregated spectra can defined parameters intensityFun mzFun combinePeaks (see ?combinePeaks information). combinePeaks function indeed helpful combine peaks different spectra, combineSpectra function addition also allow us provide , custom, peak aggregation function. simple example, instead combining spectra, like select one input spectra representative spectrum grouped input spectra. combineSpectra supports function takes list peak matrices input returns single peak matrix output. thus define function calculates total signal (TIC) input peak matrix, returns one peak matrix largest TIC. can now use function combineSpectra select compound spectrum largest TIC.","code":"sps_agg <- combineSpectra(sps, f = sps$name) plotSpectra(sps_agg, main = sps_agg$name) sps_agg <- combineSpectra(sps, f = sps$name, peaks = \"intersect\", minProp = 1) plotSpectra(sps_agg, main = sps_agg$name) sps_agg <- combineSpectra(sps, f = sps$name, peaks = \"intersect\",                           minProp = 1, tolerance = 0.2) plotSpectra(sps_agg, main = sps_agg$name) #' function to select and return the peak matrix with the largest tic from #' the provided list of peak matrices. maxTic <- function(x, ...) {     tic <- vapply(x, function(z) sum(z[, \"intensity\"], na.rm = TRUE),                   numeric(1))     x[[which.max(tic)]] } sps_agg <- combineSpectra(sps, f = sps$name, FUN = maxTic) plotSpectra(sps_agg, main = sps_agg$name)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"comparing-spectra","dir":"Articles","previous_headings":"General usage","what":"Comparing spectra","title":"Description and usage of Spectra objects","text":"Spectra can compared compareSpectra function, allows calculate similarities spectra using variety methods. However, peaks compared spectra first matched similarities can calculated. compareSpectra uses default [joinPeaks()] function MsCoreUtils package supports also mapping functions passed MAPFUN parameter (see ?joinPeaks man page MsCoreUtils details). similarity calculation function can specified FUN parameter defaults [ndotproduct()], normalized dot-product. details, see also (Rainer et al. 2022) SpectraTutorials tutorial. calculate pairwise similarities spectra sps accepting 50 ppm difference peaks’ m/z values considered matching. resulting matrix represents result pairwise comparison. expected, first two last two spectra similar, albeit moderately spectra 1-Methylhistidine don’t share similarity Caffeine.","code":"compareSpectra(sps, ppm = 50) ##           [,1]      [,2]      [,3]      [,4] ## [1,] 1.0000000 0.1380817 0.0000000 0.0000000 ## [2,] 0.1380817 1.0000000 0.0000000 0.0000000 ## [3,] 0.0000000 0.0000000 1.0000000 0.1817149 ## [4,] 0.0000000 0.0000000 0.1817149 1.0000000"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"exporting-spectra","dir":"Articles","previous_headings":"General usage","what":"Exporting spectra","title":"Description and usage of Spectra objects","text":"Spectra data can exported export method. method takes Spectra supposed exported backend (parameter backend) used export data additional parameters export function backend. backend thus defines format exported file. Note however MsBackend classes might support data export. backend classes currently supporting data export format : - MsBackendMzR (Spectra package): export data mzML mzXML format. Can export custom, user specified spectra variables. - MsBackendMgf (MsBackendMgf package): exports data Mascot Generic Format (mgf). Exports spectra variables individual spectrum fields mgf file. - MsBackendMsp (MsBackendMsp): exports data NIST MSP format. - MsBackendMassbank (MsBackendMassbank) exports data Massbank text file format. example use MsBackendMzR export spectra variable sps mzML file. thus pass data, backend used export file name result file (temporary file) export function (see also help page export,MsBackendMzR function additional supported parameters). evaluate spectra variables exported, load exported data identify spectra variables original file exported (defined variables mzML standard). additional variables thus exported. data export performed handled depends also used backend. MsBackendMzR example exports spectra default single file (specified file parameter), allows also specify individual spectrum Spectra file exported (parameter file thus length equal number spectra). example export spectrum 1 3 one file spectra 2 4 another. realistic use case mzML export export MS data processing, smoothing (using smooth function) centroiding (using pickPeaks function) raw profile-mode MS data.","code":"fl <- tempfile() export(sps, MsBackendMzR(), file = fl) ## Writing file file12b8361ac420...OK sps_im <- Spectra(backendInitialize(MsBackendMzR(), fl)) spectraVariables(sps)[!spectraVariables(sps) %in% spectraVariables(sps_im)] ## [1] \"id\"         \"name\"       \"splash\"     \"instrument\" fls <- c(tempfile(), tempfile()) export(sps, MsBackendMzR(), file = fls[c(1, 2, 1, 2)]) ## Writing file file12b8a59ff44...OK ## Writing file file12b87d4ca918...OK"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"changing-backends","dir":"Articles","previous_headings":"General usage","what":"Changing backends","title":"Description and usage of Spectra objects","text":"previous sections learned already Spectra object can use different backends actual data handling. also possible change backend Spectra different one setBackend function. example change (MsBackendMzR) backend sps_sciex object MsBackendDataFrame backend enable use data even without need keep original mzML files. change backend sps_sciex -memory MsBackendDataFrame backend. call full peak data imported original mzML files object. obviously impact object’s size, now much larger . dataStorage spectrum variable now changed, dataOrigin still keeps information originating files:","code":"print(object.size(sps_sciex), units = \"Mb\") ## 0.4 Mb sps_sciex <- setBackend(sps_sciex, MsBackendDataFrame()) sps_sciex ## MSn data (Spectra) with 1862 spectra in a MsBackendDataFrame backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ## Processing: ##  Switch backend from MsBackendMzR to MsBackendDataFrame [Fri Apr  1 12:47:10 2022] print(object.size(sps_sciex), units = \"Mb\") ## 52.4 Mb head(dataStorage(sps_sciex)) ## [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" head(basename(dataOrigin(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"parallel-processing-notes","dir":"Articles","previous_headings":"General usage","what":"Parallel processing notes","title":"Description and usage of Spectra objects","text":"functions Spectra support (use) parallel processing box. Peak data access manipulation methods perform default parallel processing per-file basis (.e. using dataStorage variable splitting factor). Spectra uses BiocParallel parallel processing functions use default registered parallel processing setup package.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"backends","dir":"Articles","previous_headings":"","what":"Backends","title":"Description and usage of Spectra objects","text":"Backends allow use different backends store mass spectrometry data providing via Spectra class unified interface use data. abstraction -disk -memory data modes MSnbase (Gatto, Gibb, Rainer 2020). Spectra package defines set example backends object extending base MsBackend class used instead. default backends : MsBackendDataFrame: mass spectrometry data stored (-memory) DataFrame. Keeping data memory guarantees high performance also, depending number mass peaks spectrum, much higher memory footprint. MsBackendMzR: backend keeps general spectra variables memory relies mzR package read mass peaks (m/z intensity values) original MS files -demand. MsBackendHdf5Peaks: similar MsBackendMzR backend reads peak data -demand disk spectra variables kept memory. peak data stored Hdf5 files guarantees scalability. mentioned backends support changing spectra variables, except MsBackendMzR support changing m/z intensity values mass peaks. example load data single mzML file use MsBackendHdf5Peaks backend data storage. hdf5path parameter allows us specify storage location HDF5 file. (possibly incomplete) list R packages providing additional backends add support additional data types storage options provided : MsBackendMgf: support import/export mass spectrometry files mascot generic format (MGF). MsBackendMassbank: support import/export access MassBank files/databases. MsBackendHmdb: support import MS2 spectra files xml-file format Human Metabolome Database (HMDB). MsBackendMsp: import MS2 spectra files MSP format.","code":"library(msdata) fl <- proteomics(full.names = TRUE)[5]  sps_tmt <- Spectra(fl, backend = MsBackendHdf5Peaks(), hdf5path = tempdir()) head(basename(dataStorage(sps_tmt))) ## [1] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [2] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [3] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [4] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [5] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [6] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Description and usage of Spectra objects","text":"","code":"sessionInfo() ## R Under development (unstable) (2022-03-14 r81896) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ##  ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ## [1] msdata_0.35.3        Spectra_1.5.16       ProtGenerics_1.27.2  ## [4] BiocParallel_1.29.18 S4Vectors_0.33.15    BiocGenerics_0.41.2  ## [7] BiocStyle_2.23.1     ##  ## loaded via a namespace (and not attached): ##  [1] Rcpp_1.0.8.3        highr_0.9           bslib_0.3.1         ##  [4] compiler_4.2.0      BiocManager_1.30.16 jquerylib_0.1.4     ##  [7] rhdf5filters_1.7.0  tools_4.2.0         ncdf4_1.19          ## [10] digest_0.6.29       rhdf5_2.39.6        jsonlite_1.8.0      ## [13] evaluate_0.15       memoise_2.0.1       clue_0.3-60         ## [16] rlang_1.0.2         cli_3.2.0           yaml_2.3.5          ## [19] parallel_4.2.0      pkgdown_2.0.2.9000  xfun_0.30           ## [22] fastmap_1.1.0       cluster_2.1.3       stringr_1.4.0       ## [25] knitr_1.38          desc_1.4.1          fs_1.5.2            ## [28] sass_0.4.1          systemfonts_1.0.4   IRanges_2.29.1      ## [31] MsCoreUtils_1.7.4   rprojroot_2.0.2     Biobase_2.55.0      ## [34] R6_2.5.1            textshaping_0.3.6   rmarkdown_2.13      ## [37] bookdown_0.25       Rhdf5lib_1.17.3     mzR_2.29.5          ## [40] purrr_0.3.4         magrittr_2.0.3      codetools_0.2-18    ## [43] htmltools_0.5.2     MASS_7.3-56         ragg_1.2.2          ## [46] stringi_1.7.6       cachem_1.0.6"},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"RforMassSpectrometry Package Maintainer. Maintainer. Laurent Gatto. Author. Johannes Rainer. Author. Sebastian Gibb. Author. Jan Stanstrup. Contributor.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J, Vicini , Salzer L, Stanstrup J, Badia JM, Neumann S, Stravs MA, Verri Hernandes V, Gatto L, Gibb S Wittin M. Modular Expandable Ecosystem Metabolomics Data Annotation R Metabolites 2022, 12, 173. https://doi.org/10.3390/metabo12020173","code":"@Article{,   title = {A Modular and Expandable Ecosystem for Metabolomics Data Annotation in R},   author = {Johannes Rainer and Andrea Vicini and Liesa Salzer and Jan Stanstrup and Josep M. Badia and Steffen Neumann and Michael A. Stravs and Vinicius {Verri Hernandes} and Laurent Gatto and Sebastian Gibb and Michael Witting},   journal = {Metabolites},   year = {2022},   doi = {10.3390/metabo12020173},   url = {https://www.mdpi.com/2218-1989/12/2/173},   volume = {12},   pages = {173}, }"},{"path":"https://rformassspectrometry.github.io/Spectra/index.html","id":"low-level-infrastructure-to-handle-ms-spectra","dir":"","previous_headings":"","what":"Spectra Infrastructure for Mass Spectrometry Data","title":"Spectra Infrastructure for Mass Spectrometry Data","text":"Spectra package defines efficient infrastructure storing handling mass spectrometry spectra functionality subset, process, visualize compare spectra data. provides different implementations (backends) store mass spectrometry data. comprise backends tuned fast data access processing backends large data sets ensuring small memory footprint.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":null,"dir":"Reference","previous_headings":"","what":"Mass spectrometry data backends — MsBackend","title":"Mass spectrometry data backends — MsBackend","text":"Note classes described meant used directly end-users material man page aimed package developers. MsBackend virtual class defines different backend needs provide. MsBackend objects provide access mass spectrometry data. backends can classified -memory -disk backends, depending data, .e spectra (m/z intensities) spectra annotation (MS level, charge, polarity, ...) stored. Typically, -memory backends keep data memory ensuring fast data access, -disk backends store (parts ) data disk retrieve demand. Backend functions implementation notes new backend classes section documents API backend must implement. Currently available backends : MsBackendDataFrame: stores data memory using DataFrame. MsBackendMzR: stores m/z intensities -disk raw data files (typically mzML mzXML) spectra annotation information (header) memory DataFrame. backend requires mzR package. MsBackendHdf5Peaks: stores m/z intensities -disk custom hdf5 data files remaining spectra variables memory (DataFrame). backend requires rhdf5 package. See details individual backends.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mass spectrometry data backends — MsBackend","text":"","code":"# S4 method for MsBackend backendInitialize(object, ...)  # S4 method for list backendMerge(object, ...)  # S4 method for MsBackend backendMerge(object, ...)  # S4 method for MsBackend export(object, ...)  # S4 method for MsBackend acquisitionNum(object)  # S4 method for MsBackend peaksData(object)  # S4 method for MsBackend centroided(object)  # S4 method for MsBackend centroided(object) <- value  # S4 method for MsBackend collisionEnergy(object)  # S4 method for MsBackend collisionEnergy(object) <- value  # S4 method for MsBackend dataOrigin(object)  # S4 method for MsBackend dataOrigin(object) <- value  # S4 method for MsBackend dataStorage(object)  # S4 method for MsBackend dataStorage(object) <- value  # S4 method for MsBackend dropNaSpectraVariables(object)  # S4 method for MsBackend filterAcquisitionNum(object, n, file, ...)  # S4 method for MsBackend filterDataOrigin(object, dataOrigin = character())  # S4 method for MsBackend filterDataStorage(object, dataStorage = character())  # S4 method for MsBackend filterEmptySpectra(object, ...)  # S4 method for MsBackend filterIsolationWindow(object, mz = numeric(), ...)  # S4 method for MsBackend filterMsLevel(object, msLevel = integer())  # S4 method for MsBackend filterPolarity(object, polarity = integer())  # S4 method for MsBackend filterPrecursorMzRange(object, mz = numeric())  # S4 method for MsBackend filterPrecursorMz(object, mz = numeric())  # S4 method for MsBackend filterPrecursorMzValues(object, mz = numeric(), ppm = 20, tolerance = 0)  # S4 method for MsBackend filterPrecursorCharge(object, z = integer())  # S4 method for MsBackend filterPrecursorScan(object, acquisitionNum = integer(), f = dataOrigin(object))  # S4 method for MsBackend filterRt(object, rt = numeric(), msLevel. = unique(msLevel(object)))  # S4 method for MsBackend intensity(object)  # S4 method for MsBackend intensity(object) <- value  # S4 method for MsBackend ionCount(object)  # S4 method for MsBackend isCentroided(object, ...)  # S4 method for MsBackend isEmpty(x)  # S4 method for MsBackend isolationWindowLowerMz(object)  # S4 method for MsBackend isolationWindowLowerMz(object) <- value  # S4 method for MsBackend isolationWindowTargetMz(object)  # S4 method for MsBackend isolationWindowTargetMz(object) <- value  # S4 method for MsBackend isolationWindowUpperMz(object)  # S4 method for MsBackend isolationWindowUpperMz(object) <- value  # S4 method for MsBackend isReadOnly(object)  # S4 method for MsBackend length(x)  # S4 method for MsBackend msLevel(object)  # S4 method for MsBackend mz(object)  # S4 method for MsBackend mz(object) <- value  # S4 method for MsBackend lengths(x, use.names = FALSE)  # S4 method for MsBackend polarity(object)  # S4 method for MsBackend polarity(object) <- value  # S4 method for MsBackend precScanNum(object)  # S4 method for MsBackend precursorCharge(object)  # S4 method for MsBackend precursorIntensity(object)  # S4 method for MsBackend precursorMz(object)  # S4 method for MsBackend peaksData(object) <- value  # S4 method for MsBackend reset(object)  # S4 method for MsBackend rtime(object)  # S4 method for MsBackend rtime(object) <- value  # S4 method for MsBackend scanIndex(object)  # S4 method for MsBackend selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for MsBackend smoothed(object)  # S4 method for MsBackend smoothed(object) <- value  # S4 method for MsBackend spectraData(object, columns = spectraVariables(object))  # S4 method for MsBackend spectraData(object) <- value  # S4 method for MsBackend spectraNames(object)  # S4 method for MsBackend spectraNames(object) <- value  # S4 method for MsBackend spectraVariables(object)  # S4 method for MsBackend,ANY split(x, f, drop = FALSE, ...)  # S4 method for MsBackend tic(object, initial = TRUE)  # S4 method for MsBackend [(x, i, j, ..., drop = FALSE)  # S4 method for MsBackend $(x, name)  # S4 method for MsBackend $(x, name) <- value  # S4 method for MsBackend [[(x, i, j, ...)  # S4 method for MsBackend [[(x, i, j, ...) <- value  MsBackendDataFrame()  # S4 method for MsBackendDataFrame backendInitialize(object, data, ...)  MsBackendHdf5Peaks()  MsBackendMzR()"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mass spectrometry data backends — MsBackend","text":"object Object extending MsBackend. ... Additional arguments. value replacement value <- methods. See individual method description expected data type. n filterAcquisitionNum: integer acquisition numbers filter . file filterFile: index name file(s) data subsetted. export: character length 1 equal number spectra. dataOrigin filterDataOrigin: character define spectra keep. filterAcquisitionNum: optionally specify filtering occurr spectra selected dataOrigin. dataStorage filterDataStorage: character define spectra keep. filterAcquisitionNum: optionally specify filtering occur spectra selected dataStorage. mz filterIsolationWindow: numeric(1) m/z value filter object. filterPrecursorMzRange: numeric(2) lower upper m/z boundary. filterPrecursorMzValues: numeric m/z value(s) filter object. msLevel integer defining MS level spectra function applied. filterMsLevel: MS level object subsetted. polarity filterPolarity: integer specifying polarity subset object. ppm filterPrecursorMzValues: numeric(1) m/z-relative maximal acceptable difference m/z considered matching. See closest() details. tolerance filterPrecursorMzValues: numeric(1) maximal absolute acceptable difference m/z value considered matching. See closest() details. z filterPrecursorCharge: integer() precursor charges used filter. acquisitionNum filterPrecursorScan: integer acquisition number spectra object subsetted. f factor defining grouping split x. See split(). filterPrecursorScan: factor defining original data files spectra derive avoid selecting spectra different samples/files. Defaults f = dataOrigin(object). rt filterRt: numeric(2) defining retention time range used subset/filter object. msLevel. msLevel . x Object extending MsBackend. use.names lengths: whether spectrum names used. spectraVariables selectSpectraVariables: character names spectra variables backend subsetted. columns spectraData accessor: optional character column names (spectra variables) included returned DataFrame. default, columns returned. drop [: considered. initial tic: logical(1) whether initially reported total ion current reported, whether total ion current (re)calculated actual data (initial = FALSE). [: integer, logical character subset object. j [: supported. name $ $<-: name spectra variable return set. data backendInitialize: DataFrame spectrum metadata/data. parameter can empty MsBackendMzR backends needs provided MsBackendDataFrame backends.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mass spectrometry data backends — MsBackend","text":"See documentation respective function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Mass spectrometry data backends — MsBackend","text":"Backends extending MsBackend must implement methods (listed ). Developers new MsBackends follow MsBackendDataFrame implementation. ensure new implementation conform MsBackend definition, developers included test suites provided package unit test setup. variable created package's \"testthat.R\" file represents (initialized) instance developed backend. path test suites defined test_suite <- system.file(\"test_backends\", \"test_MsBackend\", package = \"Spectra\") followed test_dir(test_suite) run test files directory. Individual unit test files run test_file(file.path(test_suite, \"test_spectra_variables.R\"), stop_on_failure = TRUE) (note without stop_on_failure = TRUE tests fail silently) . Adding code packages \"testthat.R\" file ensures tests checking validity MsBackend instance defined Spectra package also run newly develped backend class. MsBackend defines following slots: @readonly: logical(1) whether backend supports writing/replacing m/z intensity values. Backends extending MsBackend must implement methods (listed ). Developers new MsBackends follow MsBackendDataFrame implementation. MsBackendCached() backend provides caching mechanism allow read backends add change spectra variables. backend used , meant extended. See MsBackendCached() details. MsBackend defines following slots: @readonly: logical(1) whether backend supports writing/replacing m/z intensity values.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"backend-functions","dir":"Reference","previous_headings":"","what":"Backend functions","title":"Mass spectrometry data backends — MsBackend","text":"New backend classes must extend base MsBackend class implement following methods: [: subset backend. subsetting element (row/) allowed $, $<-: access set/add single spectrum variable (column) backend. [[, [[<-: access set/add single spectrum variable (column) backend. default implementation uses $, thus methods implemented new classes extending MsBackend. acquisitionNum: returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). peaksData returns list spectras' peak data. length list equal number spectra object. element list matrix columns \"mz\" \"intensity\". empty spectrum, matrix 0 rows two columns (named mz intensity) returned. backendInitialize: initialises backend. method supposed called rights creating instance backend class prepare backend (e.g. set data memory backend read spectra header data MsBackendMzR backend). method ensure set spectra variable dataStorage correctly. backendMerge: merges (combines) MsBackend objects single instance. objects merged type (e.g. MsBackendDataFrame()). dataOrigin: gets character length equal number spectra object data origin spectrum. e.g. mzML file data read. dataStorage: gets character length equal number spectra object data storage spectrum. Note dataStorage NA_character_ supported. dropNaSpectraVariables: removes spectra variables (.e. columns object's spectraData contain missing values (NA). Note columns NAs removed, spectraData call dropNaSpectraVariables might still show columns containing NA values core spectra variables. centroided, centroided<-: gets sets centroiding information spectra. centroided returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided estimating spectrum data whether spectrum centroided.  value centroided<- either single logical logical length equal number spectra object. collisionEnergy, collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. export: exports data Spectra class file. method called export,Spectra method passes second argument function. export,MsBackend implementation thus expected take Spectra class second argument data exported. Taking data Spectra class ensures also eventual data manipulations (cached Spectra's lazy evaluation queue) applied prior export - possible MsBackend class. example implementation export method MsBackendMzR backend supports export data mzML mzXML format. See documentation MsBackendMzR class information. filterAcquisitionNum: filters object keeping spectra matching provided acquisition numbers (argument n). dataOrigin dataStorage also provided, object subsetted spectra acquisition number equal n spectra matching dataOrigin dataStorage values retaining spectra. filterDataOrigin: filters object retaining spectra matching provided dataOrigin. Parameter dataOrigin type character needs match exactly data origin value spectra subset. filterDataOrigin return data ordered provided dataOrigin parameter, .e. dataOrigin = c(\"2\", \"1\") provided, spectra resulting object ordered accordingly (first spectra data origin \"2\" \"1\"). Implementation method optional since default implementation MsBackend available. filterDataStorage: filters object retaining spectra matching provided dataStorage. Parameter dataStorage type character needs match exactly data storage value spectra subset. filterDataStorage return data ordered provided dataStorage parameter, .e. dataStorage = c(\"2\", \"1\") provided, spectra resulting object ordered accordingly (first spectra data storage \"2\" \"1\"). Implementation method optional since default implementation MsBackend available. filterEmptySpectra: removes empty spectra (.e. spectra without peaks). Implementation method optional since default implementation MsBackend available. filterFile: retains data files matching file index file name provided parameter file. filterIsolationWindow: retains spectra contain mz isolation window m/z range (.e. isolationWindowLowerMz <= mz isolationWindowUpperMz >= mz. Implementation method optional since default implementation MsBackend available. filterMsLevel: retains spectra MS level msLevel. Implementation method optional since default implementation MsBackend available. filterPolarity: retains spectra polarity polarity. Implementation method optional since default implementation MsBackend available. filterPrecursorMzRange (previously filterPrecursorMz): retains spectra precursor m/z within provided m/z range. Implementation method optional since default implementation MsBackend available. filterPrecursorMzValues: retains spectra precursor m/z matching provided m/z values (given ppm tolerance). Implementation method optional since default implementation MsBackend available. filterPrecursorCharge: retains spectra defined precursor charge(s). Implementation method optional since default implementation MsBackend available. filterPrecursorScan: retains parent (e.g. MS1) children scans (e.g. MS2) acquisition number acquisitionNum. Parameter f supposed define origin spectra (.e. original data file) ensure related spectra file/sample selected retained. Implementation method optional since default implementation MsBackend available. filterRt: retains spectra MS level msLevel retention times within (>=) rt[1] (<=) rt[2]. Implementation method optional since default implementation MsBackend available. intensity: gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. intensity<-: replaces intensity values. value list (NumericList()) length equal number spectra number values within list element identical number peaks spectrum (.e. lengths(x)). Note just writeable backends support method. ionCount: returns numeric sum intensities spectrum. spectrum empty (see isEmpty), NA_real_ returned. isCentroided: heuristic approach assessing spectra object profile centroided mode. function takes qtl th quantile top peaks, calculates difference adjacent m/z value returns TRUE first quartile greater k. (See Spectra:::.peaks_is_centroided code.) isEmpty: checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz, isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz, isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz, isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. isReadOnly: returns logical(1) whether backend read allow also write/update data. length: returns number spectra object. lengths: gets number peaks (m/z-intensity values) per spectrum.  Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel: gets spectra's MS level. Returns integer vector (length equal number spectra) MS level spectrum (NA_integer_ available). mz: gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. mz<-: replaces m/z values. value list length equal number spectra number values within list element identical number peaks spectrum (.e. lengths(x)). Note just writeable backends support method. polarity, polarity<-: gets sets polarity spectrum.  polarity returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge, precursorIntensity, precursorMz, precScanNum, precAcquisitionNum: get charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. peaksData<- replaces peak data (m/z intensity values) backend. method expects list matrix objects columns \"mz\" \"intensity\" length number spectra backend. Note just writeable backends support method. reset backend (supported). method called backend reset,Spectra method supposed restore data original state (see reset,Spectra details). function returns reset backend. default implementation MsBackend returns backend -. rtime, rtime<-: gets sets retention times spectrum (seconds). rtime returns numeric vector (length equal number spectra) retention time spectrum. rtime<- expects numeric vector length equal number spectra. scanIndex: returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum spectrum index spectrum reported mzML file. selectSpectraVariables: reduces information within backend selected spectra variables. smoothed,smoothed<-: gets sets whether spectrum smoothed. smoothed returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraData, spectraData<-: gets sets general spectrum metadata (annotation, also called header).  spectraData returns DataFrame, spectraData<- expects DataFrame number rows spectra object. Note spectraData return full data, .e. also m/z intensity values (list SimpleList columns \"mz\" \"intensity\". spectraNames: returns character vector names spectra object NULL set. spectraNames<- allows set spectra names (object read-). spectraVariables: returns character vector available spectra variables (columns, fields attributes) available object. return spectra variables present object, also \"mz\" \"intensity\" (default returned spectraVariables,Spectra method). split: splits backend list backends (depending parameter f). default method MsBackend uses split.default(), thus backends extending MsBackend necessarily need implement method. tic: gets total ion current/count (sum signal spectrum) spectra object. default, value reported original raw data file returned. empty spectrum, NA_real_ returned.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"subsetting-and-merging-backend-classes","dir":"Reference","previous_headings":"","what":"Subsetting and merging backend classes","title":"Mass spectrometry data backends — MsBackend","text":"Backend classes must support (implement) [ method subset object. method support subsetting spectra (rows, ) return MsBackend class. Backends extending MsBackend also implement backendMerge method support combining backend instances (backend classes type merged). Merging follow following rules: whole spectrum data various objects merged. resulting merged object contain union individual objects' spectra variables (columns/fields), eventually missing variables one object filled NA.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"msbackenddataframe-in-memory-ms-data-backend","dir":"Reference","previous_headings":"","what":"MsBackendDataFrame, in-memory MS data backend","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendDataFrame objects keep MS data memory. New objects can created MsBackendDataFrame() function. backend can subsequently initialized backendInitialize method, taking DataFrame MS data parameter. Suggested columns DataFrame : \"msLevel\": integer MS levels spectra. \"rt\": numeric retention times spectra. \"acquisitionNum\": integer acquisition number spectrum. \"scanIndex\": integer index scan/spectrum within mzML/mzXML/CDF file. \"dataOrigin\": character defining data origin. \"dataStorage\": character indicating grouping spectra different e.g. input files. Note missing values supported. \"centroided\": logical whether spectrum centroided. \"smoothed\": logical whether spectrum smoothed. \"polarity\": integer polarity information spectra. \"precScanNum\": integer specifying index (MS1) spectrum containing precursor (MS2) spectrum. \"precursorMz\": numeric m/z value precursor. \"precursorIntensity\": numeric intensity value precursor. \"precursorCharge\": integer charge precursor. \"collisionEnergy\": numeric collision energy. \"mz\": NumericList() numeric vectors representing m/z values spectrum. \"intensity\": NumericList() numeric vectors representing intensity values spectrum. Additional columns allowed .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"msbackendmzr-on-disk-ms-data-backend","dir":"Reference","previous_headings":"","what":"MsBackendMzR, on-disk MS data backend","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendMzR keeps limited amount data memory, spectra data (m/z intensity values) fetched raw files -demand. backend uses mzR package data import retrieval hence requires package installed. Also, can used import represent data stored mzML, mzXML CDF files. MsBackendMzR backend extends MsBackendDataFrame backend using DataFrame keep spectra variables (except m/z intensity) memory. New objects can created MsBackendMzR() function can subsequently filled data calling backendInitialize passing file names input data files argument files. backend provides export method export data Spectra mzML mzXML format. definition function : export(object, x, file = tempfile(), format = c(\"mzML\", \"mzXML\"), copy = FALSE) parameters : object: instance MsBackendMzR class. x: Spectra object exported. file: character (full) output file name(s). length 1 equal length(x). single file specified, spectra exported file. Alternatively possible specify spectrum x name file exported (hence file length equal length(x)). format: character(1), either \"mzML\" \"mzXML\" defining output file format. copy: logical(1) whether general file information copied original MS data files. works x uses MsBackendMzR backend dataOrigin(x) contains original MS data file names. BPPARAM: parallel processing settings. See examples Spectra vignette details examples.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"msbackendhdf-peaks-on-disk-ms-data-backend","dir":"Reference","previous_headings":"","what":"MsBackendHdf5Peaks, on-disk MS data backend","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendHdf5Peaks keeps, similar MsBackendMzR, peak data (.e. m/z intensity values) custom data files (HDF5 format) disk remaining spectra variables kept memory. backend supports updating writing manipulated peak data data files. New objects can created MsBackendHdf5Peaks() function can subsequently filled data calling object's backendInitialize method passing desired file names HDF5 data files along spectra variables form DataFrame (see MsBackendDataFrame expected format). optional parameter hdf5path allows specify folder HDF5 data files stored . provided, added path submitted file names (parameter files). default backendInitialize store peak data single HDF5 file name provided parameter files. store peak data across several HDF5 files data contain column \"dataStorage\" defines grouping spectra/peaks files: peaks spectra value \"dataStorage\" saved HDF5 file. parameter files omitted, value dataStorage used file name (replacing file ending \".h5\". specify file names, files' length match number unique elements \"dataStorage\". details see examples Spectra() help page.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mass spectrometry data backends — MsBackend","text":"Johannes Rainer, Sebastian Gibb, Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mass spectrometry data backends — MsBackend","text":"","code":"## The MsBackend class is a virtual class and can not be instantiated ## directly. Below we define a new backend class extending this virtual ## class MsBackendDummy <- setClass(\"MsBackendDummy\", contains = \"MsBackend\") MsBackendDummy() #> An object of class \"MsBackendDummy\" #> Slot \"readonly\": #> [1] FALSE #>  #> Slot \"version\": #> [1] \"0.1\" #>   ## This class inherits now all methods from `MsBackend`, all of which ## however throw an error. These methods would have to be implemented ## for the new backend class. try(mz(MsBackendDummy())) #> Error in .local(object, ...) : Not implemented for MsBackendDummy.  ## See `MsBackendDataFrame` as a reference implementation for a backend ## class (in the *R/MsBackendDataFrame.R* file).  ## MsBackendDataFrame ## ## The `MsBackendDataFrame` uses a `S4Vectors::DataFrame` to store all MS ## data. Below we create such a backend by passing a `DataFrame` with all ## data to it. data <- DataFrame(msLevel = c(1L, 2L, 1L), scanIndex = 1:3) data$mz <- list(c(1.1, 1.2, 1.3), c(1.4, 54.2, 56.4, 122.1), c(15.3, 23.2)) data$intensity <- list(c(3, 2, 3), c(45, 100, 12.2, 1), c(123, 12324.2))  ## Backends are supposed to be created with their specific constructor ## function be <- MsBackendDataFrame()  be #> MsBackendDataFrame with 0 spectra  ## The `backendInitialize` method initializes the backend filling it with ## data. This method can take any parameters needed for the backend to ## get loaded with the data (e.g. a file name from which to load the data, ## a database connection or, in this case, a data frame containing the data). be <- backendInitialize(be, data)  be #> MsBackendDataFrame with 3 spectra #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1        NA         1 #> 2         2        NA         2 #> 3         1        NA         3 #>  ... 16 more variables/columns.  ## Data can be accessed with the accessor methods msLevel(be) #> [1] 1 2 1  mz(be) #> NumericList of length 3 #> [[1]] 1.1 1.2 1.3 #> [[2]] 1.4 54.2 56.4 122.1 #> [[3]] 15.3 23.2  ## Even if no data was provided for all spectra variables, its accessor ## methods are supposed to return a value. precursorMz(be) #> [1] NA NA NA  ## The `peaksData` method is supposed to return the peaks of the spectra as ## a `list`. peaksData(be) #> [[1]] #>       mz intensity #> [1,] 1.1         3 #> [2,] 1.2         2 #> [3,] 1.3         3 #>  #> [[2]] #>         mz intensity #> [1,]   1.4      45.0 #> [2,]  54.2     100.0 #> [3,]  56.4      12.2 #> [4,] 122.1       1.0 #>  #> [[3]] #>        mz intensity #> [1,] 15.3     123.0 #> [2,] 23.2   12324.2 #>"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":null,"dir":"Reference","previous_headings":"","what":"Base MsBackend class providing data caching mechanism — MsBackendCached","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"MsBackendCached class rudimentary implementation MsBackend providing simple mechanism cache spectra data locally. class thought used base class MsBackend implementations reuse caching mechanism avoid re-implement commonly used methods. class thus thought used directly user. MsBackendCached caching mechanism allows MsBackend instances add replace spectra variables even backend used allow alter values (e.g. SQL database used backend). replacement operation $<- add specified values local data.frame within MsBackendCached class allows cache values (increasing obviously memory demand object). data accessor functions extending MsBackend class ($ msLevel spectraData) first use callNextMethod call respective accessor MsBackendCached evaluate requested spectra variable(s) local cache return . requested spectra variables neither local cache, listed @spectraVariables slot (defines spectra variables can requested extending MsBackend class) core spectra variables missing values correct data type returned.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"","code":"MsBackendCached()  # S4 method for MsBackendCached backendInitialize(   object,   data = data.frame(),   nspectra = 0L,   spectraVariables = character(),   ... )  # S4 method for MsBackendCached dataStorage(object)  # S4 method for MsBackendCached length(x)  # S4 method for MsBackendCached spectraVariables(object)  # S4 method for MsBackendCached spectraData(object, columns = spectraVariables(object))  # S4 method for MsBackendCached spectraData(object) <- value  # S4 method for MsBackendCached [(x, i, j, ..., drop = FALSE)  # S4 method for MsBackendCached $(x, name)  # S4 method for MsBackendCached $(x, name) <- value  # S4 method for MsBackendCached selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for MsBackendCached show(object)  # S4 method for MsBackendCached acquisitionNum(object)  # S4 method for MsBackendCached centroided(object)  # S4 method for MsBackendCached centroided(object) <- value  # S4 method for MsBackendCached collisionEnergy(object)  # S4 method for MsBackendCached collisionEnergy(object) <- value  # S4 method for MsBackendCached dataOrigin(object)  # S4 method for MsBackendCached dataOrigin(object) <- value  # S4 method for MsBackendCached msLevel(object)  # S4 method for MsBackendCached intensity(object)  # S4 method for MsBackendCached ionCount(object)  # S4 method for MsBackendCached isEmpty(x)  # S4 method for MsBackendCached isolationWindowLowerMz(object)  # S4 method for MsBackendCached isolationWindowLowerMz(object) <- value  # S4 method for MsBackendCached isolationWindowTargetMz(object)  # S4 method for MsBackendCached isolationWindowTargetMz(object) <- value  # S4 method for MsBackendCached isolationWindowUpperMz(object)  # S4 method for MsBackendCached isolationWindowUpperMz(object) <- value  # S4 method for MsBackendCached lengths(x, use.names = FALSE)  # S4 method for MsBackendCached mz(object)  # S4 method for MsBackendCached polarity(object)  # S4 method for MsBackendCached polarity(object) <- value  # S4 method for MsBackendCached precursorCharge(object)  # S4 method for MsBackendCached precursorIntensity(object)  # S4 method for MsBackendCached precursorMz(object)  # S4 method for MsBackendCached rtime(object)  # S4 method for MsBackendCached rtime(object) <- value  # S4 method for MsBackendCached scanIndex(object)  # S4 method for MsBackendCached smoothed(object)  # S4 method for MsBackendCached smoothed(object) <- value"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"object MsBackendCached object. data backendInitialize: (optional) data.frame cached values. number rows (order) match number spectra. nspectra backendInitialize: integer number spectra. spectraVariables backendInitialize: character names spectra variables provided extending backend. selectSpectraVariables: character specifying spectra variables keep. ... ignored x MsBackendCached object. columns spectraData: character names spectra variables retrieve. value replacement value <- methods. See individual method description expected data type. [: integer indices subset object. j [: ignored. drop [: considered. name $<-: name spectra variable set. use.names lengths: whether spectrum names used.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"See documentation respective function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"Classes extending MsBackendCached need call backendInitialize method class backendInitialize method set least number spectra nspectra parameter spectraVariables available (extending) backend class. implement spectraData method also calls spectraData method MsBackendCached also retrieve cached values (e.g. using res <- callNextMethod() beginning spectraData function). spectraData,MsBackendCached method return NULL selected spectra variables cached core spectra variables provided extending backend. Thus, extending backend can proceed retrieve respective values backend/data storage. implement eventually [ method calls addition [ MsBackendCached. methods accessing setting spectra variables need implemented extending backend class (default implementations MsBackendCached used instead; ensure cached values returned first). Spectra variables can modified added using $<- method MsBackendCached. Replacing adding multiple variables using spectraData<- supported MsBackendCached. extending backend might however implement method internally uses $<- add/replace single variables. MsBackendCached following slots: nspectra: integer(1) defining number spectra backend. variable needs set must match number rows localData actual number spectra (extending) backend. localData: data.frame cached local data. replacement operation $<- set/add column respective values. spectraVariables: character defining spectra variables provided extending MsBackend class (e.g. spectra variables can retrieved data base original data files).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"available-methods","dir":"Reference","previous_headings":"","what":"Available methods","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"acquisitionNum: returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). backendInitialize: initializes backend. method takes parameters data (data.frame cached data), nspectra (integer defining number spectra) spectraVariables (character spectra variables provided extending backend. centroided, centroided<-: gets sets centroiding information spectra. centroided returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided estimating spectrum data whether spectrum centroided.  value centroided<- either single logical logical length equal number spectra object. collisionEnergy, collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. dataOrigin: gets character length equal number spectra object data origin spectrum. e.g. mzML file data read. intensity: gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. ionCount: returns numeric sum intensities spectrum. spectrum empty (see isEmpty), NA_real_ returned. isEmpty: checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz, isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz, isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz, isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. length: returns number spectra (.e. @nspectra). lengths: gets number peaks (m/z-intensity values) per spectrum.  Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel: gets spectra's MS level. Returns integer vector (length equal number spectra) MS level spectrum (NA_integer_ available). mz: gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. polarity, polarity<-: gets sets polarity spectrum.  polarity returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge, precursorIntensity, precursorMz, precScanNum, precAcquisitionNum: get charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. rtime, rtime<-: gets sets retention times spectrum (seconds). rtime returns numeric vector (length equal number spectra) retention time spectrum. rtime<- expects numeric vector length equal number spectra. scanIndex: returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum spectrum index spectrum reported mzML file. selectSpectraVariables: subset object specified spectra variables. eventually remove spectra variables listed @spectraVariables also drop columns local cache among spectraVariables. smoothed,smoothed<-: gets sets whether spectrum smoothed. smoothed returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraVariables: returns available spectra variables, .e. unique set core spectra variables, cached spectra variables spectra variables defined @spectraVariables slot (.e. spectra variables thought provided extending MsBackend instance). spectraData: returns DataFrame cached spectra variablers initialized core spectra variables. Parameter spectraVariables allows specify variables retrieve. function returns NULL requested variables cached provided extending backend. Note method returns cached spectra variables core spectra variables provided extending backend. responsibility extending backend add/provide . [: subsets cached data. Parameter needs integer vector. $, $<-: access set/add single spectrum variable (column) backend.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":null,"dir":"Reference","previous_headings":"","what":"The Spectra class to manage and access MS data — applyProcessing","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra class encapsules spectral mass spectrometry data related metadata. supports multiple data backends, e.g. -memory (MsBackendDataFrame()), -disk mzML (MsBackendMzR()) HDF5 (MsBackendHdf5Peaks()).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Spectra class to manage and access MS data — applyProcessing","text":"","code":"applyProcessing(object, f = dataStorage(object), BPPARAM = bpparam(), ...)  concatenateSpectra(x, ...)  combineSpectra(   x,   f = x$dataStorage,   p = x$dataStorage,   FUN = combinePeaks,   ...,   BPPARAM = bpparam() )  joinSpectraData(x, y, by.x = \"spectrumId\", by.y, suffix.y = \".y\")  processingLog(x)  estimatePrecursorIntensity(   x,   ppm = 10,   tolerance = 0,   method = c(\"previous\", \"interpolation\"),   msLevel. = 2L,   f = dataOrigin(x),   BPPARAM = bpparam() )  # S4 method for missing Spectra(   object,   processingQueue = list(),   metadata = list(),   ...,   backend = MsBackendDataFrame(),   BPPARAM = bpparam() )  # S4 method for MsBackend Spectra(   object,   processingQueue = list(),   metadata = list(),   ...,   BPPARAM = bpparam() )  # S4 method for character Spectra(   object,   processingQueue = list(),   metadata = list(),   source = MsBackendMzR(),   backend = source,   ...,   BPPARAM = bpparam() )  # S4 method for ANY Spectra(   object,   processingQueue = list(),   metadata = list(),   source = MsBackendDataFrame(),   backend = source,   ...,   BPPARAM = bpparam() )  # S4 method for Spectra,MsBackend setBackend(object, backend, f = dataStorage(object), ..., BPPARAM = bpparam())  # S4 method for Spectra c(x, ...)  # S4 method for Spectra,ANY split(x, f, drop = FALSE, ...)  # S4 method for Spectra export(object, backend, ...)  # S4 method for Spectra acquisitionNum(object)  # S4 method for Spectra peaksData(object, ...)  # S4 method for Spectra centroided(object)  # S4 method for Spectra centroided(object) <- value  # S4 method for Spectra collisionEnergy(object)  # S4 method for Spectra collisionEnergy(object) <- value  # S4 method for Spectra dataOrigin(object)  # S4 method for Spectra dataOrigin(object) <- value  # S4 method for Spectra dataStorage(object)  # S4 method for Spectra dropNaSpectraVariables(object)  # S4 method for Spectra intensity(object, ...)  # S4 method for Spectra ionCount(object)  # S4 method for Spectra isCentroided(object, ...)  # S4 method for Spectra isEmpty(x)  # S4 method for Spectra isolationWindowLowerMz(object)  # S4 method for Spectra isolationWindowLowerMz(object) <- value  # S4 method for Spectra isolationWindowTargetMz(object)  # S4 method for Spectra isolationWindowTargetMz(object) <- value  # S4 method for Spectra isolationWindowUpperMz(object)  # S4 method for Spectra isolationWindowUpperMz(object) <- value  # S4 method for Spectra containsMz(   object,   mz = numeric(),   tolerance = 0,   ppm = 20,   which = c(\"any\", \"all\"),   BPPARAM = bpparam() )  # S4 method for Spectra containsNeutralLoss(   object,   neutralLoss = 0,   tolerance = 0,   ppm = 20,   BPPARAM = bpparam() )  # S4 method for Spectra spectrapply(   object,   FUN,   f = as.factor(seq_along(object)),   ...,   BPPARAM = SerialParam() )  # S4 method for Spectra length(x)  # S4 method for Spectra msLevel(object)  # S4 method for Spectra mz(object, ...)  # S4 method for Spectra lengths(x, use.names = FALSE)  # S4 method for Spectra polarity(object)  # S4 method for Spectra polarity(object) <- value  # S4 method for Spectra precScanNum(object)  # S4 method for Spectra precursorCharge(object)  # S4 method for Spectra precursorIntensity(object)  # S4 method for Spectra precursorMz(object)  # S4 method for Spectra rtime(object)  # S4 method for Spectra rtime(object) <- value  # S4 method for Spectra scanIndex(object)  # S4 method for Spectra selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for Spectra smoothed(object)  # S4 method for Spectra smoothed(object) <- value  # S4 method for Spectra spectraData(object, columns = spectraVariables(object))  # S4 method for Spectra spectraData(object) <- value  # S4 method for Spectra spectraNames(object)  # S4 method for Spectra spectraNames(object) <- value  # S4 method for Spectra spectraVariables(object)  # S4 method for Spectra tic(object, initial = TRUE)  # S4 method for Spectra $(x, name)  # S4 method for Spectra $(x, name) <- value  # S4 method for Spectra [[(x, i, j, ...)  # S4 method for Spectra [[(x, i, j, ...) <- value  # S4 method for Spectra [(x, i, j, ..., drop = FALSE)  # S4 method for Spectra filterAcquisitionNum(   object,   n = integer(),   dataStorage = character(),   dataOrigin = character() )  # S4 method for Spectra filterEmptySpectra(object)  # S4 method for Spectra filterDataOrigin(object, dataOrigin = character())  # S4 method for Spectra filterDataStorage(object, dataStorage = character())  # S4 method for Spectra filterFourierTransformArtefacts(   object,   halfWindowSize = 0.05,   threshold = 0.2,   keepIsotopes = TRUE,   maxCharge = 5,   isotopeTolerance = 0.005 )  # S4 method for Spectra filterIntensity(   object,   intensity = c(0, Inf),   msLevel. = unique(msLevel(object)),   ... )  # S4 method for Spectra filterIsolationWindow(object, mz = numeric())  # S4 method for Spectra filterMsLevel(object, msLevel. = integer())  # S4 method for Spectra filterMzRange(object, mz = numeric(), msLevel. = unique(msLevel(object)))  # S4 method for Spectra filterMzValues(   object,   mz = numeric(),   tolerance = 0,   ppm = 20,   msLevel. = unique(msLevel(object)),   keep = TRUE )  # S4 method for Spectra filterPolarity(object, polarity = integer())  # S4 method for Spectra filterPrecursorMz(object, mz = numeric())  # S4 method for Spectra filterPrecursorMzRange(object, mz = numeric())  # S4 method for Spectra filterPrecursorMzValues(object, mz = numeric(), ppm = 20, tolerance = 0)  # S4 method for Spectra filterPrecursorCharge(object, z = integer())  # S4 method for Spectra filterPrecursorScan(object, acquisitionNum = integer(), f = dataOrigin(object))  # S4 method for Spectra filterRt(object, rt = numeric(), msLevel. = unique(msLevel(object)))  # S4 method for Spectra reset(object, ...)  # S4 method for Spectra bin(x, binSize = 1L, breaks = NULL, msLevel. = unique(msLevel(x)))  # S4 method for Spectra,Spectra compareSpectra(   x,   y,   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 20,   FUN = ndotproduct,   ...,   SIMPLIFY = TRUE )  # S4 method for Spectra,missing compareSpectra(   x,   y = NULL,   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 20,   FUN = ndotproduct,   ...,   SIMPLIFY = TRUE )  # S4 method for Spectra pickPeaks(   object,   halfWindowSize = 2L,   method = c(\"MAD\", \"SuperSmoother\"),   snr = 0,   k = 0L,   descending = FALSE,   threshold = 0,   msLevel. = unique(msLevel(object)),   ... )  # S4 method for Spectra replaceIntensitiesBelow(   object,   threshold = min,   value = 0,   msLevel. = unique(msLevel(object)) )  # S4 method for Spectra smooth(   x,   halfWindowSize = 2L,   method = c(\"MovingAverage\", \"WeightedMovingAverage\", \"SavitzkyGolay\"),   msLevel. = unique(msLevel(x)),   ... )  # S4 method for Spectra addProcessing(object, FUN, ..., spectraVariables = character())  coreSpectraVariables()"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Spectra class to manage and access MS data — applyProcessing","text":"object Spectra: either DataFrame missing. See section creation Spectra objects details. methods Spectra object. f split: factor defining split x. See base::split() details. setBackend: factor defining split data parallelized copying spectra data new backend. backends changing parameter can lead errors. combineSpectra: factor defining grouping spectra combined. spectrapply: factor object splitted. estimatePrecursorIntensity filterPrecursorScan: defining spectra belong original data file (sample). Defaults f = dataOrigin(x). BPPARAM Parallel setup configuration. See bpparam() information. passed directly backendInitialize() method MsBackend. ... Additional arguments. x Spectra object. p combineSpectra: factor defining split input Spectra parallel processing. Defaults x$dataStorage, .e., depending used backend, per-file parallel processing performed. FUN addProcessing: function applied peak matrix spectrum object. compareSpectra: function compare intensities peaks two spectra . combineSpectra: function combine (peak matrices) spectra. See section Data manipulations examples details. y Spectra object. DataFrame joinSpectraData(). .x character(1) specifying spectra variable used merging. Default \"spectrumId\". .y character(1) specifying column used merging. Set .x missing. suffix.y character(1) specifying suffix used making names columns merged spectra variables unique. suffix used amend names(y), spectraVariables(x) remain unchanged. ppm compareSpectra, containsMz, filterMzValues: numeric(1) defining relative, m/z-dependent, maximal accepted difference m/z values peaks matched. tolerance compareSpectra, containsMz: numeric(1) allowing define constant maximal accepted difference m/z values peaks matched. containsMz filterMzValues can also length equal mz specify different tolerance m/z value. method pickPeaks: character(1), noise estimators used, currently Median Absolute Deviation (method = \"MAD\") Friedman's Super Smoother (method = \"SuperSmoother\") supported. smooth: character(1), smoothing function used, currently, Moving-Average- (method = \"MovingAverage\"), Weighted-Moving-Average- (method = \"WeightedMovingAverage\"), Savitzky-Golay-Smoothing (method = \"SavitzkyGolay\") supported. estimatePrecursorIntensity: character(1) defining whether precursor intensity estimated previous MS1 spectrum (method = \"previous\", default) based interpolation previous next MS1 spectrum (method = \"interpolation\"). msLevel. integer defining MS level(s) spectra function applied (defaults MS levels object. filterMsLevel: MS level object subsetted. processingQueue Spectra: optional list ProcessingStep objects. metadata Spectra: optional list metadata information. backend Spectra: MsBackend used backend. See section creation Spectra objects details. setBackend: instance MsBackend. See section creation Spectra objects details. export: MsBackend used export data. source Spectra: instance MsBackend can used import spectrum data provided files. See section Creation objects, conversion changing backend details. drop [, split: considered. value replacement value <- methods. See individual method description expected data type. mz filterIsolationWindow: numeric(1) m/z value filter object. filterPrecursorMz filterMzRange: numeric(2) defining lower upper m/z boundary. filterMzValues filterPrecursorMzValues: numeric m/z values match peaks precursor m/z . containsMz: either \"\" \"\" defining whether (default) provided mz present spectrum. neutralLoss containsNeutralLoss: numeric(1) defining value subtracted spectrum's precursor m/z. use.names lengths: ignored. spectraVariables selectSpectraVariables: character names spectra variables backend subsetted. addProcessing: character additional spectra variables passed along function defined FUN. See function description details. columns spectraData accessor: optional character column names (spectra variables) included returned DataFrame. default, columns returned. initial tic: logical(1) whether initially reported total ion current reported, whether total ion current (re)calculated actual data (initial = FALSE, ionCount). name $ $<-: name spectra variable return set. [: integer, logical character subset object. j [: supported. n filterAcquisitionNum: integer acquisition numbers filter . dataStorage filterDataStorage: character define spectra keep. filterAcquisitionNum: optionally specify filtering occur spectra selected dataStorage. dataOrigin filterDataOrigin: character define spectra keep. filterAcquisitionNum: optionally specify filtering occurr spectra selected dataOrigin. halfWindowSize pickPeaks: integer(1), used identification mass peaks: local maximum maximum window (- halfWindowSize):(+ halfWindowSize). smooth: integer(1), used smoothing algorithm, window reaches (- halfWindowSize):(+ halfWindowSize). filterFourierTransformArtefacts: numeric(1) defining m/z window left right peak remove fourier transform artefacts. threshold pickPeaks: double(1) defining proportion maximal peak intensity. Just values used weighted mean calculation. replaceIntensitiesBelow: numeric(1) defining threshold function calculate threshold spectrum intensity values. Defaults threshold = min. filterFourierTransformArtefacts: relative intensity (peak) peaks considered fourier artefacts. Defaults threshold = 0.2 hence removing peaks intensity 0.2 times intensity tested peak (within selected halfWindowSize). keepIsotopes filterFourierTransformArtefacts: whether isotope peaks removed fourier artefacts. maxCharge filterFourierTransformArtefacts: maximum charge considered isotopes. isotopeTolerance filterFourierTransformArtefacts: m/z tolerance used define whether peaks might isotopes current tested peak. intensity filterIntensity: numeric length 1 2 defining either lower lower upper intensity limit filtering, function takes intensities input returns logical (length peaks spectrum) whether peak retained . Defaults intensity = c(0, Inf) thus peaks NA intensity removed. keep filterMzValues: logical(1) whether matching peaks retained (keep = TRUE, default) dropped (keep = FALSE`). polarity filterPolarity: integer specifying polarity subset object. z filterPrecursorCharge: integer() precursor charges used filter. acquisitionNum filterPrecursorScan: integer acquisition number spectra object subsetted. rt filterRt: numeric(2) defining retention time range used subset/filter object. binSize bin: numeric(1) defining size m/z bins. Defaults binSize = 1. breaks bin: numeric defining m/z breakpoints bins. MAPFUN compareSpectra: function map/match peaks two compared spectra. See joinPeaks() information possible functions. SIMPLIFY compareSpectra whether result matrix simplified numeric possible (.e. either x y length 1). snr pickPeaks: double(1) defining Signal--Noise-Ratio. intensity local maximum higher snr * noise considered peak. k pickPeaks: integer(1), number values left right peak considered weighted mean calculation. descending pickPeaks: logical, TRUE just values nearest valleys around peak centroids used.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Spectra class to manage and access MS data — applyProcessing","text":"See individual method description return value.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra class uses default lazy data manipulation strategy, .e. data manipulations performed replaceIntensitiesBelow applied immediately data, applied --fly spectrum data retrieved. backends allow write data back data storage (MsBackendDataFrame() MsBackendHdf5Peaks()) possible apply queue applyProcessing function. See Data manipulation analysis methods section details. details plotting spectra, see plotSpectra(). Clarifications regarding scan/acquisition numbers indices: spectrumId (spectrumID) vendor specific field mzML file contains information run/spectrum, e.g.: controllerType=0 controllerNumber=1 scan=5281 file=2 acquisitionNum less sanitize spectrum id generated spectrumId field mzR (see ). scanIndex mzR generated sequence number spectrum raw file (acquisitionNum) See also issue.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"creation-of-objects-conversion-changing-the-backend-and-export","dir":"Reference","previous_headings":"","what":"Creation of objects, conversion, changing the backend and export","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra classes can created Spectra constructor function supports following formats: parameter object DataFrame containing spectrum data. provided backend (default MsBackendDataFrame) initialized data. parameter object MsBackend (assumed already initialized). parameter object missing, case supposed data provided MsBackend class passed along backend argument. parameter object type character expected file names(s) spectra imported. Parameter source allows define MsBackend able import data provided source files. default value source MsBackendMzR() allows import spectra data mzML, mzXML CDF files. ... additional arguments can passed backend's backendInitialize() method. Parameter backend allows specify MsBackend used data storage. backend Spectra object can changed setBackend method takes instance new backend second parameter backend. call setBackend(sps, backend = MsBackendDataFrame()) example change backend sps -memory MsBackendDataFrame. Note possible change backend read-backend (MsBackendMzR() backend). setBackend changes \"dataOrigin\" variable resulting Spectra object \"dataStorage\" variable backend switch. definition function : setBackend(object, backend, ..., f = dataStorage(object), BPPARAM = bpparam()) parameters : parameter object: Spectra object. parameter backend: instance new backend, e.g. MsBackendDataFrame(). parameter f: factor allowing parallelize change backends. default process copying spectra data original new backend performed separately (parallel) file. Users advised use default setting. parameter ...: optional additional arguments passed backendInitialize() method new backend. parameter BPPARAM: setup parallel processing. See bpparam() details. Data Spectra object can exported file export function. actual export data performed export method MsBackend class defined mandatory parameter backend. Note however backend classes support export data. MsBackend classes Spectra package currently MsBackendMzR backend supports data export (mzML/mzXML file(s)); see help page MsBackend information arguments examples vignette examples. definition function export(object, backend,  ...) parameters : object: Spectra object exported. backend: instance class extending MsBackend supports export data (.e. defined export method). ...: additional parameters specific MsBackend passed parameter backend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"accessing-spectra-data","dir":"Reference","previous_headings":"","what":"Accessing spectra data","title":"The Spectra class to manage and access MS data — applyProcessing","text":"$, $<-: gets (sets) spectra variable spectra object. See examples details. [[, [[<-: access set/add single spectrum variable (column) backend. acquisitionNum: returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). peaksData: gets peaks matrices spectra object. function returns SimpleList() matrices, matrix columns \"mz\" \"intensity\" m/z intensity values peaks spectrum. Note also possible extract peaks matrices (x, \"list\") (x, \"SimpleList\") list SimpleList, respectively. centroided, centroided<-: gets sets centroiding information spectra. centroided returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided estimating spectrum data whether spectrum centroided.  value centroided<- either single logical logical length equal number spectra object. collisionEnergy, collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. coreSpectraVariables: returns core spectra variables along expected data type. dataOrigin, dataOrigin<-: gets sets data origin spectrum. dataOrigin returns character vector (length object) origin spectra. dataOrigin<- expects character vector (length object) replacement values data origin spectrum. dataStorage: returns character vector (length object) data storage location spectrum. intensity: gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. ionCount: returns numeric sum intensities spectrum. spectrum empty (see isEmpty), NA_real_ returned. isCentroided: heuristic approach assessing spectra object profile centroided mode. function takes qtlth quantile top peaks, calculates difference adjacent m/z value returns TRUE first quartile greater k. (See Spectra:::.isCentroided code.) isEmpty: checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz, isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz, isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz, isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. containsMz: checks spectra whether contain mass peaks m/z equal mz (given acceptable difference defined parameters tolerance ppm - see common() details). Parameter allows define whether (= \"\", default) (= \"\") mz match. function returns NA mz length 0 NA. containsNeutralLoss: checks spectrum object peak m/z value equal precursor m/z - neutralLoss (given acceptable difference defined parameters tolerance ppm). Returns NA MS1 spectra (spectra without precursor m/z). length: gets number spectra object. lengths: gets number peaks (m/z-intensity values) per spectrum. Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel: gets spectra's MS level. Returns integer vector (names spectrum names, length equal number spectra) MS level spectrum. mz: gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. polarity, polarity<-: gets sets polarity spectrum.  polarity returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge, precursorIntensity, precursorMz, precScanNum, precAcquisitionNum: gets charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level > 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. rtime, rtime<-: gets sets retention times (seconds) spectrum.  rtime returns numeric vector (length equal number spectra) retention time spectrum.  rtime<- expects numeric vector length equal number spectra. scanIndex: returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum spectrum represents index spectrum acquisition/measurement (reported mzML file). smoothed,smoothed<-: gets sets whether spectrum smoothed. smoothed returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraData: gets general spectrum metadata (annotation, also called header). spectraData returns DataFrame. Note method default return m/z intensity values. spectraData<-: replaces full spectra data Spectra object one provided value. use function disencouraged, replacing spectra data values different can break linkage associated m/z intensity values. possible, spectra variables (.e. columns Spectra) replaced individually. spectraData<- function expects DataFrame passed value. spectraNames, spectraNames<-: gets sets spectra names. spectraVariables: returns character vector available spectra variables (columns, fields attributes) available object. tic: gets total ion current/count (sum signal spectrum) spectra object. default, value reported original raw data file returned. empty spectrum, 0 returned.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"data-subsetting-filtering-and-merging","dir":"Reference","previous_headings":"","what":"Data subsetting, filtering and merging","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Subsetting filtering Spectra objects can performed listed methods. [: subsets spectra keeping selected elements (). method always returns Spectra object. dropNaSpectraVariables: removes spectra variables (.e. columns object's spectraData contain missing values (NA). Note columns NAs removed, spectraData call dropNaSpectraVariables might still show columns containing NA values core spectra variables. filterAcquisitionNum: filters object keeping spectra matching provided acquisition numbers (argument n). dataOrigin dataStorage also provided, object subsetted spectra acquisition number equal n spectra matching dataOrigin dataStorage values retaining spectra. Returns filtered Spectra. filterDataOrigin: filters object retaining spectra matching provided dataOrigin. Parameter dataOrigin type character needs match exactly data origin value spectra subset. Returns filtered Spectra object (spectra ordered according provided dataOrigin parameter). filterDataStorage: filters object retaining spectra stored specified dataStorage. Parameter dataStorage type character needs match exactly data storage value spectra subset. Returns filtered Spectra object (spectra ordered according provided dataStorage parameter). filterEmptySpectra: removes empty spectra (.e. spectra without peaks). Returns filtered Spectra object (spectra original order). filterFourierTransformArtefacts: remove (Orbitrap) fast fourier artefact peaks spectra (see examples ). function iterates intensity ordered peaks spectrum removes peaks m/z within +/- halfWindowSize current peak intensity lower threshold times current peak's intensity. Additional parameters keepIsotopes, maxCharge isotopeTolerance allow avoid removing potential [13]C isotope peaks (maxCharge maximum charge considered isotopeTolerance absolute acceptable tolerance matching m/z). See filterFourierTransformArtefacts() details background. filterIsolationWindow: retains spectra contain mz isolation window m/z range (.e. isolationWindowLowerMz <= mz isolationWindowUpperMz >= mz. Returns filtered Spectra object (spectra original order). filterMsLevel: filters object MS level keeping spectra matching MS level specified argument msLevel. Returns filtered Spectra (spectra original order). filterMzRange: filters object keeping peaks spectrum within provided m/z range. filterMzValues: filters object keeping peaks spectrum match provided m/z value(s) (parameter keep = TRUE, default) removing (parameter keep = FALSE). m/z matching considers also absolute tolerance m/z-relative ppm values. tolerance ppm can either length 1 equal length mz define different matching tolerance provided m/z. filterPolarity: filters object keeping spectra matching provided polarity. Returns filtered Spectra (spectra original order). filterPrecursorMzRange (previously filterPrecursorMz now deprecated): retains spectra precursor m/z within provided m/z range. See examples details selecting spectra precursor m/z target m/z accepting small difference ppm. filterPrecursorMzValues: retains spectra precursor m/z matching provided m/z values (given ppm tolerance). Spectra missing precursor m/z value (e.g. MS1 spectra) dropped. filterPrecursorCharge: retains spectra defined precursor charge(s). filterPrecursorScan: retains parent (e.g. MS1) children scans (e.g. MS2) acquisition number acquisitionNum. Returns filtered Spectra (spectra original order). Parameter f allows define spectra belong sample original data file ( defaults f = dataOrigin(object)). filterRt: retains spectra MS level msLevel retention times (seconds) within (>=) rt[1] (<=) rt[2]. Returns filtered Spectra (spectra original order). reset: restores data original state (much possible): removes processing steps lazy processing queue calls reset backend , depending backend, can also undo e.g. data filtering operations. Note reset call applyProcessing effect. See examples information. selectSpectraVariables: reduces information within object selected spectra variables: data variables specified dropped. mandatory columns (msLevel, rtime ...) values dropped, additional (user defined) spectra variables completely removed. Returns filtered Spectra. split: splits Spectra object based parameter f list Spectra objects. joinSpectraData: Individual spectra variables can directly added $<- [[<- syntax. joinSpectraData() function allows merge DataFrame existing spectra data. function diverges merge() method two main ways: .x .y column names must length 1. variable names shared x y, spectra variables x modified. y variables appended suffix defined suffix.y. avoid modifying core spectra variables lead invalid object. Duplicated Spectra keys (.e. x[[.x]]) allowed. Duplicated keys DataFrame (.e y[[.y]]) throw warning last occurrence kept. explored ideally removed using QFeatures::reduceDataFrame(), PMS::reducePSMs() similar functions. Several Spectra objects can concatenated single object c concatenateSpectra function. Concatenation fail processing queue Spectra objects empty different backends used Spectra objects. spectra variables resulting Spectra object union spectra variables individual Spectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"data-manipulation-and-analysis-methods","dir":"Reference","previous_headings":"","what":"Data manipulation and analysis methods","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Many data manipulation operations, listed section, applied immediately spectra, added lazy processing/manipulation queue. Operations stored queue applied --fly spectra data time accessed. lazy execution guarantees functionality Spectra objects backend, .e. backends supporting save changes spectrum data (MsBackendDataFrame() MsBackendHdf5Peaks()) well read-backends (MsBackendMzR()). Note former possible apply processing queue write modified peak data back data storage applyProcessing function. addProcessing: adds arbitrary function applied peaks matrix every spectrum object. function (can passed parameter FUN) expected take peaks matrix input return peaks matrix. peaks matrix numeric matrix two columns, first containing m/z values peaks second corresponding intensities. function ... definition. Additional arguments can passed .... parameter spectraVariables possible define additional spectra variables object passed function FUN. passed name (e.g. specifying spectraVariables = \"precursorMz\" pass spectra's precursor m/z parameter named precursorMz function. exception spectra's MS level, passed function parameter called spectrumMsLevel (.e. spectraVariables = \"msLevel\" MS levels spectrum submitted function parameter called spectrumMsLevel). Examples provided package vignette. applyProcessing: Spectra objects use writeable backend : apply steps lazy processing queue peak data write back data storage. Parameter f allows specify object split parallel processing. either equal dataStorage, f = rep(1, length(object)) disable parallel processing alltogether. partitionings might result errors (especially MsBackendHdf5Peaks backend used). bin: aggregates individual spectra discrete (m/z) bins. intensity values peaks falling bin summed. combineSpectra: combine sets spectra single spectrum per set. spectrum group (set), spectra variables first spectrum used peak matrices combined using function specified FUN, defaults combinePeaks(). Please refer combinePeaks() help page details options actual combination peaks across sets spectra package vignette examples alternative ways aggregate spectra. sets spectra can specified parameter f. addition possible define, parameter p split input data parallel processing. defaults p = x$dataStorage hence per-file parallel processing applied Spectra file-based backends (MsBackendMzR()). Prior combination spectra processings queued lazy evaluation queue applied. aware calling combineSpectra Spectra object certain backends allow modifications might overwrite original data. happen MsBackendDataFrame backend, MsBackendHdf5Peaks backend m/z intensity values original hdf5 file(s) overwritten. function returns Spectra length equal unique levels f. compareSpectra: compare spectrum x spectrum y using function provided FUN (defaults ndotproduct()). y missing, spectrum x compared spectrum x. matching/mapping peaks compared spectra done MAPFUN function. default joinPeaks() matches peaks spectra allows keep peaks first spectrum (type = \"left\"), second (type = \"right\"), (type = \"outer\") keep matching peaks (type = \"inner\"); see joinPeaks() information examples). MAPFUN function parameters x, y, xPrecursorMz yPrecursorMz values passed function. addition joinPeaks() also joinPeaksGnps() supported GNPS-like similarity score calculations. FUN supposed function compare intensities (matched) peaks two spectra compared. function needs take two matrices columns \"mz\" \"intensity\" input supposed return single numeric result. addition two peak matrices spectra's precursor m/z values passed function parameters xPrecursorMz (precursor m/z x peak matrix) yPrecursorMz (precursor m/z y peak matrix). Additional parameters functions FUN MAPFUN can passed .... function returns matrix results FUN comparison, number rows equal length(x) number columns equal length(y) (.e. element row 2 column 3 result comparison x[2] y[3]). SIMPLIFY = TRUE matrix simplified numeric length x y one. estimatePrecursorIntensity: define precursor intensities MS2 spectra using intensity matching MS1 peak closest MS1 spectrum (.e. last MS1 spectrum measured respective MS2 spectrum). method = \"interpolation\" also possible calculate precursor intensity based interpolation intensity values (retention times) matching MS1 peaks previous next MS1 spectrum. See example. filterIntensity: filters spectrum keeping peaks intensities within provided range match criteria provided function. former, parameter intensity numeric defining intensity range, latter function takes intensity values spectrum returns logical whether peak retained (see examples details) - additional parameters function can passed .... remove peaks intensities certain threshold, say 100, use intensity = c(100, Inf). Note: also single value can passed intensity parameter case upper limit Inf used. Note function removes also peaks missing intensities (.e. intensity NA). Parameter msLevel. allows restrict filtering spectra specified MS level(s). neutralLoss: calculate neutral loss spectra fragment spectra. See neutralLoss() detailed documentation. processingLog: returns character vector processing log messages. spectrapply: apply given function spectrum Spectra object. Spectra splitted individual spectra (.e. Spectra length 1) function FUN applied. Additional parameters FUN can passed ... argument. Parameter BPPARAM allows enable parallel processing, however makes sense FUN computational intense. spectrapply returns list (length object) result FUN. See examples details. Note result order depends factor f used splitting object split, .e. re-ordering unsplit performed result. smooth: smooth individual spectra using moving window-based approach (window size = 2 * halfWindowSize). Currently, Moving-Average- (method = \"MovingAverage\"), Weighted-Moving-Average- (method = \"WeightedMovingAverage\"), weights depending distance center calculated 1/2^(-halfWindowSize:halfWindowSize)) Savitzky-Golay-Smoothing (method = \"SavitzkyGolay\") supported. details choose correct halfWindowSize please see MsCoreUtils::smooth(). pickPeaks: picks peaks individual spectra using moving window-based approach (window size = 2 * halfWindowSize). noisy spectra currently two different noise estimators available, Median Absolute Deviation (method = \"MAD\") Friedman's Super Smoother (method = \"SuperSmoother\"), implemented MsCoreUtils::noise(). method supports also optionally refine m/z value identified centroids considering data points belong (likely) mass peak. Therefore m/z value calculated intensity weighted average m/z values within peak region. peak region defined m/z values (respective intensities) 2 * k closest signals centroid closest valleys (descending = TRUE) 2 * k region. latter k chosen general larger. See MsCoreUtils::refineCentroids() details. ratio signal highest intensity peak threshold ignored weighted average. replaceIntensitiesBelow: replaces intensities specified threshold provided value. Parameter threshold can either single numeric value function applied non-NA intensities spectrum determine threshold value spectrum. default threshold = min replaces values <= minimum intensity spectrum value (default value 0). Note function specified threshold expected parameter na.rm since na.rm = TRUE passed function. spectrum profile mode, ranges successive non-0 peaks <= threshold set 0. Parameter msLevel. allows apply spectra certain MS level(s).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Sebastian Gibb, Johannes Rainer, Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Spectra class to manage and access MS data — applyProcessing","text":"","code":"## Create a Spectra providing a `DataFrame` containing the spectrum data.  spd <- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2)) spd$mz <- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2)) spd$intensity <- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))  data <- Spectra(spd) data #> MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 16 more variables/columns.  ## Get the number of spectra length(data) #> [1] 2  ## Get the number of peaks per spectrum lengths(data) #> [1] 4 3  ## Create a Spectra from mzML files and use the `MsBackendMzR` on-disk ## backend. sciex_file <- dir(system.file(\"sciex\", package = \"msdata\"),     full.names = TRUE) sciex <- Spectra(sciex_file, backend = MsBackendMzR()) sciex #> MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: #>        msLevel     rtime scanIndex #>      <integer> <numeric> <integer> #> 1            1     0.280         1 #> 2            1     0.559         2 #> 3            1     0.838         3 #> 4            1     1.117         4 #> 5            1     1.396         5 #> ...        ...       ...       ... #> 1858         1   258.636       927 #> 1859         1   258.915       928 #> 1860         1   259.194       929 #> 1861         1   259.473       930 #> 1862         1   259.752       931 #>  ... 33 more variables/columns. #>  #> file(s): #> 20171016_POOL_POS_1_105-134.mzML #> 20171016_POOL_POS_3_105-134.mzML  ## The MS data is on disk and will be read into memory on-demand. We can ## however change the backend to a MsBackendDataFrame backend which will ## keep all of the data in memory. sciex_im <- setBackend(sciex, MsBackendDataFrame()) sciex_im #> MSn data (Spectra) with 1862 spectra in a MsBackendDataFrame backend: #>        msLevel     rtime scanIndex #>      <integer> <numeric> <integer> #> 1            1     0.280         1 #> 2            1     0.559         2 #> 3            1     0.838         3 #> 4            1     1.117         4 #> 5            1     1.396         5 #> ...        ...       ...       ... #> 1858         1   258.636       927 #> 1859         1   258.915       928 #> 1860         1   259.194       929 #> 1861         1   259.473       930 #> 1862         1   259.752       931 #>  ... 33 more variables/columns. #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Fri Apr  1 12:46:29 2022]   ## The on-disk object `sciex` is light-weight, because it does not keep the ## MS peak data in memory. The `sciex_im` object in contrast keeps all the ## data in memory and its size is thus much larger. object.size(sciex) #> 395512 bytes object.size(sciex_im) #> 54926736 bytes  ## The spectra variable `dataStorage` returns for each spectrum the location ## where the data is stored. For in-memory objects: head(dataStorage(sciex_im)) #> [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\"  ## While objects that use an on-disk backend will list the files where the ## data is stored. head(dataStorage(sciex)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"  ## The spectra variable `dataOrigin` returns for each spectrum the *origin* ## of the data. If the data is read from e.g. mzML files, this will be the ## original mzML file name: head(dataOrigin(sciex)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" head(dataOrigin(sciex_im)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"  ## ---- ACCESSING AND ADDING DATA ----  ## Get the MS level for each spectrum. msLevel(data) #> [1] 1 2  ## Alternatively, we could also use $ to access a specific spectra variable. ## This could also be used to add additional spectra variables to the ## object (see further below). data$msLevel #> [1] 1 2  ## Get the intensity and m/z values. intensity(data) #> NumericList of length 2 #> [[1]] 200 400 34.2 17 #> [[2]] 12.3 15.2 6.8 mz(data) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 45.6 120.4 190.2  ## Determine whether one of the spectra has a specific m/z value containsMz(data, mz = 120.4) #> [1] FALSE  TRUE  ## Accessing spectra variables works for all backends: intensity(sciex) #> NumericList of length 1862 #> [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0 #> [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0 #> [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0 #> [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0 #> [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0 #> [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0 #> [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0 #> [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0 #> [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0 #> [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0 #> ... #> <1852 more elements> intensity(sciex_im) #> NumericList of length 1862 #> [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0 #> [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0 #> [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0 #> [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0 #> [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0 #> [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0 #> [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0 #> [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0 #> [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0 #> [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0 #> ... #> <1852 more elements>  ## Get the m/z for the first spectrum. mz(data)[[1]] #> [1] 100.0 103.2 104.3 106.5  ## Get the peak data (m/z and intensity values). pks <- peaksData(data) pks #> List of length 2 pks[[1]] #>         mz intensity #> [1,] 100.0     200.0 #> [2,] 103.2     400.0 #> [3,] 104.3      34.2 #> [4,] 106.5      17.0 pks[[2]] #>         mz intensity #> [1,]  45.6      12.3 #> [2,] 120.4      15.2 #> [3,] 190.2       6.8  ## Note that we could get the same resulb by coercing the `Spectra` to ## a `list` or `SimpleList`: as(data, \"list\") #> [[1]] #>         mz intensity #> [1,] 100.0     200.0 #> [2,] 103.2     400.0 #> [3,] 104.3      34.2 #> [4,] 106.5      17.0 #>  #> [[2]] #>         mz intensity #> [1,]  45.6      12.3 #> [2,] 120.4      15.2 #> [3,] 190.2       6.8 #>  as(data, \"SimpleList\") #> List of length 2  ## List all available spectra variables (i.e. spectrum data and metadata). spectraVariables(data) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"   ## For all *core* spectrum variables accessor functions are available. These ## return NA if the variable was not set. centroided(data) #> [1] NA NA dataStorage(data) #> [1] \"<memory>\" \"<memory>\" rtime(data) #> [1] 1.1 1.2 precursorMz(data) #> [1] NA NA  ## The core spectra variables are: coreSpectraVariables() #>                 msLevel                   rtime          acquisitionNum  #>               \"integer\"               \"numeric\"               \"integer\"  #>               scanIndex                      mz               intensity  #>               \"integer\"           \"NumericList\"           \"NumericList\"  #>             dataStorage              dataOrigin              centroided  #>             \"character\"             \"character\"               \"logical\"  #>                smoothed                polarity             precScanNum  #>               \"logical\"               \"integer\"               \"integer\"  #>             precursorMz      precursorIntensity         precursorCharge  #>               \"numeric\"               \"numeric\"               \"integer\"  #>         collisionEnergy  isolationWindowLowerMz isolationWindowTargetMz  #>               \"numeric\"               \"numeric\"               \"numeric\"  #>  isolationWindowUpperMz  #>               \"numeric\"   ## Add an additional metadata column. data$spectrum_id <- c(\"sp_1\", \"sp_2\")  ## List spectra variables, \"spectrum_id\" is now also listed spectraVariables(data) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"  \"spectrum_id\"              ## Get the values for the new spectra variable data$spectrum_id #> [1] \"sp_1\" \"sp_2\"  ## Extract specific spectra variables. spectraData(data, columns = c(\"spectrum_id\", \"msLevel\")) #> DataFrame with 2 rows and 2 columns #>   spectrum_id   msLevel #>   <character> <integer> #> 1        sp_1         1 #> 2        sp_2         2  ## Drop spectra variable data and/or columns. res <- selectSpectraVariables(data, c(\"mz\", \"intensity\"))  ## This removed the additional columns \"spectrum_id\" and deleted all values ## for all spectra variables, except \"mz\" and \"intensity\". spectraData(res) #> DataFrame with 2 rows and 17 columns #>     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin #>   <integer> <numeric>      <integer> <integer> <character> <character> #> 1        NA        NA             NA        NA    <memory>          NA #> 2        NA        NA             NA        NA    <memory>          NA #>   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity #>    <logical> <logical> <integer>   <integer>   <numeric>          <numeric> #> 1         NA        NA        NA          NA          NA                 NA #> 2         NA        NA        NA          NA          NA                 NA #>   precursorCharge collisionEnergy isolationWindowLowerMz #>         <integer>       <numeric>              <numeric> #> 1              NA              NA                     NA #> 2              NA              NA                     NA #>   isolationWindowTargetMz isolationWindowUpperMz #>                 <numeric>              <numeric> #> 1                      NA                     NA #> 2                      NA                     NA  ## Compared to the data before selectSpectraVariables. spectraData(data) #> DataFrame with 2 rows and 18 columns #>     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin #>   <integer> <numeric>      <integer> <integer> <character> <character> #> 1         1       1.1             NA        NA    <memory>          NA #> 2         2       1.2             NA        NA    <memory>          NA #>   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity #>    <logical> <logical> <integer>   <integer>   <numeric>          <numeric> #> 1         NA        NA        NA          NA          NA                 NA #> 2         NA        NA        NA          NA          NA                 NA #>   precursorCharge collisionEnergy isolationWindowLowerMz #>         <integer>       <numeric>              <numeric> #> 1              NA              NA                     NA #> 2              NA              NA                     NA #>   isolationWindowTargetMz isolationWindowUpperMz spectrum_id #>                 <numeric>              <numeric> <character> #> 1                      NA                     NA        sp_1 #> 2                      NA                     NA        sp_2   ## ---- SUBSETTING, FILTERING AND COMBINING  ## Subset to all MS2 spectra. data[msLevel(data) == 2] #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         2       1.2        NA #>  ... 17 more variables/columns.  ## Same with the filterMsLevel function filterMsLevel(data, 2) #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         2       1.2        NA #>  ... 17 more variables/columns. #> Processing: #>  Filter: select MS level(s) 2 [Fri Apr  1 12:46:31 2022]   ## Below we combine the `data` and `sciex_im` objects into a single one. data_comb <- c(data, sciex_im)  ## The combined Spectra contains a union of all spectra variables: head(data_comb$spectrum_id) #> [1] \"sp_1\" \"sp_2\" NA     NA     NA     NA     head(data_comb$rtime) #> [1] 1.100 1.200 0.280 0.559 0.838 1.117 head(data_comb$dataStorage) #> [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" head(data_comb$dataOrigin) #> [1] NA                                                                 #> [2] NA                                                                 #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"  ## Filter a Spectra for a target precursor m/z with a tolerance of 10ppm spd$precursorMz <- c(323.4, 543.2302) data_filt <- Spectra(spd) filterPrecursorMzRange(data_filt, mz = 543.23 + ppm(c(-543.23, 543.23), 10)) #> MSn data (Spectra) with 0 spectra in a MsBackendDataFrame backend: #> Processing: #>  Filter: select spectra with a precursor m/z within [543.2354323, 543.2354323] [Fri Apr  1 12:46:31 2022]   ## Filter a Spectra keeping only peaks matching certain m/z values sps_sub <- filterMzValues(data, mz = c(103, 104), tolerance = 0.3) mz(sps_sub) #> NumericList of length 2 #> [[1]] 103.2 104.3 #> [[2]] numeric(0)  ## This function can also be used to remove specific peaks from a spectrum ## by setting `keep = FALSE`. sps_sub <- filterMzValues(data, mz = c(103, 104),     tolerance = 0.3, keep = FALSE) mz(sps_sub) #> NumericList of length 2 #> [[1]] 100 106.5 #> [[2]] 45.6 120.4 190.2  ## Filter a Spectra keeping only peaks within a m/z range sps_sub <- filterMzRange(data, mz = c(100, 300)) mz(sps_sub) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 120.4 190.2  ## Remove empty spectra variables sciex_noNA <- dropNaSpectraVariables(sciex)  ## Available spectra variables before and after dropNaSpectraVariables spectraVariables(sciex) #>  [1] \"msLevel\"                  \"rtime\"                    #>  [3] \"acquisitionNum\"           \"scanIndex\"                #>  [5] \"dataStorage\"              \"dataOrigin\"               #>  [7] \"centroided\"               \"smoothed\"                 #>  [9] \"polarity\"                 \"precScanNum\"              #> [11] \"precursorMz\"              \"precursorIntensity\"       #> [13] \"precursorCharge\"          \"collisionEnergy\"          #> [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  #> [17] \"isolationWindowUpperMz\"   \"peaksCount\"               #> [19] \"totIonCurrent\"            \"basePeakMZ\"               #> [21] \"basePeakIntensity\"        \"ionisationEnergy\"         #> [23] \"lowMZ\"                    \"highMZ\"                   #> [25] \"mergedScan\"               \"mergedResultScanNum\"      #> [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   #> [29] \"injectionTime\"            \"filterString\"             #> [31] \"spectrumId\"               \"ionMobilityDriftTime\"     #> [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"     spectraVariables(sciex_noNA) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"  \"peaksCount\"              #> [19] \"totIonCurrent\"           \"basePeakMZ\"              #> [21] \"basePeakIntensity\"       \"ionisationEnergy\"        #> [23] \"lowMZ\"                   \"highMZ\"                  #> [25] \"injectionTime\"           \"spectrumId\"                ## Adding new spectra variables sciex1 <- filterDataOrigin(sciex, dataOrigin(sciex)[1]) spv <- DataFrame(spectrumId = sciex1$spectrumId[3:12], ## used for merging                  var1 = rnorm(10),                  var2 = sample(letters, 10)) spv #> DataFrame with 10 rows and 3 columns #>                spectrumId      var1        var2 #>               <character> <numeric> <character> #> 1  sample=1 period=1 cy.. -1.399420           c #> 2  sample=1 period=1 cy.. -0.786817           n #> 3  sample=1 period=1 cy..  0.124463           z #> 4  sample=1 period=1 cy..  1.152566           e #> 5  sample=1 period=1 cy..  0.424950           s #> 6  sample=1 period=1 cy.. -0.678662           q #> 7  sample=1 period=1 cy..  0.676167           j #> 8  sample=1 period=1 cy.. -0.146476           b #> 9  sample=1 period=1 cy..  0.125902           d #> 10 sample=1 period=1 cy.. -0.838577           r  sciex2 <- joinSpectraData(sciex1, spv, by.y = \"spectrumId\")  spectraVariables(sciex2) #>  [1] \"msLevel\"                  \"rtime\"                    #>  [3] \"acquisitionNum\"           \"scanIndex\"                #>  [5] \"dataStorage\"              \"dataOrigin\"               #>  [7] \"centroided\"               \"smoothed\"                 #>  [9] \"polarity\"                 \"precScanNum\"              #> [11] \"precursorMz\"              \"precursorIntensity\"       #> [13] \"precursorCharge\"          \"collisionEnergy\"          #> [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  #> [17] \"isolationWindowUpperMz\"   \"peaksCount\"               #> [19] \"totIonCurrent\"            \"basePeakMZ\"               #> [21] \"basePeakIntensity\"        \"ionisationEnergy\"         #> [23] \"lowMZ\"                    \"highMZ\"                   #> [25] \"mergedScan\"               \"mergedResultScanNum\"      #> [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   #> [29] \"injectionTime\"            \"filterString\"             #> [31] \"spectrumId\"               \"ionMobilityDriftTime\"     #> [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"     #> [35] \"var1\"                     \"var2\"                     spectraData(sciex2)[1:13, c(\"spectrumId\", \"var1\", \"var2\")] #> DataFrame with 13 rows and 3 columns #>                 spectrumId      var1        var2 #>                <character> <numeric> <character> #> 1   sample=1 period=1 cy..        NA          NA #> 2   sample=1 period=1 cy..        NA          NA #> 3   sample=1 period=1 cy.. -1.399420           c #> 4   sample=1 period=1 cy.. -0.786817           n #> 5   sample=1 period=1 cy..  0.124463           z #> ...                    ...       ...         ... #> 9   sample=1 period=1 cy..  0.676167           j #> 10  sample=1 period=1 cy.. -0.146476           b #> 11  sample=1 period=1 cy..  0.125902           d #> 12  sample=1 period=1 cy.. -0.838577           r #> 13  sample=1 period=1 cy..        NA          NA  ## Removing fourier transform artefacts seen in Orbitra data.  ## Loading an Orbitrap spectrum with artefacts. data(fft_spectrum) plotSpectra(fft_spectrum, xlim = c(264.5, 265.5))  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   fft_spectrum <- filterFourierTransformArtefacts(fft_spectrum) fft_spectrum #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Fri Apr  1 12:46:32 2022]  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## Using a few examples peaks in your data you can optimize the parameters fft_spectrum_filtered <- filterFourierTransformArtefacts(fft_spectrum,                                                halfWindowSize = 0.2,                                                threshold = 0.005,                                                keepIsotopes = TRUE,                                                maxCharge = 5,                                                isotopeTolerance = 0.005                                                )  fft_spectrum_filtered #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 2 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Fri Apr  1 12:46:32 2022] #>  Remove fast fourier artefacts. [Fri Apr  1 12:46:32 2022]  length(mz(fft_spectrum_filtered)[[1]]) #> [1] 297 plotSpectra(fft_spectrum_filtered, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## ---- DATA MANIPULATIONS AND OTHER OPERATIONS ----  ## Set the data to be centroided centroided(data) <- TRUE  ## Replace peak intensities below 40 with 3. res <- replaceIntensitiesBelow(data, threshold = 40, value = 3) res #> MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 17 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Signal <= 40 in MS level(s) 1, 2 set to 0 [Fri Apr  1 12:46:32 2022]   ## Get the intensities of the first and second spectrum. intensity(res)[[1]] #> [1] 200 400   3   3 intensity(res)[[2]] #> [1] 3 3 3  ## Remove all peaks with an intensity below 40. res <- filterIntensity(res, intensity = c(40, Inf))  ## Get the intensities of the first and second spectrum. intensity(res)[[1]] #> [1] 200 400 intensity(res)[[2]] #> numeric(0)  ## Lengths of spectra is now different lengths(mz(res)) #> [1] 2 0 lengths(mz(data)) #> [1] 4 3  ## In addition it is possible to pass a function to `filterIntensity`: in ## the example below we want to keep only peaks that have an intensity which ## is larger than one third of the maximal peak intensity in that spectrum. keep_peaks <- function(x, prop = 3) {     x > max(x, na.rm = TRUE) / prop } res2 <- filterIntensity(data, intensity = keep_peaks) intensity(res2)[[1L]] #> [1] 200 400 intensity(data)[[1L]] #> [1] 200.0 400.0  34.2  17.0  ## We can also change the proportion by simply passing the `prop` parameter ## to the function. To keep only peaks that have an intensity which is ## larger than half of the maximum intensity: res2 <- filterIntensity(data, intensity = keep_peaks, prop = 2) intensity(res2)[[1L]] #> intensity  #>       400  intensity(data)[[1L]] #> [1] 200.0 400.0  34.2  17.0  ## Since data manipulation operations are by default not directly applied to ## the data but only added to the internal lazy evaluation queue, it is also ## possible to remove these data manipulations with the `reset` function: res_rest <- reset(res) res_rest #> MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 17 more variables/columns. #> Processing: #>  Signal <= 40 in MS level(s) 1, 2 set to 0 [Fri Apr  1 12:46:32 2022] #>  Remove peaks with intensities outside [40, Inf] in spectra of MS level(s) 1, 2. [Fri Apr  1 12:46:32 2022] #>  Reset object. [Fri Apr  1 12:46:32 2022]  lengths(mz(res_rest)) #> [1] 4 3 lengths(mz(res)) #> [1] 2 0 lengths(mz(data)) #> [1] 4 3  ## `reset` after a `applyProcessing` can not restore the data, because the ## data in the backend was changed. Similarly, `reset` after any filter ## operations can not restore data for a `Spectra` with a ## `MsBackendDataFrame`. res_2 <- applyProcessing(res) res_rest <- reset(res_2) lengths(mz(res)) #> [1] 2 0 lengths(mz(res_rest)) #> [1] 2 0   ## Compare spectra: comparing spectra 2 and 3 against spectra 10:20 using ## the normalized dotproduct method. res <- compareSpectra(sciex_im[2:3], sciex_im[10:20]) ## first row contains comparisons of spectrum 2 with spectra 10 to 20 and ## the second row comparisons of spectrum 3 with spectra 10 to 20 res #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7] #> [1,] 0.8583577 0.8603472 0.8588292 0.8434391 0.8581683 0.8515891 0.8568266 #> [2,] 0.8620081 0.8609868 0.8604669 0.8481934 0.8637094 0.8586378 0.8618227 #>           [,8]      [,9]     [,10]     [,11] #> [1,] 0.8563933 0.8559511 0.8546560 0.8538058 #> [2,] 0.8559523 0.8652169 0.8585325 0.8639445  ## To use a simple Pearson correlation instead we can define a function ## that takes the two peak matrices and calculates the correlation for ## their second columns (containing the intensity values). correlateSpectra <- function(x, y, use = \"pairwise.complete.obs\", ...) {     cor(x[, 2], y[, 2], use = use) } res <- compareSpectra(sciex_im[2:3], sciex_im[10:20],     FUN = correlateSpectra) res #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7] #> [1,] 0.9974395 0.9989580 0.9973735 0.9974334 0.9987225 0.9992307 0.9978621 #> [2,] 0.9986971 0.9976861 0.9964951 0.9965942 0.9982105 0.9984607 0.9982808 #>           [,8]      [,9]     [,10]     [,11] #> [1,] 0.9950464 0.9987036 0.9988265 0.9970657 #> [2,] 0.9921029 0.9990331 0.9975400 0.9955439  ## Use compareSpectra to determine the number of common (matching) peaks ## with a ppm of 10: ## type = \"inner\" uses a *inner join* to match peaks, i.e. keeps only ## peaks that can be mapped betwen both spectra. The provided FUN returns ## simply the number of matching peaks. compareSpectra(sciex_im[2:3], sciex_im[10:20], ppm = 10, type = \"inner\",     FUN = function(x, y, ...) nrow(x)) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [1,]  530  501  484  576  592  515  549  578  539   542   550 #> [2,]  526  548  524  592  639  502  589  571  575   564   613  ## Apply an arbitrary function to each spectrum in a Spectra. ## In the example below we calculate the mean intensity for each spectrum ## in a subset of the sciex_im data. Note that we can access all variables ## of each individual spectrum either with the `$` operator or the ## corresponding method. res <- spectrapply(sciex_im[1:20], FUN = function(x) mean(x$intensity[[1]])) head(res) #> $`1` #> [1] 1553.953 #>  #> $`2` #> [1] 678.2289 #>  #> $`3` #> [1] 684.3569 #>  #> $`4` #> [1] 682.1004 #>  #> $`5` #> [1] 780.6867 #>  #> $`6` #> [1] 737.5087 #>   ## It is however important to note that dedicated methods to access the ## data (such as `intensity`) are much more efficient than using `lapply`: res <- lapply(intensity(sciex_im[1:20]), mean) head(res) #> [[1]] #> [1] 1553.953 #>  #> [[2]] #> [1] 678.2289 #>  #> [[3]] #> [1] 684.3569 #>  #> [[4]] #> [1] 682.1004 #>  #> [[5]] #> [1] 780.6867 #>  #> [[6]] #> [1] 737.5087 #>   ## Calculating the precursor intensity for MS2 spectra: ## ## Some MS instrument manufacturer don't report the precursor intensities ## for MS2 spectra. The `estimatePrecursorIntensity` function can be used ## in these cases to calculate the precursor intensity on MS1 data. Below ## we load an mzML file from a vendor providing precursor intensities and ## compare the estimated and reported precursor intensities. tmt <- Spectra(msdata::proteomics(full.names = TRUE)[5],     backend = MsBackendMzR()) pmi <- estimatePrecursorIntensity(tmt) plot(pmi, precursorIntensity(tmt))   ## We can also replace the original precursor intensity values with the ## newly calculated ones tmt$precursorIntensity <- pmi  ## ---- DATA EXPORT ----  ## Some `MsBackend` classes provide an `export` method to export the data to ## the file format supported by the backend. The `MsBackendMzR` for example ## allows to export MS data to mzML or mzXML file(s), the `MsBackendMgf` ## (defined in the MsBackendMgf R package) would allow to export the data ## in mgf file format. Below we export the MS data in `data`. We ## call the `export` method on this object, specify the backend that should ## be used to export the data (and which also defines the output format) and ## provide a file name. fl <- tempfile() export(data, MsBackendMzR(), file = fl) #> Writing file file117f1fb03753... #> OK  ## This exported our data in mzML format. Below we read the first 6 lines ## from that file. readLines(fl, n = 6) #> [1] \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"                                                                                                                                                                                             #> [2] \"<indexedmzML xmlns=\\\"http://psi.hupo.org/ms/mzml\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.2_idx.xsd\\\">\"                  #> [3] \"  <mzML xmlns=\\\"http://psi.hupo.org/ms/mzml\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.0.xsd\\\" id=\\\"\\\" version=\\\"1.1.0\\\">\" #> [4] \"    <cvList count=\\\"2\\\">\"                                                                                                                                                                                                               #> [5] \"      <cv id=\\\"MS\\\" fullName=\\\"Proteomics Standards Initiative Mass Spectrometry Ontology\\\" version=\\\"4.1.51\\\" URI=\\\"https://raw.githubusercontent.com/HUPO-PSI/psi-ms-CV/master/psi-ms.obo\\\"/>\"                                        #> [6] \"      <cv id=\\\"UO\\\" fullName=\\\"Unit Ontology\\\" version=\\\"09:04:2014\\\" URI=\\\"https://raw.githubusercontent.com/bio-ontology-research-group/unit-ontology/master/unit.obo\\\"/>\"                                                             ## If only a single file name is provided, all spectra are exported to that ## file. To export data with the `MsBackendMzR` backend to different files, a ## file name for each individual spectrum has to be provided. ## Below we export each spectrum to its own file. fls <- c(tempfile(), tempfile()) export(data, MsBackendMzR(), file = fls) #> Writing file file117f160f5c08... #> OK #> Writing file file117f1dd65dad... #> OK  ## Reading the data from the first file res <- Spectra(backendInitialize(MsBackendMzR(), fls[1]))  mz(res) #> NumericList of length 1 #> [[1]] 100 103.2 104.3 106.5 mz(data) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 45.6 120.4 190.2"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine peaks with similar m/z across spectra — combinePeaks","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"combinePeaks aggregates provided peak matrices single peak matrix. Peaks grouped m/z values group() function MsCoreUtils package. brief, peaks provided spectra first ordered m/z consecutively grouped one group (pairwise) difference smaller specified parameter tolerance ppm (see group() grouping details examples). m/z intensity values resulting peak matrix calculated using mzFun intensityFun grouped m/z intensity values. Note grouped m/z intensity values used aggregation functions (mzFun intensityFun) number spectra. function supports also different strategies peak combinations can specified peaks parameter: peaks = \"union\" (default): report peaks input spectra. peaks = \"intersect\": keep peaks resulting peak matrix present >= minProp proportion input spectra. generate consensus representative spectra set e.g. fragment spectra measured precursor ion. special case possible report peaks resulting matrix peak groups contain peak one input spectra, can specified parameter main. Thus, e.g. main = 2 specified, (grouped) peaks peak second input matrix returned. Setting timeDomain TRUE causes grouping performed square root m/z values (assuming TOF instrument used create data).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"","code":"combinePeaks(   x,   intensityFun = base::mean,   mzFun = base::mean,   weighted = FALSE,   tolerance = 0,   ppm = 0,   timeDomain = FALSE,   peaks = c(\"union\", \"intersect\"),   main = integer(),   minProp = 0.5,   ... )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"x list peak matrices. intensityFun function used combine intensity values matching peaks. default mean intensity value returned. mzFun function used combine m/z values matching peaks. default mean m/z value returned. weighted logical(1) defining whether m/z values matching peaks calculated intensity-weighted average individuak m/z values. overrides parameter mzFun. tolerance numeric(1) defining (absolute) maximal accepted difference mass peaks group final peak. ppm numeric(1) defining m/z-relative maximal accepted difference mass peaks (expressed parts-per-million) group final peak. timeDomain logical(1) whether grouping mass peaks performed m/z values (timeDomain = FALSE) sqrt(mz) (timeDomain = TRUE). peaks character(1) specifying peaks combined. Can either \"peaks = \"union\" (default) peaks = \"intersect\". See function description details. main optional integer(1) force resulting peak list contain peaks present specified input spectrum. See description details. minProp numeric(1) `peaks = \"intersect\": minimal required proportion input spectra (peak matrices) mass peak present included consensus peak matrix. ... additional parameters mzFun intensityFun functions.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"Peaks matrix m/z intensity values representing aggregated values across provided peak matrices.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"general merging spectra, tolerance /ppm manually specified based precision MS instrument. Peaks spectra difference m/z smaller tolerance smaller ppm m/z grouped final peak. details combination consecutive spectra LC-MS run: m/z values ion consecutive scans (spectra) LC-MS run identical. Assuming random variation much smaller resolution MS instrument (.e. difference m/z values within single spectrum), m/z value groups defined across spectra containing m/z values main spectrum retained. Intensities m/z values falling within m/z groups aggregated using intensityFun mzFun, respectively. highly likely QTOF profile data collected timing circuit collects data points regular intervals time later converted m/z values based relationship t = k * sqrt(m/z). m/z scale thus non-linear m/z scattering (fact caused small variations time circuit) thus different lower upper m/z scale. m/z-intensity pairs consecutive scans combined therefore defined default square root m/z values. timeDomain = FALSE, actual m/z values used.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine peaks with similar m/z across spectra — combinePeaks","text":"","code":"set.seed(123) mzs <- seq(1, 20, 0.1) ints1 <- abs(rnorm(length(mzs), 10)) ints1[11:20] <- c(15, 30, 90, 200, 500, 300, 100, 70, 40, 20) # add peak ints2 <- abs(rnorm(length(mzs), 10)) ints2[11:20] <- c(15, 30, 60, 120, 300, 200, 90, 60, 30, 23) ints3 <- abs(rnorm(length(mzs), 10)) ints3[11:20] <- c(13, 20, 50, 100, 200, 100, 80, 40, 30, 20)  ## Create the peaks matrices p1 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),     intensity = ints1) p2 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),     intensity = ints2) p3 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.009),     intensity = ints3)  ## Combine the spectra. With `tolerance = 0` and `ppm = 0` only peaks with ## **identical** m/z are combined. The result will be a single spectrum ## containing the *union* of mass peaks from the individual input spectra. p <- combinePeaks(list(p1, p2, p3))  ## Plot the spectra before and after combining par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1)) plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = \"h\", col = \"red\") points(p2[, 1], p2[, 2], type = \"h\", col = \"green\") points(p3[, 1], p3[, 2], type = \"h\", col = \"blue\")  plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = \"h\",     col = \"black\")  ## The peaks were not merged, because their m/z differs too much.  ## Combine spectra with `tolerance = 0.05`. This will merge all triplets. p <- combinePeaks(list(p1, p2, p3), tolerance = 0.05)  ## Plot the spectra before and after combining par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1)) plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = \"h\", col = \"red\") points(p2[, 1], p2[, 2], type = \"h\", col = \"green\") points(p3[, 1], p3[, 2], type = \"h\", col = \"blue\")  plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = \"h\",     col = \"black\")   ## With `intensityFun = max` the maximal intensity per peak is reported. p <- combinePeaks(list(p1, p2, p3), tolerance = 0.05,     intensityFun = max)  ## Create *consensus*/representative spectrum from a set of spectra  p1 <- cbind(mz = c(12, 45, 64, 70), intensity = c(10, 20, 30, 40)) p2 <- cbind(mz = c(17, 45.1, 63.9, 70.2), intensity = c(11, 21, 31, 41)) p3 <- cbind(mz = c(12.1, 44.9, 63), intensity = c(12, 22, 32))  ## No mass peaks identical thus consensus peaks are empty combinePeaks(list(p1, p2, p3), peaks = \"intersect\") #>      mz intensity  ## Reducing the minProp to 0.2. The consensus spectrum will contain all ## peaks combinePeaks(list(p1, p2, p3), peaks = \"intersect\", minProp = 0.2) #>         mz intensity #>  [1,] 12.0        10 #>  [2,] 12.1        12 #>  [3,] 17.0        11 #>  [4,] 44.9        22 #>  [5,] 45.0        20 #>  [6,] 45.1        21 #>  [7,] 63.0        32 #>  [8,] 63.9        31 #>  [9,] 64.0        30 #> [10,] 70.0        40 #> [11,] 70.2        41  ## With a tolerance of 0.1 mass peaks can be matched across spectra combinePeaks(list(p1, p2, p3), peaks = \"intersect\", tolerance = 0.1) #>         mz intensity #> [1,] 12.05      11.0 #> [2,] 45.00      21.0 #> [3,] 63.95      30.5  ## Report the minimal m/z and intensity combinePeaks(list(p1, p2, p3), peaks = \"intersect\", tolerance = 0.1,     intensityFun = min, mzFun = min) #>        mz intensity #> [1,] 12.0        10 #> [2,] 44.9        20 #> [3,] 63.9        30"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of identifications per scan — countIdentifications","title":"Count the number of identifications per scan — countIdentifications","text":"function takes Spectra object containing identification results input. counts number identifications scan (descendants) lead - either 0 1 MS2 scans, , MS1 scans, number MS2 scans originating MS1 peak lead identification. function can used generate id-annotated total ion chromatograms, can illustrated .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of identifications per scan — countIdentifications","text":"","code":"countIdentifications(   object,   identification = \"sequence\",   f = dataStorage(object),   BPPARAM = bpparam() )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of identifications per scan — countIdentifications","text":"object instance class Spectra() contains identification data, defined sequence argument. identification character(1) name spectra variable defines whether scan lead identification (typically containing idenfified peptides sequence proteomics). absence identification encode NA. Default \"sequence\". f factor defining split object parallelized processing. Default dataOrigin(x), .e. raw data files processed parallel. BPPARAM Parallel setup configuration. See BiocParallel::bpparam() details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of identifications per scan — countIdentifications","text":"updated Spectra() object now contains integer spectra variable countIdentifications number identification scan.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count the number of identifications per scan — countIdentifications","text":"computed number identifications stored new spectra variables named \"countIdentifications\". already exists, function throws message returns object unchanged. force recomputation \"countIdentifications\" variable, users either delete rename .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count the number of identifications per scan — countIdentifications","text":"Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of identifications per scan — countIdentifications","text":"","code":"spdf <- new(\"DFrame\", rownames = NULL, nrows = 86L,    listData = list(        msLevel = c(1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L),        acquisitionNum = 8975:9060,        precScanNum = c(NA, 8956L, 8956L, 8956L, 8956L, 8956L, 8956L,                        8956L, 8956L, 8956L, 8956L, 8956L, 8956L,                        8956L, 8956L, 8956L, 8956L, 8956L, 8956L, NA,                        8975L, 8975L, 8975L, 8975L, 8975L, 8975L,                        8975L, 8975L, 8975L, 8975L, 8975L, 8975L,                        8975L, 8975L, 8975L, 8975L, 8975L, NA, 8994L,                        8994L, 8994L, 8994L, 8994L, 8994L, 8994L,                        8994L, 8994L, 8994L, 8994L, 8994L, 8994L, NA,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L, NA,                        9026L, 9026L, 9026L, 9026L, 9026L, 9026L,                        9026L, 9026L, 9026L, 9026L, 9026L, 9026L,                        9026L, 9026L, 9026L),        sequence = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     \"LSEHATAPTR\", NA, NA, NA, NA, NA, NA, NA,                     \"EGSDATGDGTK\", NA, NA, \"NEDEDSPNK\", NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, \"GLTLAQGGVK\",                     NA, NA, NA, NA, \"STLPDADRER\", NA, NA, NA, NA, NA,                     NA, NA, NA)),    elementType = \"ANY\", elementMetadata = NULL, metadata = list())  sp <- Spectra(spdf)  ## We have in this data 5 MS1 and 81 MS2 scans table(msLevel(sp)) #>  #>  1  2  #>  5 81   ## The acquisition number of the MS1 scans acquisitionNum(filterMsLevel(sp, 1)) #> [1] 8975 8994 9012 9026 9045  ## And the number of MS2 scans with precursor ions selected ## from MS1 scans (those in the data and others) table(precScanNum(sp)) #>  #> 8956 8975 8994 9012 9026  #>   18   17   13   18   15   ## Count number of sequences/identifications per scan sp <- countIdentifications(sp)  ## MS2 scans either lead to an identification (5 instances) or none ## (76). Among the five MS1 scans in the experiment, 3 lead to MS2 ## scans being matched to no peptides and two MS1 scans produced two ## and three PSMs respectively. table(sp$countIdentifications, sp$msLevel) #>     #>      1  2 #>   0  3 76 #>   1  0  5 #>   2  1  0 #>   3  1  0"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"filterFourierTransformArtefacts function removes (Orbitrap) fast fourier artefact peaks spectra. artefacts (also referred rippples) seem related ringing phenomenon frequently seen Orbitrap data small random mass peaks ~ 0.01 Da main peak large intensity. See also details information. data set fft_spectrum represents Spectra() object single Orbitrap spectrum artefacts (see examples ). See also Spectra() (section *Data subsetting, filtering merging) definition function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"current implementation iterates intensity ordered peaks spectrum removes peaks m/z within +/- halfWindowSize current peak intensity lower threshold times current peak's intensity. Additional parameters keepIsotopes, maxCharge isotopeTolerance allow avoid removing potential [13]C isotope peaks (maxCharge maximum charge considered isotopeTolerance absolute acceptable tolerance matching m/z).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"Jan Stanstrup, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"","code":"library(Spectra) data(fft_spectrum)  plotSpectra(fft_spectrum)   ## Focus on an artefact plotSpectra(fft_spectrum, xlim = c(264.5, 265.5))  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   fft_spectrum <- filterFourierTransformArtefacts(fft_spectrum) fft_spectrum #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Fri Apr  1 12:46:40 2022]  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## R code to download/extract the data.  if (FALSE) { library(Spectra) # get orbitrap data download.file(\"https://www.ebi.ac.uk/metabolights/ws/studies/MTBLS469/download/4cc5d820-dc5d-4766-8112-7a05f74acef4?file=AV_01_v2_male_arm1_juice.mzXML\", \"AV_01_v2_male_arm1_juice.mzXML\") data <- Spectra(\"AV_01_v2_male_arm1_juice.mzXML\") extracted_spectrum <- data[195] }"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal page for hidden aliases — hidden_aliases","title":"Internal page for hidden aliases — hidden_aliases","text":"S4 methods require documentation entry clutter index.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal page for hidden aliases — hidden_aliases","text":"","code":"addProcessing(object, ...)  backendInitialize(object, ...)  backendMerge(object, ...)  # S4 method for numeric bin(   x,   y,   size = 1,   breaks = seq(floor(min(y)), ceiling(max(y)), by = size),   FUN = max )  containsMz(object, ...)  containsNeutralLoss(object, ...)  dropNaSpectraVariables(object, ...)  export(object, ...)  filterMzRange(object, ...)  filterMzValues(object, ...)  filterPrecursorMzValues(object, ...)  filterPrecursorMzRange(object, ...)  isReadOnly(object, ...)  peaksData(object, ...)  peaksData(object) <- value  pickPeaks(object, ...)  replaceIntensitiesBelow(object, threshold = min, ...)  reset(object, ...)  selectSpectraVariables(object, ...)  setBackend(object, backend, ...)  spectrapply(object, ...)  # S4 method for MsBackendDataFrame show(object)  # S4 method for MsBackendDataFrame backendMerge(object, ...)  # S4 method for MsBackendDataFrame acquisitionNum(object)  # S4 method for MsBackendDataFrame peaksData(object)  # S4 method for MsBackendDataFrame centroided(object)  # S4 method for MsBackendDataFrame centroided(object) <- value  # S4 method for MsBackendDataFrame collisionEnergy(object)  # S4 method for MsBackendDataFrame collisionEnergy(object) <- value  # S4 method for MsBackendDataFrame dataOrigin(object)  # S4 method for MsBackendDataFrame dataOrigin(object) <- value  # S4 method for MsBackendDataFrame dataStorage(object)  # S4 method for MsBackendDataFrame dataStorage(object) <- value  # S4 method for MsBackendDataFrame intensity(object)  # S4 method for MsBackendDataFrame intensity(object) <- value  # S4 method for MsBackendDataFrame ionCount(object)  # S4 method for MsBackendDataFrame isEmpty(x)  # S4 method for MsBackendDataFrame isolationWindowLowerMz(object)  # S4 method for MsBackendDataFrame isolationWindowLowerMz(object) <- value  # S4 method for MsBackendDataFrame isolationWindowTargetMz(object)  # S4 method for MsBackendDataFrame isolationWindowTargetMz(object) <- value  # S4 method for MsBackendDataFrame isolationWindowUpperMz(object)  # S4 method for MsBackendDataFrame isolationWindowUpperMz(object) <- value  # S4 method for MsBackendDataFrame length(x)  # S4 method for MsBackendDataFrame lengths(x, use.names = FALSE)  # S4 method for MsBackendDataFrame msLevel(object, ...)  # S4 method for MsBackendDataFrame msLevel(object) <- value  # S4 method for MsBackendDataFrame mz(object)  # S4 method for MsBackendDataFrame mz(object) <- value  # S4 method for MsBackendDataFrame polarity(object)  # S4 method for MsBackendDataFrame polarity(object) <- value  # S4 method for MsBackendDataFrame precScanNum(object)  # S4 method for MsBackendDataFrame precursorCharge(object)  # S4 method for MsBackendDataFrame precursorIntensity(object)  # S4 method for MsBackendDataFrame precursorMz(object)  # S4 method for MsBackendDataFrame peaksData(object) <- value  # S4 method for MsBackendDataFrame rtime(object)  # S4 method for MsBackendDataFrame rtime(object) <- value  # S4 method for MsBackendDataFrame scanIndex(object)  # S4 method for MsBackendDataFrame selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for MsBackendDataFrame smoothed(object)  # S4 method for MsBackendDataFrame smoothed(object) <- value  # S4 method for MsBackendDataFrame spectraData(object, columns = spectraVariables(object))  # S4 method for MsBackendDataFrame spectraData(object) <- value  # S4 method for MsBackendDataFrame spectraNames(object)  # S4 method for MsBackendDataFrame spectraNames(object) <- value  # S4 method for MsBackendDataFrame spectraVariables(object)  # S4 method for MsBackendDataFrame tic(object, initial = TRUE)  # S4 method for MsBackendDataFrame $(x, name)  # S4 method for MsBackendDataFrame $(x, name) <- value  # S4 method for MsBackendDataFrame [(x, i, j, ..., drop = FALSE)  # S4 method for MsBackendDataFrame,ANY split(x, f, drop = FALSE, ...)  # S4 method for MsBackendDataFrame filterAcquisitionNum(   object,   n = integer(),   dataStorage = character(),   dataOrigin = character() )  # S4 method for MsBackendHdf5Peaks backendInitialize(   object,   files = character(),   data = DataFrame(),   hdf5path = character(),   ...,   BPPARAM = bpparam() )  # S4 method for MsBackendHdf5Peaks show(object)  # S4 method for MsBackendHdf5Peaks peaksData(object)  # S4 method for MsBackendHdf5Peaks intensity(object)  # S4 method for MsBackendHdf5Peaks intensity(object) <- value  # S4 method for MsBackendHdf5Peaks ionCount(object)  # S4 method for MsBackendHdf5Peaks isCentroided(object, ...)  # S4 method for MsBackendHdf5Peaks isEmpty(x)  # S4 method for MsBackendHdf5Peaks lengths(x, use.names = FALSE)  # S4 method for MsBackendHdf5Peaks mz(object)  # S4 method for MsBackendHdf5Peaks mz(object) <- value  # S4 method for MsBackendHdf5Peaks peaksData(object) <- value  # S4 method for MsBackendHdf5Peaks spectraData(object, columns = spectraVariables(object))  # S4 method for MsBackendHdf5Peaks spectraData(object) <- value  # S4 method for MsBackendHdf5Peaks $(x, name) <- value  # S4 method for MsBackendHdf5Peaks [(x, i, j, ..., drop = FALSE)  # S4 method for MsBackendHdf5Peaks backendMerge(object, ...)  # S4 method for MsBackendMzR backendInitialize(object, files, ..., BPPARAM = bpparam())  # S4 method for MsBackendMzR show(object)  # S4 method for MsBackendMzR peaksData(object)  # S4 method for MsBackendMzR intensity(object)  # S4 method for MsBackendMzR intensity(object) <- value  # S4 method for MsBackendMzR ionCount(object)  # S4 method for MsBackendMzR isCentroided(object, ...)  # S4 method for MsBackendMzR isEmpty(x)  # S4 method for MsBackendMzR lengths(x, use.names = FALSE)  # S4 method for MsBackendMzR mz(object)  # S4 method for MsBackendMzR mz(object) <- value  # S4 method for MsBackendMzR spectraData(object, columns = spectraVariables(object))  # S4 method for MsBackendMzR spectraData(object) <- value  # S4 method for MsBackendMzR spectraNames(object)  # S4 method for MsBackendMzR spectraNames(object) <- value  # S4 method for MsBackendMzR spectraVariables(object)  # S4 method for MsBackendMzR $(x, name) <- value  # S4 method for MsBackendMzR export(   object,   x,   file = tempfile(),   format = c(\"mzML\", \"mzXML\"),   copy = FALSE,   BPPARAM = bpparam() )  # S4 method for Spectra show(object)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal page for hidden aliases — hidden_aliases","text":"applicable","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Join (map) peaks of two spectra — joinPeaks","title":"Join (map) peaks of two spectra — joinPeaks","text":"functions map peaks two spectra difference m/z values smaller defined parameters tolerance ppm. functions take two matrices joinPeaks: maps peaks two spectra allowing specify type join performed: type = \"outer\" peak x matched peak y, peaks match peak spectra NA intensity returned. type = \"left\" peaks left spectrum (x) matched peaks y. Peaks y match peak x omitted. type = \"right\" type = \"left\" y. peaks can matched x y returned type = \"inner\", .e. peaks present spectra reported. joinPeaksGnps matches/maps peaks spectra approach used GNPS: peaks considered matching ) difference m/z values smaller defined tolerance ppm (joinPeaks) b) difference m/z adjusted difference spectras' precursor smaller defined tolerance ppm. Based definition, peaks x can match two peaks y hence peaks returned matrices might reported multiple times. Note one xPrecursorMz yPrecursorMz NA , results joinPeaks(). calculate GNPS similarity scores, gnps() called aligned peak matrices (.e. compareSpectra called MAPFUN = joinPeaksGnps FUN = MsCoreUtils::gnps).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join (map) peaks of two spectra — joinPeaks","text":"","code":"joinPeaks(x, y, type = \"outer\", tolerance = 0, ppm = 10, ...)  joinPeaksGnps(   x,   y,   xPrecursorMz = NA_real_,   yPrecursorMz = NA_real_,   tolerance = 0,   ppm = 0,   type = \"outer\",   ... )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join (map) peaks of two spectra — joinPeaks","text":"x matrix two columns \"mz\" \"intensity\" containing m/z intensity values mass peaks spectrum. y matrix two columns \"mz\" \"intensity\" containing m/z intensity values mass peaks spectrum. type joinPeaks joinPeaksGnps: character(1) specifying type join performed. See function description details. tolerance numeric(1) defining constant maximal accepted difference m/z values peaks two spectra matched/mapped. ppm numeric(1) defining relative, m/z-dependent, maximal accepted difference m/z values peaks two spectra matched/mapped. ... optional parameters passed MsCoreUtils::join() function. xPrecursorMz joinPeaksGnps: numeric(1) precursor m/z spectrum x. yPrecursorMz joinPeaksGnps: numeric(1) precursor m/z spectrum y.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join (map) peaks of two spectra — joinPeaks","text":"functions return list elements \"x\" \"y\" two column matrix m/z (first column) intensity values (second column). two matrices contain matched peaks input matrices x yand hence number rows. Peaks present x y input matrix m/z intensity values NA result matrix y (vice versa).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Join (map) peaks of two spectra — joinPeaks","text":"mapping function must take two numeric matrices x y input must return list two elements named \"x\" \"y\" represent aligned input matrices. function also ... definition. Parameters ppm tolerance suggested required.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Join (map) peaks of two spectra — joinPeaks","text":"Johannes Rainer, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join (map) peaks of two spectra — joinPeaks","text":"","code":"x <- cbind(c(31.34, 50.14, 60.3, 120.9, 230, 514.13, 874.1),     1:7) y <- cbind(c(12, 31.35, 70.3, 120.9 + ppm(120.9, 5),     230 + ppm(230, 10), 315, 514.14, 901, 1202),     1:9)  ## No peaks with identical m/z joinPeaks(x, y, ppm = 0, type = \"inner\") #> $x #>      [,1] [,2] #>  #> $y #>      [,1] [,2] #>   ## With ppm 10 two peaks are overlapping joinPeaks(x, y, ppm = 10, type = \"inner\") #> $x #>       [,1] [,2] #> [1,] 120.9    4 #> [2,] 230.0    5 #>  #> $y #>          [,1] [,2] #> [1,] 120.9006    4 #> [2,] 230.0023    5 #>   ## Outer join: contain all peaks from x and y joinPeaks(x, y, ppm = 10, type = \"outer\") #> $x #>         [,1] [,2] #>  [1,]     NA   NA #>  [2,]  31.34    1 #>  [3,]     NA   NA #>  [4,]  50.14    2 #>  [5,]  60.30    3 #>  [6,]     NA   NA #>  [7,] 120.90    4 #>  [8,] 230.00    5 #>  [9,]     NA   NA #> [10,] 514.13    6 #> [11,]     NA   NA #> [12,] 874.10    7 #> [13,]     NA   NA #> [14,]     NA   NA #>  #> $y #>            [,1] [,2] #>  [1,]   12.0000    1 #>  [2,]        NA   NA #>  [3,]   31.3500    2 #>  [4,]        NA   NA #>  [5,]        NA   NA #>  [6,]   70.3000    3 #>  [7,]  120.9006    4 #>  [8,]  230.0023    5 #>  [9,]  315.0000    6 #> [10,]        NA   NA #> [11,]  514.1400    7 #> [12,]        NA   NA #> [13,]  901.0000    8 #> [14,] 1202.0000    9 #>   ## Left join: keep all peaks from x and those from y that match joinPeaks(x, y, ppm = 10, type = \"left\") #> $x #>        [,1] [,2] #> [1,]  31.34    1 #> [2,]  50.14    2 #> [3,]  60.30    3 #> [4,] 120.90    4 #> [5,] 230.00    5 #> [6,] 514.13    6 #> [7,] 874.10    7 #>  #> $y #>          [,1] [,2] #> [1,]       NA   NA #> [2,]       NA   NA #> [3,]       NA   NA #> [4,] 120.9006    4 #> [5,] 230.0023    5 #> [6,]       NA   NA #> [7,]       NA   NA #>   ## Right join: keep all peaks from y and those from x that match. Using ## a constant tolerance of 0.01 joinPeaks(x, y, tolerance = 0.01, type = \"right\") #> $x #>         [,1] [,2] #>  [1,]     NA   NA #>  [2,]  31.34    1 #>  [3,]     NA   NA #>  [4,] 120.90    4 #>  [5,] 230.00    5 #>  [6,]     NA   NA #>  [7,] 514.13    6 #>  [8,]     NA   NA #>  [9,]     NA   NA #>  #> $y #>            [,1] [,2] #>  [1,]   12.0000    1 #>  [2,]   31.3500    2 #>  [3,]   70.3000    3 #>  [4,]  120.9006    4 #>  [5,]  230.0023    5 #>  [6,]  315.0000    6 #>  [7,]  514.1400    7 #>  [8,]  901.0000    8 #>  [9,] 1202.0000    9 #>   ## GNPS-like peak matching  ## Define spectra x <- cbind(mz = c(10, 36, 63, 91, 93), intensity = c(14, 15, 999, 650, 1)) y <- cbind(mz = c(10, 12, 50, 63, 105), intensity = c(35, 5, 16, 999, 450)) ## The precursor m/z pmz_x <- 91 pmz_y <- 105  ## Plain joinPeaks identifies only 2 matching peaks: 1 and 5 joinPeaks(x, y) #> $x #>      mz intensity #> [1,] 10        14 #> [2,] NA        NA #> [3,] 36        15 #> [4,] NA        NA #> [5,] 63       999 #> [6,] 91       650 #> [7,] 93         1 #> [8,] NA        NA #>  #> $y #>       mz intensity #> [1,]  10        35 #> [2,]  12         5 #> [3,]  NA        NA #> [4,]  50        16 #> [5,]  63       999 #> [6,]  NA        NA #> [7,]  NA        NA #> [8,] 105       450 #>   ## joinPeaksGnps finds 4 matches joinPeaksGnps(x, y, pmz_x, pmz_y) #> $x #>       mz intensity #>  [1,] 10        14 #>  [2,] 36        15 #>  [3,] 36        15 #>  [4,] 63       999 #>  [5,] 91       650 #>  [6,] 91       650 #>  [7,] 93         1 #>  [8,] NA        NA #>  [9,] NA        NA #> [10,] NA        NA #>  #> $y #>        mz intensity #>  [1,]  10        35 #>  [2,]  NA        NA #>  [3,]  50        16 #>  [4,]  63       999 #>  [5,]  NA        NA #>  [6,] 105       450 #>  [7,]  NA        NA #>  [8,]  12         5 #>  [9,]  50        16 #> [10,] 105       450 #>   ## with one of the two precursor m/z being NA, the result are the same as ## with joinPeaks (with type = \"left\"). joinPeaksGnps(x, y, pmz_x, yPrecursorMz = NA) #> $x #>      mz intensity #> [1,] 10        14 #> [2,] NA        NA #> [3,] 36        15 #> [4,] NA        NA #> [5,] 63       999 #> [6,] 91       650 #> [7,] 93         1 #> [8,] NA        NA #>  #> $y #>       mz intensity #> [1,]  10        35 #> [2,]  12         5 #> [3,]  NA        NA #> [4,]  50        16 #> [5,]  63       999 #> [6,]  NA        NA #> [7,]  NA        NA #> [8,] 105       450 #>"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Neutral Loss Spectra — neutralLoss","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"help page lists functions convert MS/MS spectra neutral loss spectra. main function neutralLoss specific algorithm used defined (configured) dedicated parameter objects (paramer param neutralLoss function). parameter objects different algorithms : PrecursorMzParam: calculates neutral loss spectra Aisporna et al. 2022 subtracting (fragment's) peak m/z value precursor m/z value spectrum (precursor m/z - fragment m/z). Parameter msLevel allows restrict calculation neutral loss spectra specified MS level(s). Spectra MS level(s) returned -. Parameter filterPeaks allows filter fragment peaks e.g. m/z value larger precursor's (filterPeaks = \"abovePrecursor\") (filterPeaks = \"belowPrecursor\"). default, peak filtering performed. See also parameter filterPeaks details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"","code":"neutralLoss(object, param, ...)  PrecursorMzParam(   filterPeaks = c(\"none\", \"abovePrecursor\", \"belowPrecursor\"),   msLevel = c(2L, NA_integer_) )  # S4 method for Spectra,PrecursorMzParam neutralLoss(object, param, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"object Spectra() object fragment spectra neutral loss spectra calculated. param One parameter objects discussed . ... Currently ignored. filterPeaks PrecursorMzParam: character(1) function defining fragment peaks filtered calculation. Pre-defined options : \"none\" (keep peaks), \"abovePrecursor\" (removes fragment peaks m/z >= precursor m/z), \"belowPrecursor\" (removes fragment peaks m/z <= precursor m/z). addition, possible pass custom function parameter arguments x (two column peak matrix) precursorMz (precursor m/z) returns sub-setted two column peak matrix. msLevel integer defining MS level(s) neutral loss spectra calculated. Defaults msLevel = c(2L, NA) thus, neutral loss spectra calculated spectra MS level equal 2 missing/undefined MS level. spectra MS level different msLevel returned unchanged.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Spectra() object calculated neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"definition, mass peaks Spectra object need ordered m/z value (increasing order). Thus, order peaks calculated neutral loss spectra might original Spectra object. Note also spectra missing precursor m/z empty spectra returned (.e. spectra without peaks) since possible calcualte neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Aisporna , Benton PH, Chen , Derks RJE, Galano JM, Giera M Siuzdak G (2022). Neutral Loss Mass Spectral Data Enhances Molecular Similarity Analysis METLIN. Journal American Society Mass Spectrometry. doi: 10.1021/jasms.1c00343","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"","code":"## Create a simple example Spectra object with some MS1, MS2 and MS3 spectra. DF <- DataFrame(msLevel = c(1L, 2L, 3L, 1L, 2L, 3L),                 precursorMz = c(NA, 40, 20, NA, 300, 200)) DF$mz <- IRanges::NumericList(                       c(3, 12, 14, 15, 16, 200),                       c(13, 23, 39, 86),                       c(5, 7, 20, 34, 50),                       c(5, 7, 9, 20, 100),                       c(15, 53, 299, 300),                       c(34, 56, 100, 200, 204, 309)                   , compress = FALSE) DF$intensity <- IRanges::NumericList(1:6, 1:4, 1:5, 1:5, 1:4, 1:6,                                      compress = FALSE) sps <- Spectra(DF, backend = MsBackendDataFrame())  ## Calculate neutral loss spectra for all MS2 spectra, keeping MS1 and MS3 ## spectra unchanged. sps_nl <- neutralLoss(sps, PrecursorMzParam(msLevel = 2L)) mz(sps) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] 13 23 39 86 #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] 15 53 299 300 #> [[6]] 34 56 100 200 204 309 mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] -46 1 17 27 #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] 0 1 247 285 #> [[6]] 34 56 100 200 204 309  ## Calculate neutral loss spectra for MS2 and MS3 spectra, removing peaks ## with an m/z >= precursorMz sps_nl <- neutralLoss(sps, PrecursorMzParam(     filterPeaks = \"abovePrecursor\", msLevel = 2:3)) mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] 1 17 27 #> [[3]] 13 15 #> [[4]] 5 7 9 20 100 #> [[5]] 1 247 285 #> [[6]] 100 144 166  ## Empty spectra are returned for MS 2 spectra with undefined precursor m/z. sps$precursorMz <- NA_real_ sps_nl <- neutralLoss(sps, PrecursorMzParam()) mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] numeric(0) #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] numeric(0) #> [[6]] 34 56 100 200 204 309"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":null,"dir":"Reference","previous_headings":"","what":"MZ delta Quality Control — plotMzDelta","title":"MZ delta Quality Control — plotMzDelta","text":"M/Z delta plot illustrates suitability MS2 spectra identification plotting M/Z differences intense peaks. resulting histogram optimally show modes amino acid residu masses. plots described Foster et al. 2011. certain percentage intense MS2 peaks taken account use significant signal. Default value 20% (see percentage argument). difference peaks computed individual spectra distribution plotted histogram. Delta M/Z 40 200 plotted default, encompass residue masses amino acids several common contaminants, although can changes mzRange argument. addition processing described , isobaric reporter tag peaks precursor peak can also removed MS2 spectrum, avoid interence fragment peaks. Note figures Foster et al. 2011 produced optimised centroided data. running function profile mode likely fine, recommended use centroided data. ggplot2 based function called ggMzDeltaPlot() visualise M/Z delta distributions available https://gist.github.com/lgatto/c72b1ff5a4116118dbb34d9d2bc3470a.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MZ delta Quality Control — plotMzDelta","text":"","code":"computeMzDeltas(   object,   percentage = 0.2,   mzRange = c(40, 200),   BPPARAM = BiocParallel::bpparam() )  plotMzDelta(x, aaLabels = TRUE)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MZ delta Quality Control — plotMzDelta","text":"object instance class Spectra(). percentage numeric(1) 0 1 indicating percentage intense peaks MS2 spectrum include calculation. Default 0.2. mzRange numeric(2) upper lower M/Z used MZ deltas. Default c(40, 200). BPPARAM optional BiocParallelParam instance determining parallel back-end used evaluation. Default use BiocParallel::bpparam(). See ?BiocParallel::bpparam details. x list M/Z delta values, returned computeMzDeltas(). aaLabels logical(1) defining whether amino acids labelled histogram. Default TRUE.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MZ delta Quality Control — plotMzDelta","text":"computeMzDeltas() returns list numeric vectors. plotMzDelta() used visualise M/Z delta distributions.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"MZ delta Quality Control — plotMzDelta","text":"Foster JM, Degroeve S, Gatto L, Visser M, Wang R, Griss J, et al. posteriori quality control curation reuse public proteomics data. Proteomics. 2011;11: 2182-2194. http://dx.doi.org/10.1002/pmic.201000602","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MZ delta Quality Control — plotMzDelta","text":"Laurent Gatto contributions (MSnbase) Guangchuang Yu.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MZ delta Quality Control — plotMzDelta","text":"","code":"library(msdata) f <- proteomics(pattern = \"TMT.+20141210.mzML.gz\", full.names = TRUE) sp <- Spectra(f)  d <- computeMzDeltas(sp[1:1000]) plotMzDelta(d)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting Spectra — spectra-plotting","title":"Plotting Spectra — spectra-plotting","text":"Spectra() can plotted one following functions plotSpectra: plots spectrum separate plot splitting plot area many panels spectra. plotSpectraOverlay: plots spectra x plot (overlay). plotSpectraMirror: plots pair spectra mirror plot. Parameters x y Spectra length 1. Matching peaks (considering ppm tolerance) highlighted. See common() details peak matching. Parameters matchCol, matchLty, matchLwd matchPch allow customize matching peaks indicated.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting Spectra — spectra-plotting","text":"","code":"plotSpectra(   x,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = character(),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   asp = 1,   ... )  plotSpectraOverlay(   x,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = paste(length(x), \"spectra\"),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   axes = TRUE,   frame.plot = axes,   ... )  # S4 method for Spectra plotSpectraMirror(   x,   y,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = character(),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   axes = TRUE,   frame.plot = axes,   ppm = 20,   tolerance = 0,   matchCol = \"#80B1D3\",   matchLwd = 1,   matchLty = 1,   matchPch = 16,   ... )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting Spectra — spectra-plotting","text":"x Spectra() object. plotSpectraMirror object length 2. xlab character(1) label x-axis (default xlab = \"m/z\"). ylab character(1) label y-axis (default ylab = \"intensity\"). type character(1) specifying type plot. See plot.default() details. Defaults type = \"h\" draws peak line. xlim numeric(2) defining x-axis limits. range m/z values used default. ylim numeric(2) defining y-axis limits. range intensity values used default. main character(1) title plot. default spectrum's MS level retention time (seconds) used. col color used draw peaks. either length 1, equal number spectra (plot spectrum different color) list colors individual peak spectrum. labels allows specify label peak. Can character length equal number peaks, , ideally, function uses one Spectra's variables (see examples ). plotSpectraMirror supports labels type function. labelCex numeric(1) giving amount text magnified relative default. See parameter cex par(). labelSrt numeric(1) defining rotation label. See parameter srt text(). labelAdj see parameter adj text(). labelPos see parameter pos text(). labelOffset see parameter offset text(). labelCol color label(s). asp plotSpectra: target ratio (columns / rows) plotting mutliple spectra (e.g. 20 spectra use asp = 4/5 4 columns 5 rows asp = 5/4 5 columns 4 rows; see grDevices::n2mfrow() details). ... additional parameters passed plot.default() function. axes logical(1) whether (x y) axes drawn. frame.plot logical(1) whether box drawn around plotting area. y plotSpectraMirror: Spectra object length 1 x plotted . ppm plotSpectraMirror: m/z relative acceptable difference (ppm) peaks considered matching (see common() details). tolerance plotSpectraMirror: absolute acceptable difference m/z values peaks considered matching (see common() details). matchCol plotSpectraMirror: color matching peaks. matchLwd plotSpectraMirror: line width (lwd) draw matching peaks. See par() details. matchLty plotSpectraMirror: line type (lty) draw matching peaks. See par() details. matchPch plotSpectraMirror: point character (pch) label matching peaks. Defaults matchPch = 16, set matchPch = NA disable. See par() details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting Spectra — spectra-plotting","text":"functions create plot.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plotting Spectra — spectra-plotting","text":"Johannes Rainer, Sebastian Gibb, Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting Spectra — spectra-plotting","text":"","code":"ints <- list(c(4.3412, 12, 8, 34, 23.4),     c(8, 25, 16, 32)) mzs <- list(c(13.453421, 43.433122, 46.6653553, 129.111212, 322.24432),     c(13.452, 43.5122, 129.112, 322.245))  df <- DataFrame(msLevel = c(1L, 1L), rtime = c(123.12, 124)) df$mz <- mzs df$intensity <- ints sp <- Spectra(df)  #### --------------------------------------------- #### ##                   plotSpectra                     ##  ## Plot one spectrum. plotSpectra(sp[1])  ## Plot both spectra. plotSpectra(sp)   ## Define a color for each peak in each spectrum. plotSpectra(sp, col = list(c(1, 2, 3, 4, 5), 1:4))   ## Color peaks from each spectrum in different colors. plotSpectra(sp, col = c(\"green\", \"blue\"))   ## Label each peak with its m/z. plotSpectra(sp, labels = function(z) format(unlist(mz(z)), digits = 4))   ## Rotate the labels. plotSpectra(sp, labels = function(z) format(unlist(mz(z)), digits = 4),     labelPos = 2, labelOffset = 0.1, labelSrt = -30)   ## Add a custom annotation for each peak. sp$label <- list(c(\"\", \"A\", \"B\", \"C\", \"D\"),     c(\"Frodo\", \"Bilbo\", \"Peregrin\", \"Samwise\")) ## Plot each peak in a different color plotSpectra(sp, labels = function(z) unlist(z$label),     col = list(1:5, 1:4))   ## Plot a single spectrum specifying the label. plotSpectra(sp[2], labels = c(\"A\", \"B\", \"C\", \"D\"))   #### --------------------------------------------- #### ##                plotSpectraOverlay                 ##  ## Plot both spectra overlaying. plotSpectraOverlay(sp)   ## Use a different color for each spectrum. plotSpectraOverlay(sp, col = c(\"#ff000080\", \"#0000ff80\"))  ## Label also the peaks with their m/z if their intensity is above 15. plotSpectraOverlay(sp, col = c(\"#ff000080\", \"#0000ff80\"),     labels = function(z) {         lbls <- format(mz(z)[[1L]], digits = 4)         lbls[intensity(z)[[1L]] <= 15] <- \"\"         lbls     }) abline(h = 15, lty = 2)   ## Use different asp values plotSpectra(sp, asp = 1/2) plotSpectra(sp, asp = 2/1)   #### --------------------------------------------- #### ##                plotSpectraMirror                  ##  ## Plot two spectra against each other. plotSpectraMirror(sp[1], sp[2])  ## Label the peaks with their m/z plotSpectraMirror(sp[1], sp[2],     labels = function(z) format(mz(z)[[1L]], digits = 3),     labelSrt = -30, labelPos = 2, labelOffset = 0.2) grid()   ## The same plot with a tolerance of 0.1 and using a different color to ## highlight matching peaks plotSpectraMirror(sp[1], sp[2],     labels = function(z) format(mz(z)[[1L]], digits = 3),     labelSrt = -30, labelPos = 2, labelOffset = 0.2, tolerance = 0.1,     matchCol = \"#ff000080\", matchLwd = 2) grid()"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapping between spectra variables and data file fields — spectraVariableMapping","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"spectraVariableMapping function provides mapping spectra variables Spectra() object data fields data file. name mapping expected enable easier import data files specific dialects, e.g. files MGF format use different naming convention core spectra variables. MsBackend() implementations expected implement function (needed) enable import data file formats non-standardized data fields.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"","code":"spectraVariableMapping(object, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"object instance object extending MsBackend(). ... Optional parameters.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"named character names spectra variable names (use spectraVariables() list supported names) values data field names.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"Johannes Rainer","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.16","title":"Spectra 1.5","text":"Fix issue neutralLoss prevent calculation neutral loss spectra ","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.15","title":"Spectra 1.5","text":"Fix typo MZ delta plot title.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.14","title":"Spectra 1.5","text":"Add coreSpectraVariables function export core spectra variables expected data types.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.13","title":"Spectra 1.5","text":"Fix figure sizes vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.12","title":"Spectra 1.5","text":"Add neutralLoss method first algorithm calculate neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.11","title":"Spectra 1.5","text":"Fix neutral loss example vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.10","title":"Spectra 1.5","text":"Add citation.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.9","title":"Spectra 1.5","text":"Add examples combineSpectra vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.8","title":"Spectra 1.5","text":"Add spectraVariableMapping generic.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.7","title":"Spectra 1.5","text":"Add missing export filterPrecursorMz method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.6","title":"Spectra 1.5","text":"Add filterPrecursorMzValue method allows filter using multiple precursor m/z values (issue #230). Fix unit test suite.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.5","title":"Spectra 1.5","text":"Add testing framework allowing run standardized unit tests new MsBackend implementations (issue #186).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-12","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.4","title":"Spectra 1.5","text":"Add MsBackendCached backend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.3","title":"Spectra 1.5","text":"calculate number peaks per spectra processing queue Spectra empty. Otherwise call backend’s implementation (issue MsBackendSql #31).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-14","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.2","title":"Spectra 1.5","text":"Small documentation update (related MsCoreUtils issue #87). New countIdentifications() function. Add filterFourierTransformArtefacts function remove fast fourier artefact peaks seen e.g. Orbitrap instruments (issue #223).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.1","title":"Spectra 1.5","text":"Don’t read header information importing peaks matrix macOS.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.11","title":"Spectra 1.3","text":"Fix error message setBackend (issue #217).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.10","title":"Spectra 1.3","text":"Fix bug plotSpectra plotSpectraMirror cause error number peaks spectrum 1 labels provided.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.9","title":"Spectra 1.3","text":"New features: joinSpectraData() now check duplicated keys x (throws error) y (thows warning).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.8","title":"Spectra 1.3","text":"New features: plotMzDelta() function M/Z delta QC (ported MSnbase).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.7","title":"Spectra 1.3","text":"Add fix MSnbase (issue #170) Spectra: macOS require reading also spectrum header reading peaks data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.6","title":"Spectra 1.3","text":"Documentation updates combineSpectra combinePeaks.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.5","title":"Spectra 1.3","text":"filterMzValues supports also removing peaks matching specified m/z values (issue #209).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.4","title":"Spectra 1.3","text":"Add list additional R packages repositories providing MsBackend backends vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.3","title":"Spectra 1.3","text":"Move generics bin compareSpectra ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.2","title":"Spectra 1.3","text":"Add parameter f filterPrecursorScan fix issue #194.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.1","title":"Spectra 1.3","text":"Add estimatePrecursorIntensity function (issue #202).","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.20","title":"Spectra 1.1","text":"Fix concatenating empty spectra (issue #200).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.19","title":"Spectra 1.1","text":"New filterPrecursorCharge() method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.18","title":"Spectra 1.1","text":"Define plotSpectraMirror method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.17","title":"Spectra 1.1","text":"Fix issue #187. Add function concatenateSpectra allow concatenating Spectra objects list Spectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.16","title":"Spectra 1.1","text":"Support arbitrary spectra variables passed functions provided/added addProcessing; issue #182.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.15","title":"Spectra 1.1","text":"Pass spectras’ precursor m/z MAPFUN compareSpectra; issue #171. Add joinPeaksGnps perform peak matching spectra similar one performed GNPS (issue #171).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.14","title":"Spectra 1.1","text":"Support plotting empty spectra (issue 175).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.13","title":"Spectra 1.1","text":"Move ProcessingStep ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.12","title":"Spectra 1.1","text":"Fix show method Spectra list 3 recent processing steps (issue 173). Add processingLog function display log messages processing steps Spectra object.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.11","title":"Spectra 1.1","text":"Add support ... pickPeaks smooth (issue 168).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.10","title":"Spectra 1.1","text":"Import filterIntensity ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.9","title":"Spectra 1.1","text":"Fix label plotSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-12","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.8","title":"Spectra 1.1","text":"filterIntensity supports passing additional parameters used filter function (issue 164).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.7","title":"Spectra 1.1","text":"Fix bug show,ProcessingStep (issue 162).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-14","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.6","title":"Spectra 1.1","text":"New joinSpectraData() function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.5","title":"Spectra 1.1","text":"Add [[,Msbackend [[<-,MsBackend methods (issue 149). Add [[,Spectra [[<-,Spectra methods.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-16","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.4","title":"Spectra 1.1","text":"Fix issue labelCol plotSpectra (issue #157).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-17","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.3","title":"Spectra 1.1","text":"Implement generic Spectra,constructor replacing Spectra,DataFrame Spectra,character.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-18","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.2","title":"Spectra 1.1","text":"Fix problem export mzML files failed empty spectra (issue #145)","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-19","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"Spectra 1.1","text":"Round retention time figure titles. Document differences spectrumId (spectrumID), acquisitionNum scanIndex.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-20","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.0","title":"Spectra 1.1","text":"New Bioc devel version","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.11","title":"Spectra 0.99","text":"Re-add mz intensity core spectra variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.10","title":"Spectra 0.99","text":"Fix spectraData<-,Spectra avoid removing m/z intensity values (issue #146). Add default implementations filter functions MsBackend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.9","title":"Spectra 0.99","text":"Fix Spectra,character constructor ensure backend changed even source inherits backend (issue #143).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.8","title":"Spectra 0.99","text":"combineSpectra applies data processing steps processing queue prior combination (issue #140).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.7","title":"Spectra 0.99","text":"Fix problem dropNaSpectraVariables also drop m/z intensity values backends (issue #138.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.6","title":"Spectra 0.99","text":"Support intensity filterIntensity method function enable peak intensity-based filtering spectra (issue #126).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.5","title":"Spectra 0.99","text":"Add filterMzRange filterMzValues filter spectra based m/z range list target m/z values, respectively.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.4","title":"Spectra 0.99","text":"Add export,MsBackendMzR export spectra data mzML mzXML file(s). Add export,MsBackend method allow backends take care data export. Refactor export,Spectra use MsBackend class export data. Change parameter source Spectra,character MsBackendMzR set parameter backend = source. Thus default, import backend also used store data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.3","title":"Spectra 0.99","text":"Replace lapply,Spectra spectrapply,Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.2","title":"Spectra 0.99","text":"Replace asDataFrame,MsBackend spectraData,MsBackend. Replace asDataFrame<-,MsBackend spectraData<-,MsBackend. Replace .list,MsBackend peaksData,MsBackend. Replace replaceList<-,MsBackend peaksData<-,MsBackend. Replace .list,Spectra peaksData,Spectra add methods coerce Spectra list SimpleList.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.0","title":"Spectra 0.99","text":"Add reset method. Add processing chunk compareSpectra.","code":""}]
