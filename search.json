[{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating new `MsBackend` classes","text":"vignette briefly describes MsBackend class used Spectra package represent provide Mass Spectrometry (MS) data illustrates new backend class can created tested validity. Contributions vignette (content correction typos) requests additional details information highly welcome (ideally via pull requests github issues).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"what-is-a-msbackend","dir":"Articles","previous_headings":"","what":"What is a MsBackend?","title":"Creating new `MsBackend` classes","text":"Spectra package separates code analysis MS data code needed import, represent provide data. former implemented Spectra class main object users use analyses. Spectra object relies -called backend provide MS data. MsBackend virtual class defines API new backend classes need implement order used Spectra object. Spectra object contains implementation MsBackend within @backend slot provides MS data Spectra object. data management thus hidden user. addition separation allows define new, alternative, data representations integrate seamlessly Spectra-based data analysis workflow. concept extension -memory -disk data representations MSnbase package (Gatto, Gibb, Rainer 2020).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"conventions-and-definitions","dir":"Articles","previous_headings":"What is a MsBackend?","what":"Conventions and definitions","title":"Creating new `MsBackend` classes","text":"General conventions MS data Spectra : One Spectra object supposed contain MS (spectral) data multiple MS spectra. m/z values within spectrum expected sorted increasingly. Missing values (NA) m/z values supported. Properties spectrum called spectra variables. backends can define properties, minimum required set spectra variables must provided backend (even values empty). core spectra variables listed (along expected data type) coreSpectraVariables() function. dataStorage dataOrigin two special spectra variables define spectrum data stored data derived (loaded, data origin). expected typecharacter need defined backend (.e., can empty missing). MsBackend implementations can also represent purely read-data resources. case data accessor methods need implemented data replacement methods. Whether backend read-can set @readonly slot virtual MsBackend class (isReadOnly() function can used retrieve value slot). default @readonly = FALSE thus data replacement method listed section Data replacement methods implemented. read-backends (@readonly = TRUE) methods section Required methods need implemented. Backends can also partially read-, MsBackendMzR. backend allows example change spectra variables, peaks data (.e. m/z intensity values). Also, backends purely read-resources extend MsBackendCached Spectra package enable support modifying (adding) spectra variables. changes spectra variables internally cached MsBackendCached without need propagating underlying data resource (see example MsBackendMassbankSql MsBackendMassbank package).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"notes-on-parallel-processing","dir":"Articles","previous_headings":"What is a MsBackend?","what":"Notes on parallel processing","title":"Creating new `MsBackend` classes","text":"parallel processing, Spectra splits backend based defined factor processes parallel (serial SerialParam used). splitting factor can defined Spectra setting parameter processingChunkSize. Alternatively, backendParallelFactor() function backend can also suggest factor /used splitting parallel processing. default implementation backendParallelFactor() return empty factor (factor()) hence suggesting preferred splitting. backendParallelFactor() MsBackendMzR hand returns factor based data files data stored (.e. based dataStorage MS data). Besides parallel processing, chunk-wise processing can also reduce memory demand operations, peak data current chunk needs realized memory.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"api","dir":"Articles","previous_headings":"","what":"API","title":"Creating new `MsBackend` classes","text":"MsBackend class defines core methods implemented MS backend well optional methods default implementations might implemented new backend don’t necessarily . functions described sections Required methods Optional methods, respectively. create new backend class extending virtual MsBackend needs implemented. example create thus simple class data.frame contain general spectral properties (spectra variables) two slots m/z intensity values. stored NumericList objects since m/z intensity values expected type numeric allow store data multiple spectra single backend object. also define simple constructor function returns empty instance new class. 3 slots spectraVars, mz intensity used store MS data, row spectraVars data one spectrum columns different spectra variables (.e. additional properties spectrum retention time MS level) element mz intensity numeric m/z intensity values respective spectrum. ideally also add basic validity function ensures data OK. function simply checks number rows spectraVars slot matches length mz intensity slot. can now create instance new class MsBackendTest() function. Note backend class necessarily need contain data like one example. Backends MsBackendMzR example retrieve data fly raw MS data files MsBackendSql MsBackendSql SQL database.","code":"library(Spectra) library(IRanges)  setClass(\"MsBackendTest\",          contains = \"MsBackend\",          slots = c(              spectraVars = \"data.frame\",              mz = \"NumericList\",              intensity = \"NumericList\"          ),          prototype = prototype(              spectraVars = data.frame(),              mz = NumericList(compress = FALSE),              intensity = NumericList(compress = FALSE)          ))  MsBackendTest <- function() {     new(\"MsBackendTest\") } setValidity(\"MsBackendTest\", function(object) {     if (length(object@mz) != length(object@intensity) ||         length(object@mz) != nrow(object@spectraVars))         return(\"length of 'mz' and 'intensity' has to match the number of \",                \"rows of 'spectraVars'\")     NULL }) ## Class \"MsBackendTest\" [in \".GlobalEnv\"] ##  ## Slots: ##                                                                    ## Name:  spectraVars          mz   intensity    readonly     version ## Class:  data.frame NumericList NumericList     logical   character ##  ## Extends: \"MsBackend\" MsBackendTest() ## An object of class \"MsBackendTest\" ## Slot \"spectraVars\": ## data frame with 0 columns and 0 rows ##  ## Slot \"mz\": ## NumericList of length 0 ##  ## Slot \"intensity\": ## NumericList of length 0 ##  ## Slot \"readonly\": ## [1] FALSE ##  ## Slot \"version\": ## [1] \"0.1\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"required-methods","dir":"Articles","previous_headings":"API","what":"Required methods","title":"Creating new `MsBackend` classes","text":"Methods listed section must implemented new class extending MsBackend. Methods ideally also implemented order listed . Also, strongly advised write dedicated unit tests newly implemented method function already development.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"datastorage","dir":"Articles","previous_headings":"API > Required methods","what":"dataStorage()","title":"Creating new `MsBackend` classes","text":"dataStorage spectra variable spectrum provides information data stored. dataStorage() method therefor return character vector length equal number spectra backend object information. backends data storage information can simple string \"memory\" \"database\" specify data spectrum stored within object database, respectively. Backend classes keep subset MS data memory need load data data files upon request use spectra variable store keep track original data file spectrum. example MsBackendMzR backend retrieves MS data --fly original data file(s) whenever m/z intensity values requested backend. Calling dataStorage() MsBackendMzR returns thus names originating files. example backend define simple dataStorage() method simply returns column \"dataStorage\" @svars (character).","code":"setMethod(\"dataStorage\", \"MsBackendTest\", function(object) {     as.character(object@spectraVars$dataStorage) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"length","dir":"Articles","previous_headings":"API > Required methods","what":"length()","title":"Creating new `MsBackend` classes","text":"length() expected return single integer total number spectra available backend class. example backend simply return number rows data.frame stored @spectraVars slot.","code":"setMethod(\"length\", \"MsBackendTest\", function(x) {     nrow(x@spectraVars) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"backendinitialize","dir":"Articles","previous_headings":"API > Required methods","what":"backendInitialize()","title":"Creating new `MsBackend` classes","text":"backendInitialize() method expected called creating instance backend class prepare (initialize) backend cases means MS data loaded. method can take parameters needed backend get loaded/initialized data (can file names load data, database connection object(s) containing data). backendInitialize() usually also special spectra variables dataStorage dataOrigin set. define backendInitialize() method takes arguments data.frame spectra variables two lists m/z intensity values spectrum. addition adding data object, function also defined dataStorage dataOrigin spectra variables. purpose two variables provide information data stored (memory example) data originating. dataOrigin example allow specify original data files individual spectra derive. can now create instance backend class fill data. thus first define MS data pass backendInitialize() method. method works compliant MsBackend API (requirement input parameters backendInitialize() method), good practice backends supposed support replacing data, add optional additional parameter data allow passing complete MS data (including m/z intensity values) function DataFrame. simplify implementation replacement methods addition also allow change backend Spectra using setBackend() new backend. thus re-implement backendInitialize() method supporting also initialize backend data frame also implement helper function checks spectra variables correct data type. function used check input data new backendInitialize() method. create backend updated backendInitialize(). backendInitialize() method implemented backend class expects user provide full MS data. however always case. backendInitialize() method MsBackendMzR backend takes example file names raw mzML, mzXML CDF files input initializes backend importing part data . Also backends defined MsBackendMgf r Biocpkg(\"MsBackendMsp\") packages work way thus allow import MS data specific file formats. backendInitialize() method backend defined MsBackendSql hand takes connection database containing data input performs sanity checks data load data backend. subsequent data access handled methods backend class SQL calls database. purpose backendInitialize() method initialize prepare data way can accessed Spectra object (initialized backend class). Whether data loaded backendInitialize() method memory simply referenced within backend class matter long backend able provide data accessor methods. Note also backendInitialize() function ideally also perform data sanity checks (e.g. whether spectra variables correct data type etc).","code":"setMethod(     \"backendInitialize\", \"MsBackendTest\",     function(object, svars, mz, intensity) {         if (!is.data.frame(svars))             stop(\"'svars' needs to be a 'data.frame' with spectra variables\")         if (is.null(svars$dataStorage))             svars$dataStorage <- \"<memory>\"         if (is.null(svars$dataOrigin))             svars$dataOrigin <- \"<user provided>\"         object@spectraVars <- svars         object@mz <- NumericList(mz, compress = FALSE)         object@intensity <- NumericList(intensity, compress = FALSE)         validObject(object)         object     }) ## A data.frame with spectra variables. svars <- data.frame(msLevel = c(1L, 2L, 2L),                     rtime = c(1.2, 1.3, 1.4)) ## m/z values for each spectrum. mzs <- list(c(12.3, 13.5, 16.5, 17.5),             c(45.1, 45.2),             c(64.4, 123.1, 124.1)) ## intensity values for each spectrum. ints <- list(c(123.3, 153.6, 2354.3, 243.4),              c(100, 80.1),              c(12.3, 35.2, 100))  ## Create and initialize the backend be <- backendInitialize(MsBackendTest(),                         svars = svars, mz = mzs, intensity = ints) be ## An object of class \"MsBackendTest\" ## Slot \"spectraVars\": ##   msLevel rtime dataStorage      dataOrigin ## 1       1   1.2    <memory> <user provided> ## 2       2   1.3    <memory> <user provided> ## 3       2   1.4    <memory> <user provided> ##  ## Slot \"mz\": ## NumericList of length 3 ## [[1]] 12.3 13.5 16.5 17.5 ## [[2]] 45.1 45.2 ## [[3]] 64.4 123.1 124.1 ##  ## Slot \"intensity\": ## NumericList of length 3 ## [[1]] 123.3 153.6 2354.3 243.4 ## [[2]] 100 80.1 ## [[3]] 12.3 35.2 100 ##  ## Slot \"readonly\": ## [1] FALSE ##  ## Slot \"version\": ## [1] \"0.1\" #' Helper function to check if core spectra variables have the correct #' data type. #' #' @param x `data.frame` with the data for spectra variables. #' #' @param name `character` defining the column names (spectra variables) of `x` #'     for which the correct data type should be evaluated. .sv_valid_data_type <- function(x, name = colnames(x)) {     sv <- coreSpectraVariables()[names(coreSpectraVariables()) %in% name]     for (i in seq_along(sv)) {         if (!is(x[, names(sv[i])], sv[i]))             stop(\"Spectra variabe \\\"\", names(sv[i]), \"\\\" is not of type \",                  sv[i], call. = FALSE)     }     TRUE } setMethod(     \"backendInitialize\", \"MsBackendTest\",     function(object, svars, mz, intensity, data) {         if (!missing(data)) {             svars <- as.data.frame(                 data[, !colnames(data) %in% c(\"mz\", \"intensity\")])             if (any(colnames(data) == \"mz\"))                 mz <- data$mz             if (any(colnames(data) == \"intensity\"))                 intensity <- data$intensity         }         if (!is.data.frame(svars))             stop(\"'svars' needs to be a 'data.frame' with spectra variables\")         if (is.null(svars$dataStorage))             svars$dataStorage <- \"<memory>\"         if (is.null(svars$dataOrigin))             svars$dataOrigin <- \"<user provided>\"         .sv_valid_data_type(svars)         object@spectraVars <- svars         object@mz <- NumericList(mz, compress = FALSE)         object@intensity <- NumericList(intensity, compress = FALSE)         validObject(object)         object     }) ## Create and initialize the backend be <- backendInitialize(MsBackendTest(),                         svars = svars, mz = mzs, intensity = ints) be ## An object of class \"MsBackendTest\" ## Slot \"spectraVars\": ##   msLevel rtime dataStorage      dataOrigin ## 1       1   1.2    <memory> <user provided> ## 2       2   1.3    <memory> <user provided> ## 3       2   1.4    <memory> <user provided> ##  ## Slot \"mz\": ## NumericList of length 3 ## [[1]] 12.3 13.5 16.5 17.5 ## [[2]] 45.1 45.2 ## [[3]] 64.4 123.1 124.1 ##  ## Slot \"intensity\": ## NumericList of length 3 ## [[1]] 123.3 153.6 2354.3 243.4 ## [[2]] 100 80.1 ## [[3]] 12.3 35.2 100 ##  ## Slot \"readonly\": ## [1] FALSE ##  ## Slot \"version\": ## [1] \"0.1\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"spectravariables","dir":"Articles","previous_headings":"API > Required methods","what":"spectraVariables()","title":"Creating new `MsBackend` classes","text":"spectraVariables() method return character vector names available spectra variables backend. backend class support defining providing spectra variables, MsBackend class must provide also core spectra variables (correct data type). Since data file formats provide values spectra variables can however also NA (exception spectra variable \"dataStorage\"). coreSpectraVariables() function returns full list mandatory spectra variables along expected data type. typical spectraVariables() method MsBackend class thus implemented similarly one MsBackendTest test backend: return union core spectra variables names available spectra variables within backend object.","code":"coreSpectraVariables() ##                 msLevel                   rtime          acquisitionNum  ##               \"integer\"               \"numeric\"               \"integer\"  ##               scanIndex                      mz               intensity  ##               \"integer\"           \"NumericList\"           \"NumericList\"  ##             dataStorage              dataOrigin              centroided  ##             \"character\"             \"character\"               \"logical\"  ##                smoothed                polarity             precScanNum  ##               \"logical\"               \"integer\"               \"integer\"  ##             precursorMz      precursorIntensity         precursorCharge  ##               \"numeric\"               \"numeric\"               \"integer\"  ##         collisionEnergy  isolationWindowLowerMz isolationWindowTargetMz  ##               \"numeric\"               \"numeric\"               \"numeric\"  ##  isolationWindowUpperMz  ##               \"numeric\" setMethod(\"spectraVariables\", \"MsBackendTest\", function(object) {     union(names(coreSpectraVariables()), colnames(object@spectraVars)) }) spectraVariables(be) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"mz\"                      \"intensity\"               ##  [7] \"dataStorage\"             \"dataOrigin\"              ##  [9] \"centroided\"              \"smoothed\"                ## [11] \"polarity\"                \"precScanNum\"             ## [13] \"precursorMz\"             \"precursorIntensity\"      ## [15] \"precursorCharge\"         \"collisionEnergy\"         ## [17] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [19] \"isolationWindowUpperMz\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"spectradata","dir":"Articles","previous_headings":"API > Required methods","what":"spectraData()","title":"Creating new `MsBackend` classes","text":"spectraData() method return full spectra data within backend DataFrame object (defined S4Vectors package). second parameter columns allows define names spectra variables returned DataFrame. row data frame represent one spectrum, column spectra variable. Columns \"mz\" \"intensity\" (requested) contain NumericList m/z intensity values spectra. DataFrame must provide values (even NA) requested spectra variables backend (including core spectra variables). now first problem toy backend class, since keep spectra variable data simple data.frame without constraints required columns etc. simple solution (also used backend classes Spectra package) fill missing spectra variables --fly returned DataFrame. thus define simple helper function adds columns missing values (correct data type) core spectra variables available within backend result. next implement spectraData() method uses helper function fill eventually missing core spectra variables. Note also function return DataFrame even single column. alternative, also initialize @spectraVars data frame within backendInitialize() method adding columns spectra variables provided user require data frame always contains core spectra variables. Extracting spectra data (single spectra variables full data) might thus efficient --fly initialization eventual missing spectra variables, backend class also larger memory footprint even spectra variables missing values spectra need stored within object. can now use spectraData() either extract full spectra data backend, data selected spectra variables.","code":"#' @description Add columns with missing core spectra variables. #' #' @param x `data.frame` or `DataFrame` with some spectra variables. #' #' @param core_vars `character` with core spectra variable names that should #'     be added to `x` if not already present. #' .fill_core_variables <- function(x, core_vars = names(coreSpectraVariables())) {     fill_vars <- setdiff(core_vars, colnames(x))     core_type <- coreSpectraVariables()     n <- nrow(x)     if (length(fill_vars)) {         fill <- lapply(fill_vars, function(z) {             rep(as(NA, core_type[z]), n)         })         names(fill) <- fill_vars         x <- cbind(x, as.data.frame(fill))     }     x } setMethod(     \"spectraData\", \"MsBackendTest\",     function(object, columns = spectraVariables(object)) {         if (!all(columns %in% spectraVariables(object)))             stop(\"Some of the requested spectra variables are not available\")         ## Add m/z and intensity values to the result         res <- DataFrame(object@spectraVars)         res$mz <- object@mz         res$intensity <- object@intensity         ## Fill with eventually missing core variables         res <- .fill_core_variables(             res, intersect(columns, names(coreSpectraVariables())))         res[, columns, drop = FALSE] }) ## Full data spectraData(be) ## DataFrame with 3 rows and 19 columns ##     msLevel     rtime acquisitionNum scanIndex                 mz ##   <integer> <numeric>      <integer> <integer>      <NumericList> ## 1         1       1.2             NA        NA 12.3,13.5,16.5,... ## 2         2       1.3             NA        NA          45.1,45.2 ## 3         2       1.4             NA        NA   64.4,123.1,124.1 ##                  intensity dataStorage      dataOrigin centroided  smoothed ##              <NumericList> <character>     <character>  <logical> <logical> ## 1  123.3, 153.6,2354.3,...    <memory> <user provided>         NA        NA ## 2              100.0, 80.1    <memory> <user provided>         NA        NA ## 3         12.3, 35.2,100.0    <memory> <user provided>         NA        NA ##    polarity precScanNum precursorMz precursorIntensity precursorCharge ##   <integer>   <integer>   <numeric>          <numeric>       <integer> ## 1        NA          NA          NA                 NA              NA ## 2        NA          NA          NA                 NA              NA ## 3        NA          NA          NA                 NA              NA ##   collisionEnergy isolationWindowLowerMz isolationWindowTargetMz ##         <numeric>              <numeric>               <numeric> ## 1              NA                     NA                      NA ## 2              NA                     NA                      NA ## 3              NA                     NA                      NA ##   isolationWindowUpperMz ##                <numeric> ## 1                     NA ## 2                     NA ## 3                     NA ## Selected variables spectraData(be, c(\"rtime\", \"mz\", \"centroided\")) ## DataFrame with 3 rows and 3 columns ##       rtime                 mz centroided ##   <numeric>      <NumericList>  <logical> ## 1       1.2 12.3,13.5,16.5,...         NA ## 2       1.3          45.1,45.2         NA ## 3       1.4   64.4,123.1,124.1         NA ## Only missing core spectra variables spectraData(be, c(\"centroided\", \"polarity\")) ## DataFrame with 3 rows and 2 columns ##   centroided  polarity ##    <logical> <integer> ## 1         NA        NA ## 2         NA        NA ## 3         NA        NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"peaksdata","dir":"Articles","previous_headings":"API > Required methods","what":"peaksData()","title":"Creating new `MsBackend` classes","text":"peaksData() method extracts MS peaks data backend, includes m/z intensity values MS peak spectrum. expected returned List numerical matrices columns matrix requested peaks variables (default \"mz\" \"intensity\") one spectrum. Backends must provide least two peaks variables. implement peaksData() method backend. need loop @mz @intensity slots merge m/z intensity spectrum matrix. Also, simplicity reasons, accept c(\"mz\", \"intensity\") columns parameter. expected default behavior MsBackend, general columns parameter thought allow user specify peaks variables returned matrix. method can now extract peaks data backend. peaksData() method used many data analysis functions Spectra object extract MS data, thus ideally method implemented efficient way. backend need loop lists m/z intensity values obviously ideal. Thus, storing m/z intensity values separate slots done backend might ideal. MsBackendMemory backend example stores MS data already list matrices results efficient peaksData() method (comes also larger overhead adding, replacing checking MS data). Note also backend needs provide m/z intensity values, additional peak variables also supported. MsBackendMemory class example allows store provide additional peak variables can added additional columns returned matrix. case default peaksVariables() method also overwritten list additionally available variables columns parameter peaksData() method allow selection additional peaks variables (addition required \"mz\" \"intensity\" variables).","code":"setMethod(     \"peaksData\", \"MsBackendTest\",     function(object, columns = c(\"mz\", \"intensity\")) {         if (length(columns) != 2 && columns != c(\"mz\", \"intensity\"))             stop(\"'columns' supports only \\\"mz\\\" and \\\"intensity\\\"\")         mapply(mz = object@mz, intensity = object@intensity,                FUN = cbind, SIMPLIFY = FALSE, USE.NAMES = FALSE)     }) peaksData(be) ## [[1]] ##        mz intensity ## [1,] 12.3     123.3 ## [2,] 13.5     153.6 ## [3,] 16.5    2354.3 ## [4,] 17.5     243.4 ##  ## [[2]] ##        mz intensity ## [1,] 45.1     100.0 ## [2,] 45.2      80.1 ##  ## [[3]] ##         mz intensity ## [1,]  64.4      12.3 ## [2,] 123.1      35.2 ## [3,] 124.1     100.0"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"section","dir":"Articles","previous_headings":"API > Required methods","what":"[","title":"Creating new `MsBackend` classes","text":"[ method allows subset MsBackend objects. operation expected reduce MsBackend object selected spectra. method support subset indices logical vectors also support duplicating elements (.e. duplicated indices used) well subset arbitrary order. error thrown indices bounds, method also support returning empty backend [integer()]. Note MsCoreUtils::i2index function can used check correct input (convert input integer index). implement possible [ test backend class. ignore parameters j definition [ generic, since treat data one-dimensional (spectrum one element). can now subset backend last two spectra. extracting second spectrum multiple times.","code":"setMethod(\"[\", \"MsBackendTest\", function(x, i, j, ..., drop = FALSE) {     i <- MsCoreUtils::i2index(i, length = length(x))     x@spectraVars <- x@spectraVars[i, ]     x@mz <- x@mz[i]     x@intensity <- x@intensity[i]     x }) a <- be[2:3] spectraData(a) ## DataFrame with 2 rows and 19 columns ##     msLevel     rtime acquisitionNum scanIndex                mz ##   <integer> <numeric>      <integer> <integer>     <NumericList> ## 1         2       1.3             NA        NA         45.1,45.2 ## 2         2       1.4             NA        NA  64.4,123.1,124.1 ##           intensity dataStorage      dataOrigin centroided  smoothed  polarity ##       <NumericList> <character>     <character>  <logical> <logical> <integer> ## 1       100.0, 80.1    <memory> <user provided>         NA        NA        NA ## 2  12.3, 35.2,100.0    <memory> <user provided>         NA        NA        NA ##   precScanNum precursorMz precursorIntensity precursorCharge collisionEnergy ##     <integer>   <numeric>          <numeric>       <integer>       <numeric> ## 1          NA          NA                 NA              NA              NA ## 2          NA          NA                 NA              NA              NA ##   isolationWindowLowerMz isolationWindowTargetMz isolationWindowUpperMz ##                <numeric>               <numeric>              <numeric> ## 1                     NA                      NA                     NA ## 2                     NA                      NA                     NA a <- be[c(2, 2, 2)] spectraData(a) ## DataFrame with 3 rows and 19 columns ##       msLevel     rtime acquisitionNum scanIndex            mz     intensity ##     <integer> <numeric>      <integer> <integer> <NumericList> <NumericList> ## 2           2       1.3             NA        NA     45.1,45.2   100.0, 80.1 ## 2.1         2       1.3             NA        NA     45.1,45.2   100.0, 80.1 ## 2.2         2       1.3             NA        NA     45.1,45.2   100.0, 80.1 ##     dataStorage      dataOrigin centroided  smoothed  polarity precScanNum ##     <character>     <character>  <logical> <logical> <integer>   <integer> ## 2      <memory> <user provided>         NA        NA        NA          NA ## 2.1    <memory> <user provided>         NA        NA        NA          NA ## 2.2    <memory> <user provided>         NA        NA        NA          NA ##     precursorMz precursorIntensity precursorCharge collisionEnergy ##       <numeric>          <numeric>       <integer>       <numeric> ## 2            NA                 NA              NA              NA ## 2.1          NA                 NA              NA              NA ## 2.2          NA                 NA              NA              NA ##     isolationWindowLowerMz isolationWindowTargetMz isolationWindowUpperMz ##                  <numeric>               <numeric>              <numeric> ## 2                       NA                      NA                     NA ## 2.1                     NA                      NA                     NA ## 2.2                     NA                      NA                     NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"backendmerge","dir":"Articles","previous_headings":"API > Required methods","what":"backendMerge()","title":"Creating new `MsBackend` classes","text":"backendMerge() method merges (combines) MsBackend objects (type!) single instance. test backend thus need combine values @spectraVars, @mz @intensity slots. support also merging data.frames different set columns use MsCoreUtils::rbindFill() function instead simple rbind() (function joins data frames making union available columns). , implementation requires 3 loops might efficient - allows merge backends type MsBackendTest.","code":"setMethod(\"backendMerge\", \"MsBackendTest\", function(object, ...) {     res <- object     object <- unname(c(object, ...))     res@mz <- do.call(c, lapply(object, function(z) z@mz))     res@intensity <- do.call(c, lapply(object, function(z) z@intensity))     res@spectraVars <- do.call(MsCoreUtils::rbindFill,                                lapply(object, function(z) z@spectraVars))     validObject(res)     res }) a <- backendMerge(be, be[2], be) a ## An object of class \"MsBackendTest\" ## Slot \"spectraVars\": ##    msLevel rtime dataStorage      dataOrigin ## 1        1   1.2    <memory> <user provided> ## 2        2   1.3    <memory> <user provided> ## 3        2   1.4    <memory> <user provided> ## 21       2   1.3    <memory> <user provided> ## 11       1   1.2    <memory> <user provided> ## 22       2   1.3    <memory> <user provided> ## 31       2   1.4    <memory> <user provided> ##  ## Slot \"mz\": ## NumericList of length 7 ## [[1]] 12.3 13.5 16.5 17.5 ## [[2]] 45.1 45.2 ## [[3]] 64.4 123.1 124.1 ## [[4]] 45.1 45.2 ## [[5]] 12.3 13.5 16.5 17.5 ## [[6]] 45.1 45.2 ## [[7]] 64.4 123.1 124.1 ##  ## Slot \"intensity\": ## NumericList of length 7 ## [[1]] 123.3 153.6 2354.3 243.4 ## [[2]] 100 80.1 ## [[3]] 12.3 35.2 100 ## [[4]] 100 80.1 ## [[5]] 123.3 153.6 2354.3 243.4 ## [[6]] 100 80.1 ## [[7]] 12.3 35.2 100 ##  ## Slot \"readonly\": ## [1] FALSE ##  ## Slot \"version\": ## [1] \"0.1\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"section-1","dir":"Articles","previous_headings":"API > Required methods","what":"$","title":"Creating new `MsBackend` classes","text":"$ method expected extract single spectra variable backend. Parameter name allow name spectra variable return. MsBackend must support extracting core spectra variables method (even data might available variable). example implementation make use spectraData() method, efficient implementations might available well (require first subset/create DataFrame full data subset ). Also, $ method check requested spectra variable available throw error otherwise. can now extract MS levels core spectra variable available within backend. also m/z values","code":"setMethod(\"$\", \"MsBackendTest\", function(x, name) {     spectraData(x, columns = name)[, 1L] }) be$msLevel ## [1] 1 2 2 be$precursorMz ## [1] NA NA NA be$mz ## NumericList of length 3 ## [[1]] 12.3 13.5 16.5 17.5 ## [[2]] 45.1 45.2 ## [[3]] 64.4 123.1 124.1"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"lengths","dir":"Articles","previous_headings":"API > Required methods","what":"lengths()","title":"Creating new `MsBackend` classes","text":"lengths() method expected return integer vector (length number spectra backend) total number peaks per spectrum. MsBackendTest can simply use lengths() method m/z intensity values . can now get peaks count per spectrum:","code":"setMethod(\"lengths\", \"MsBackendTest\", function(x, use.names = FALSE) {     lengths(x@mz, use.names = use.names) }) lengths(be) ## [1] 4 2 3"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isempty","dir":"Articles","previous_headings":"API > Required methods","what":"isEmpty()","title":"Creating new `MsBackend` classes","text":"isEmpty() method expected return spectrum information whether empty, .e. contain MS peaks (hence m/z intensity values). result method logical length equal number spectra represented backend TRUE indicating whether spectrum empty FALSE otherwise. implementation isEmpty() method use lenghts() method defined returns number MS peaks per spectrum.","code":"setMethod(\"isEmpty\", \"MsBackendTest\", function(x) {     lengths(x) == 0L }) isEmpty(be) ## [1] FALSE FALSE FALSE"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"acquisitionnum","dir":"Articles","previous_headings":"API > Required methods","what":"acquisitionNum()","title":"Creating new `MsBackend` classes","text":"Extract acquisitionNum core spectra variable. method expected return integer vector length spectra represented backend. backend simply re-use spectraData() method.","code":"setMethod(\"acquisitionNum\", \"MsBackendTest\", function(object) {     spectraData(object, \"acquisitionNum\")[, 1L] }) acquisitionNum(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"centroided","dir":"Articles","previous_headings":"API > Required methods","what":"centroided()","title":"Creating new `MsBackend` classes","text":"Extract spectrum information whether contains centroided data. method expected return logical vector length spectra represented backend.","code":"setMethod(\"centroided\", \"MsBackendTest\", function(object) {     spectraData(object, \"centroided\")[, 1L] }) centroided(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"collisionenergy","dir":"Articles","previous_headings":"API > Required methods","what":"collisionEnergy()","title":"Creating new `MsBackend` classes","text":"Extract spectrum collision energy applied generate fragment spectrum. method expected return numeric vector length spectra represented backend (NA_real_ spectra information available, MS1 spectra).","code":"setMethod(\"collisionEnergy\", \"MsBackendTest\", function(object) {     spectraData(object, \"collisionEnergy\")[, 1L] }) collisionEnergy(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"dataorigin","dir":"Articles","previous_headings":"API > Required methods","what":"dataOrigin()","title":"Creating new `MsBackend` classes","text":"Extract data origin spectra variable spectrum. spectra variable can used store origin spectra. method expected return character vector length equal number spectra represented backend.","code":"setMethod(\"dataOrigin\", \"MsBackendTest\", function(object) {     spectraData(object, \"dataOrigin\")[, 1L] }) dataOrigin(be) ## [1] \"<user provided>\" \"<user provided>\" \"<user provided>\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"intensity","dir":"Articles","previous_headings":"API > Required methods","what":"intensity()","title":"Creating new `MsBackend` classes","text":"Extract intensity values spectrum backend. result expected NumericList length equal number spectra represented backend. test backend can simply return @intensity slot since data already stored within NumericList.","code":"setMethod(\"intensity\", \"MsBackendTest\", function(object) {     object@intensity }) intensity(be) ## NumericList of length 3 ## [[1]] 123.3 153.6 2354.3 243.4 ## [[2]] 100 80.1 ## [[3]] 12.3 35.2 100"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowlowermz","dir":"Articles","previous_headings":"API > Required methods","what":"isolationWindowLowerMz()","title":"Creating new `MsBackend` classes","text":"Extract core spectra variable isolationWindowLowerMz backend. information usually provided spectrum raw mzML files. method expected return numeric vector length equal number spectra represented backend.","code":"setMethod(\"isolationWindowLowerMz\", \"MsBackendTest\", function(object) {     spectraData(object, \"isolationWindowLowerMz\")[, 1L] }) isolationWindowLowerMz(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowtargetmz","dir":"Articles","previous_headings":"API > Required methods","what":"isolationWindowTargetMz()","title":"Creating new `MsBackend` classes","text":"Extract core spectra variable isolationWindowTargetMz backend. information usually provided spectrum raw mzML files. method expected return numeric vector length equal number spectra represented backend.","code":"setMethod(\"isolationWindowTargetMz\", \"MsBackendTest\", function(object) {     spectraData(object, \"isolationWindowTargetMz\")[, 1L] }) isolationWindowTargetMz(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowuppermz","dir":"Articles","previous_headings":"API > Required methods","what":"isolationWindowUpperMz()","title":"Creating new `MsBackend` classes","text":"Extract core spectra variable isolationWindowUpperMz backend. information usually provided spectrum raw mzML files. method expected return numeric vector length equal number spectra represented backend.","code":"setMethod(\"isolationWindowUpperMz\", \"MsBackendTest\", function(object) {     spectraData(object, \"isolationWindowUpperMz\")[, 1L] }) isolationWindowUpperMz(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"mslevel","dir":"Articles","previous_headings":"API > Required methods","what":"msLevel()","title":"Creating new `MsBackend` classes","text":"Extract MS level spectrum backend. method expected return integer length equal number spectra represented backend.","code":"setMethod(\"msLevel\", \"MsBackendTest\", function(object) {     spectraData(object, \"msLevel\")[, 1L] }) msLevel(be) ## [1] 1 2 2"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"mz","dir":"Articles","previous_headings":"API > Required methods","what":"mz()","title":"Creating new `MsBackend` classes","text":"Extract m/z values spectrum backend. result expected NumericList length equal number spectra represented backend. Also, m/z values expected ordered increasingly element (spectrum).","code":"setMethod(\"mz\", \"MsBackendTest\", function(object) {     object@mz }) mz(be) ## NumericList of length 3 ## [[1]] 12.3 13.5 16.5 17.5 ## [[2]] 45.1 45.2 ## [[3]] 64.4 123.1 124.1"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"polarity","dir":"Articles","previous_headings":"API > Required methods","what":"polarity()","title":"Creating new `MsBackend` classes","text":"Extract polarity core spectra variable spectrum backend. method expected return integer length equal number spectra represented backend. Negative positive polarity expected encoded 0L 1L, respectively.","code":"setMethod(\"polarity\", \"MsBackendTest\", function(object) {     spectraData(object, \"polarity\")[, 1L] }) polarity(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"precscannum","dir":"Articles","previous_headings":"API > Required methods","what":"precScanNum()","title":"Creating new `MsBackend` classes","text":"Extract acquisition number precursor spectrum. method expected return integer length equal number spectra represented backend. MS1 spectra (acquisition number precursor provided) NA_integer_ returned.","code":"setMethod(\"precScanNum\", \"MsBackendTest\", function(object) {     spectraData(object, \"precScanNum\")[, 1L] }) precScanNum(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"precursorcharge","dir":"Articles","previous_headings":"API > Required methods","what":"precursorCharge()","title":"Creating new `MsBackend` classes","text":"Extract charge precursor spectrum. method expected return integer length equal number spectra represented backend. MS1 spectra (charge precursor provided) NA_integer_ returned.","code":"setMethod(\"precursorCharge\", \"MsBackendTest\", function(object) {     spectraData(object, \"precursorCharge\")[, 1L] }) precursorCharge(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"precursorintensity","dir":"Articles","previous_headings":"API > Required methods","what":"precursorIntensity()","title":"Creating new `MsBackend` classes","text":"Extract intensity precursor spectrum. method expected return numeric length equal number spectra represented backend. MS1 spectra (precursor intensity fragment spectrum provided) NA_real_ returned.","code":"setMethod(\"precursorIntensity\", \"MsBackendTest\", function(object) {     spectraData(object, \"precursorIntensity\")[, 1L] }) precursorIntensity(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"precursormz","dir":"Articles","previous_headings":"API > Required methods","what":"precursorMz()","title":"Creating new `MsBackend` classes","text":"Extract precursor m/z spectrum. method expected return numeric length equal number spectra represented backend. MS1 spectra (precursor m/z fragment spectrum provided) NA_real_ returned.","code":"setMethod(\"precursorMz\", \"MsBackendTest\", function(object) {     spectraData(object, \"precursorMz\")[, 1L] }) precursorMz(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"rtime","dir":"Articles","previous_headings":"API > Required methods","what":"rtime()","title":"Creating new `MsBackend` classes","text":"Extract retention time spectrum. method expected return numeric length equal number spectra represented backend.","code":"setMethod(\"rtime\", \"MsBackendTest\", function(object) {     spectraData(object, \"rtime\")[, 1L] }) rtime(be) ## [1] 1.2 1.3 1.4"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"scanindex","dir":"Articles","previous_headings":"API > Required methods","what":"scanIndex()","title":"Creating new `MsBackend` classes","text":"Extract scan index core spectra variable. scan index represents relative index spectrum within respective raw data file can different acquisitionNum (index spectrum recorded MS instrument). method expected return integer length equal number spectra represented backend.","code":"setMethod(\"scanIndex\", \"MsBackendTest\", function(object) {     spectraData(object, \"scanIndex\")[, 1L] }) scanIndex(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"smoothed","dir":"Articles","previous_headings":"API > Required methods","what":"smoothed()","title":"Creating new `MsBackend` classes","text":"Extract smoothed core spectra variable indicates whether spectrum smoothed. variable supported backward compatibility seldomly used. method expected return logical length equal number spectra represented backend.","code":"setMethod(\"smoothed\", \"MsBackendTest\", function(object) {     spectraData(object, \"smoothed\")[, 1L] }) smoothed(be) ## [1] NA NA NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"spectranames","dir":"Articles","previous_headings":"API > Required methods","what":"spectraNames()","title":"Creating new `MsBackend` classes","text":"spectraNames() can used extract (optional) names (IDs) individual spectra backend, NULL set. test backend can use rownames @spectraVars slot store spectra names. methods need implemented valid read-MsBackend class running test object described section Testing validity backend produce errors. backends support also data replacement also methods listed next section need implemented.","code":"setMethod(\"spectraNames\", \"MsBackendTest\", function(object) {     rownames(object@spectraVars) }) spectraNames(be) ## [1] \"1\" \"2\" \"3\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"tic","dir":"Articles","previous_headings":"API > Required methods","what":"tic()","title":"Creating new `MsBackend` classes","text":"tic() method return total ion count (.e. sum intensities) spectrum. information usually also provided raw MS data files, can also calculated fly data. parameter initial (default TRUE) allows define whether provided original tic returned (initial = TRUE) whether tic calculated actual data (initial = FALSE). original tic values usually provided spectra variable \"totIonCurrent\". Thus, initial = TRUE, implementation return value spectra variable avaialble NA . can now either return original (initial) TIC (available). calculate TIC based actual intensity values.","code":"setMethod(\"tic\", \"MsBackendTest\", function(object, initial = TRUE) {     if (initial) {         if (any(spectraVariables(object) == \"totIonCurrent\"))             spectraData(object, \"totIonCurrent\")[, 1L]         else rep(NA_real_, length(object))     } else vapply(intensity(object), sum, numeric(1), na.rm = TRUE) }) tic(be) ## [1] NA NA NA tic(be, initial = FALSE) ## [1] 2874.6  180.1  147.5"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"data-replacement-methods","dir":"Articles","previous_headings":"API","what":"Data replacement methods","title":"Creating new `MsBackend` classes","text":"stated general description, MsBackend implementations can also purely read-resources allowing just access data, replace data. Thus, strictly required implement methods, fully functional backend suggested (much possible). backend purely read-MS data resource might even extend MsBackendCached backend defined Spectra package provides mechanism cache (spectra variable) data data.frame within object. MsBackendMassbankSql implemented MsBackendMassbank package extends example backend thus allows modifying spectra variables without changing original data MassBank SQL database.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"spectradata-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"spectraData<-","title":"Creating new `MsBackend` classes","text":"spectraData<- method allow replace data within backend. method take DataFrame full data input value expected replace full data within backend, .e. spectra variables well peak data. Also, importantly, number spectra calling spectraData<- method object . implementation can make use optional parameter data added backendInitialize() method allows fill MsBackendTest object full data. test new method extract full spectra data, add additional column (spectra variable) replace data .","code":"setReplaceMethod(\"spectraData\", \"MsBackendTest\", function(object, value) {     if (!inherits(value, \"DataFrame\"))         stop(\"'value' is expected to be a 'DataFrame'\")     if (length(object) && length(object) != nrow(value))         stop(\"'value' has to be a 'DataFrame' with \", length(object), \" rows\")     object <- backendInitialize(MsBackendTest(), data = value)     object }) d <- spectraData(be) d$new_col <- c(\"a\", \"b\", \"c\")  spectraData(be) <- d be$new_col ## [1] \"a\" \"b\" \"c\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"intensity-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"intensity<-","title":"Creating new `MsBackend` classes","text":"intensity<- method allow replace intensity values spectra backend. method expected replace values intensities, must change number intensities (hence peaks) spectrum (done peaksData<- method allows replace intensity m/z values time). value method ideally NumericList ensure intensity values indeed numeric. addition method implement also simple helper function checks correct length value. data replacement method needs check function thus reduces code duplication. now use method replace intensities backend modified intensities.","code":".match_length <- function(x, y) {     if (length(x) != length(y))         stop(\"Length of 'value' has to match the length of 'object'\") }  setReplaceMethod(\"intensity\", \"MsBackendTest\", function(object, value) {     .match_length(object, value)     if (!(is.list(value) || inherits(value, \"NumericList\")))         stop(\"'value' has to be a list or NumericList\")     if (!all(lengths(value) == lengths(mz(object))))         stop(\"lengths of 'value' has to match the number of peaks per spectrum\")     if (!inherits(value, \"NumericList\"))         value <- NumericList(value, compress = FALSE)     object@intensity <- value     object }) intensity(be) ## NumericList of length 3 ## [[1]] 123.3 153.6 2354.3 243.4 ## [[2]] 100 80.1 ## [[3]] 12.3 35.2 100 intensity(be) <- intensity(be) - 10 intensity(be) ## NumericList of length 3 ## [[1]] 113.3 143.6 2344.3 233.4 ## [[2]] 90 70.1 ## [[3]] 2.3 25.2 90"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"mz-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"mz<-","title":"Creating new `MsBackend` classes","text":"mz<- method allow replace m/z values spectra backend. implementation can intensity<- method. m/z values within spectrum need increasingly ordered. thus also check case provided m/z values. take advantage efficient .unsorted() implementation NumericList already available, faster e.g. calling vapply(mz(), .unsorted, logical(1)).","code":"setReplaceMethod(\"mz\", \"MsBackendTest\", function(object, value) {     .match_length(object, value)     if (!(is.list(value) || inherits(value, \"NumericList\")))         stop(\"'value' has to be a list or NumericList\")     if (!all(lengths(value) == lengths(mz(object))))         stop(\"lengths of 'value' has to match the number of peaks per spectrum\")     if (!inherits(value, \"NumericList\"))         value <- NumericList(value, compress = FALSE)     if (any(is.unsorted(value)))         stop(\"m/z values need to be increasingly sorted within each spectrum\")     object@mz <- value     object })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"peaksdata-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"peaksData<-","title":"Creating new `MsBackend` classes","text":"peaksData<- allow replace peaks data (m/z intensity values) spectra backend. contrast mz<- intensity<- methods method also support changing number peaks per spectrum (e.g. due filtering). Parameter value list matrix objects columns \"mz\" \"intensity\". length list match number spectra backend. implementation backend class need loop list extract m/z intensity values assign @mz @intensity slots. Using peaksData<- method can now also example remove peaks.","code":"setReplaceMethod(\"peaksData\", \"MsBackendTest\", function(object, value) {     if (!(is.list(value) || inherits(value, \"SimpleList\")))         stop(\"'value' has to be a list-like object\")     .match_length(object, value)     object@mz <- NumericList(lapply(value, \"[\", , \"mz\"), compress = FALSE)     object@intensity <- NumericList(lapply(value, \"[\", , \"intensity\"),                                     compress = FALSE)     validObject(object)     object }) pd <- peaksData(be) ## Remove the first peak from the first spectrum pd[[1L]] <- pd[[1L]][-1L, ]  lengths(be) ## [1] 4 2 3 peaksData(be) <- pd lengths(be) ## [1] 3 2 3"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"section-2","dir":"Articles","previous_headings":"API > Data replacement methods","what":"$<-","title":"Creating new `MsBackend` classes","text":"$<- method allow replace values spectra variables also add additional spectra variables backend. replacement methods, length() value match number spectra represented backend. can now replace example existing spectra variables: even add new spectra variables. Replacement methods core spectra variables can implemented similarly.","code":"setReplaceMethod(\"$\", \"MsBackendTest\", function(x, name, value) {     .match_length(x, value)     if (name == \"mz\") {         mz(x) <- value     } else if (name == \"intensity\") {        intensity(x) <- value     } else {         x@spectraVars[[name]] <- value     }     .sv_valid_data_type(x@spectraVars, name)     x }) msLevel(be) ## [1] 1 2 2 be$msLevel <- c(2L, 1L, 2L) msLevel(be) ## [1] 2 1 2 be$new_var <- c(\"a\", \"b\", \"c\") be$new_var ## [1] \"a\" \"b\" \"c\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"selectspectravariables","dir":"Articles","previous_headings":"API > Data replacement methods","what":"selectSpectraVariables()","title":"Creating new `MsBackend` classes","text":"selectSpectraVariables() function allow reduce information within backend (parameter object) selected spectra variables (parameter spectraVariables). equivalent subset columns/variables. core spectra variables, specified parameter spectraVariables, values expected removed (since core spectra variables expected available even defined within backend). implementation backend remove columns @spectraVars data frame defined spectraVariables parameter. Special care given \"mz\" \"intensity\" spectra variables: selected, @mz @intensity slots initialized empty NumericList (length matching number spectra). Note also backends might throw error spectra variable required backend removed (\"dataStorage\" MsBackendMzR backend, required backend allow retrieval m/z intensity values). can now use selectSpectraVariables() remove example spectra variable \"new_var\" added . spectra variable \"new_var\" now longer available. Note however still core spectra variables listed, even selected spectraVariables parameter. variables (\"dataOrigin\") still listed spectraVariables(be2), actual values removed: \"mz\" \"intensitity\" selected, m/z intensity values get removed.","code":"setMethod(     \"selectSpectraVariables\", \"MsBackendTest\",     function(object, spectraVariables = spectraVariables(object)) {         keep <- colnames(object@spectraVars) %in% spectraVariables         object@spectraVars <- object@spectraVars[, keep, drop = FALSE]         if (!any(spectraVariables == \"mz\"))             object@mz <- NumericList(vector(\"list\", length(object)),                                      compress = FALSE)         if (!any(spectraVariables == \"intensity\"))             object@intensity <- NumericList(vector(\"list\", length(object)),                                             compress = FALSE)         validObject(object)         object     }) be2 <- be be2 <- selectSpectraVariables(be2, c(\"msLevel\", \"rtime\", \"mz\",                                      \"intensity\", \"dataStorage\")) spectraVariables(be2) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"mz\"                      \"intensity\"               ##  [7] \"dataStorage\"             \"dataOrigin\"              ##  [9] \"centroided\"              \"smoothed\"                ## [11] \"polarity\"                \"precScanNum\"             ## [13] \"precursorMz\"             \"precursorIntensity\"      ## [15] \"precursorCharge\"         \"collisionEnergy\"         ## [17] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [19] \"isolationWindowUpperMz\" dataOrigin(be) ## [1] \"<user provided>\" \"<user provided>\" \"<user provided>\" dataOrigin(be2) ## [1] NA NA NA be2 <- selectSpectraVariables(be2, c(\"msLevel\", \"rtime\", \"dataStorage\")) mz(be2) ## NumericList of length 3 ## [[1]] numeric(0) ## [[2]] numeric(0) ## [[3]] numeric(0) intensity(be2) ## NumericList of length 3 ## [[1]] numeric(0) ## [[2]] numeric(0) ## [[3]] numeric(0)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"centroided-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"centroided<-","title":"Creating new `MsBackend` classes","text":"Replace value centroided core spectra variable. provided data type must logical. re-use function .sv_valid_data_type defined backendInitialize() check correct data type core spectra variables. Alternatively, also simply re-use $<- replacement method . make whole code base backend cleaner replacing adding spectra variables handled single central function.","code":"setReplaceMethod(\"centroided\", \"MsBackendTest\", function(object, value) {     object@spectraVars[[\"centroided\"]] <- value     .sv_valid_data_type(object@spectraVars, \"centroided\")     object }) setReplaceMethod(\"centroided\", \"MsBackendTest\", function(object, value) {     object$centroided <- value     object }) centroided(be) <- c(TRUE, FALSE, TRUE) centroided(be) ## [1]  TRUE FALSE  TRUE"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"collisionenergy-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"collisionEnergy<-","title":"Creating new `MsBackend` classes","text":"Replace values collision energy. Parameter value type numeric.","code":"setReplaceMethod(\"collisionEnergy\", \"MsBackendTest\", function(object, value) {     object$collisionEnergy <- value     object }) collisionEnergy(be) <- c(NA_real_, 20.0, 20.0) collisionEnergy(be) ## [1] NA 20 20"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"dataorigin-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"dataOrigin<-","title":"Creating new `MsBackend` classes","text":"Replace values data origin spectra variable. Parameter value type character.","code":"setReplaceMethod(\"dataOrigin\", \"MsBackendTest\", function(object, value) {     object$dataOrigin <- value     object }) dataOrigin(be) ## [1] \"<user provided>\" \"<user provided>\" \"<user provided>\" dataOrigin(be) <- c(\"unknown\", \"file a\", \"file b\") dataOrigin(be) ## [1] \"unknown\" \"file a\"  \"file b\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"datastorage-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"dataStorage<-","title":"Creating new `MsBackend` classes","text":"Replace values data storage spectra variable. Parameter value type character. Since backend really make use spectra variable, can accept character value. backends, example need load data --fly data files, spectra variable used store name data files hence need perform additional checks within replacement function.","code":"setReplaceMethod(\"dataStorage\", \"MsBackendTest\", function(object, value) {     object$dataStorage <- value     object }) dataStorage(be) ## [1] \"<memory>\" \"<memory>\" \"<memory>\" dataStorage(be) <- c(\"\", \"\", \"\") dataStorage(be) ## [1] \"\" \"\" \"\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowlowermz-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"isolationWindowLowerMz<-","title":"Creating new `MsBackend` classes","text":"Replace values isolation window lower m/z spectra variable. Parameter value type numeric (NA_real_ missing values supported, e.g. MS1 spectra).","code":"setReplaceMethod(     \"isolationWindowLowerMz\", \"MsBackendTest\", function(object, value) {         object$isolationWindowLowerMz <- value         object     }) isolationWindowLowerMz(be) <- c(NA_real_, 245.3, NA_real_) isolationWindowLowerMz(be) ## [1]    NA 245.3    NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowtargetmz-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"isolationWindowTargetMz<-","title":"Creating new `MsBackend` classes","text":"Replace values isolation window target m/z spectra variable. Parameter value type numeric (NA_real_ missing values supported, e.g. MS1 spectra).","code":"setReplaceMethod(     \"isolationWindowTargetMz\", \"MsBackendTest\", function(object, value) {         object$isolationWindowTargetMz <- value         object     }) isolationWindowTargetMz(be) <- c(NA_real_, 245.4, NA_real_) isolationWindowTargetMz(be) ## [1]    NA 245.4    NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isolationwindowuppermz-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"isolationWindowUpperMz<-","title":"Creating new `MsBackend` classes","text":"Replace values isolation window upper m/z spectra variable. Parameter value type numeric (NA_real_ missing values supported, e.g. MS1 spectra).","code":"setReplaceMethod(     \"isolationWindowUpperMz\", \"MsBackendTest\", function(object, value) {         object$isolationWindowUpperMz <- value         object     }) isolationWindowUpperMz(be) <- c(NA_real_, 245.5, NA_real_) isolationWindowUpperMz(be) ## [1]    NA 245.5    NA"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"mslevel-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"msLevel<-","title":"Creating new `MsBackend` classes","text":"Replace MS level spectra backend. Parameter value type integer. Missing values (NA_integer_) supported.","code":"setReplaceMethod(\"msLevel\", \"MsBackendTest\", function(object, value) {     object$msLevel <- value     object }) msLevel(be) ## [1] 2 1 2 msLevel(be) <- c(1L, 1L, 2L) msLevel(be) ## [1] 1 1 2"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"polarity-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"polarity<-","title":"Creating new `MsBackend` classes","text":"Replace values polarity spectra variables. Parameter value type integer ideally also use standard encoding 0L 1L negative positive polarity (NA_integer missing). Thus, implementation also make sure input parameter contains expected values (although strictly required).","code":"setReplaceMethod(\"polarity\", \"MsBackendTest\", function(object, value) {     if (!all(value %in% c(0, 1, NA)))         stop(\"'polarity' should be encoded as 0L (negative), 1L (positive) \",              \"with missing values being NA_integer_\")     object$polarity <- value     object }) polarity(be) <- c(0L, 0L, 0L) polarity(be) ## [1] 0 0 0"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"rtime-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"rtime<-","title":"Creating new `MsBackend` classes","text":"Replace retention times spectra represented backend. Parameter value must type numeric. Also, although strict requirement, retention times ideally ordered increasingly per sample unit seconds.","code":"setReplaceMethod(\"rtime\", \"MsBackendTest\", function(object, value) {     object$rtime <- value     object }) rtime(be) ## [1] 1.2 1.3 1.4 rtime(be) <- rtime(be) + 2 rtime(be) ## [1] 3.2 3.3 3.4"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"smoothed-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"smoothed<-","title":"Creating new `MsBackend` classes","text":"Replace spectra variable smoothed indicates whether data smoothing operation performed spectra. Parameter value must type logical.","code":"setReplaceMethod(\"smoothed\", \"MsBackendTest\", function(object, value) {     object$smoothed <- value     object }) smoothed(be) <- rep(TRUE, 3) smoothed(be) ## [1] TRUE TRUE TRUE"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"spectranames-","dir":"Articles","previous_headings":"API > Data replacement methods","what":"spectraNames<-","title":"Creating new `MsBackend` classes","text":"Replace names individual spectras within backend. names, colnames rownames, spectraNames expected type character. backend implementation store spectra names rownames @spectraVars data frame.","code":"setReplaceMethod(\"spectraNames\", \"MsBackendTest\", function(object, value) {     rownames(object@spectraVars) <- value     object }) spectraNames(be) <- c(\"a\", \"b\", \"c\") spectraNames(be) ## [1] \"a\" \"b\" \"c\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"optional-methods","dir":"Articles","previous_headings":"API","what":"Optional methods","title":"Creating new `MsBackend` classes","text":"Default implementations methods available MsBackend classes, thus methods don’t implemented new backend. backends, depending data represented accessed within , different implementations might however efficient.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"backendbpparam","dir":"Articles","previous_headings":"API > Optional methods","what":"backendBpparam()","title":"Creating new `MsBackend` classes","text":"backendBpparam() method supposed evaluate whether provided (default) parallel processing setup supported backend. Backends support parallel processing return SerialParam() instead. default implementation shown .","code":"setMethod(\"backendBpparam\", signature = \"MsBackend\",           function(object, BPPARAM = bpparam()) {               ## Return SerialParam() instead to disable parallel processing               BPPARAM           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"backendparallelfactor","dir":"Articles","previous_headings":"API > Optional methods","what":"backendParallelFactor()","title":"Creating new `MsBackend` classes","text":"backendParallelFactor() allows backend suggest preferred way backend split parallel processing. See also notes parallel processing information. default implementation returns factor() (.e. factor length 0) hence suggesting splitting:","code":"setMethod(\"backendParallelFactor\", \"MsBackend\", function(object, ...) {     factor() })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"dropnaspectravariables","dir":"Articles","previous_headings":"API > Optional methods","what":"dropNaSpectraVariables()","title":"Creating new `MsBackend` classes","text":"dropNaSpectraVariables() supposed allow removing spectra variables data set (storage) contain missing values (.e. value spectra variable spectrum NA). function intended reduce memory requirements backends MsBackendMzR load values core spectra variables original data files, even values NA. Removing missing values backend can hence reduce size memory backend without data loss (methods extracting core spectra variables supposed always return NA values even data available - cases NA values supposed created --fly. default implementation shown .","code":"setMethod(\"dropNaSpectraVariables\", \"MsBackend\", function(object) {     svs <- spectraVariables(object)     svs <- svs[!(svs %in% c(\"mz\", \"intensity\"))]     spd <- spectraData(object, columns = svs)     keep <- !vapply1l(spd, function(z) all(is.na(z)))     selectSpectraVariables(object, c(svs[keep], \"mz\", \"intensity\")) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"isreadonly","dir":"Articles","previous_headings":"API > Optional methods","what":"isReadOnly()","title":"Creating new `MsBackend` classes","text":"isReadOnly() expected return logical(1) either TRUE FALSE indicating whether backend supports replacing data . default implementation shown .","code":"setMethod(\"isReadOnly\", \"MsBackend\", function(object) {     object@readonly })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"peaksvariables","dir":"Articles","previous_headings":"API > Optional methods","what":"peaksVariables()","title":"Creating new `MsBackend` classes","text":"peaksVariables() expected return character vector names peaks variables (.e. information properties individual mass peaks) available backend. default implementation MsBackend returns default c(\"mz\", \"intensity\"). method implemented backends (eventually) also provide additional peaks variables. default implementation shown .","code":"setMethod(\"peaksVariables\", \"MsBackend\", function(object) {     c(\"mz\", \"intensity\") })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"uniquemslevels","dir":"Articles","previous_headings":"API > Optional methods","what":"uniqueMsLevels()","title":"Creating new `MsBackend` classes","text":"method return unique MS level(s) spectra within backend. default implementation shown . method thus retrieves first MS levels spectra calls unique() . Database-based backends might avoid eventually heavy operation selecting unique MS levels directly using SQL call.","code":"setMethod(\"uniqueMsLevels\", \"MsBackend\", function(object, ...) {     unique(msLevel(object)) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"ioncount","dir":"Articles","previous_headings":"API > Optional methods","what":"ionCount()","title":"Creating new `MsBackend` classes","text":"ionCount() method return numeric (length equal number spectra represented backend) sum intensities within spectrum. empty spectra NA_real_ returned. method default implementation method.","code":"setMethod(\"ionCount\", \"MsBackend\", function(object) {     vapply1d(intensity(object), sum, na.rm = TRUE) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"iscentroided","dir":"Articles","previous_headings":"API > Optional methods","what":"isCentroided()","title":"Creating new `MsBackend` classes","text":"method return information spectrum whether centroided. contrast centroided() method heuristic approach used. default implementation shown .","code":"setMethod(\"isCentroided\", \"MsBackend\", function(object, ...) {     vapply1l(peaksData(object), .peaks_is_centroided) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"reset","dir":"Articles","previous_headings":"API > Optional methods","what":"reset()","title":"Creating new `MsBackend` classes","text":"special method backends may implement support, don’t necessary . method called reset,Spectra method supposed restore data original state. default implementation MsBackend shown simply returns backend -. MsBackendSql backend MsBackendSql package contrast re-initializes data using data database.","code":"setMethod(\"reset\", \"MsBackend\", function(object) {     object })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"export","dir":"Articles","previous_headings":"API > Optional methods","what":"export()","title":"Creating new `MsBackend` classes","text":"method export data MsBackend. method called export,Spectra method passes second argument function. export,MsBackend implementation thus expected take Spectra object second argument data taken exported. Implementation method optional. implementation method MsBackendMzR backend shown . See alternatively also MsBackendMgf package implementation MsBackendMgf backend.","code":"setMethod(\"export\", \"MsBackendMzR\", function(object, x, file = tempfile(),                                              format = c(\"mzML\", \"mzXML\"),                                              copy = FALSE,                                              BPPARAM = bpparam()) {     l <- length(x)     file <- sanitize_file_name(file)     if (length(file) == 1)         file <- rep_len(file, l)     if (length(file) != l)         stop(\"Parameter 'file' has to be either of length 1 or \",              length(x), \", i.e. 'length(x)'.\", call. = FALSE)     f <- factor(file, levels = unique(file))     tmp <- bpmapply(.write_ms_data_mzR, split(x, f), levels(f),                     MoreArgs = list(format = format, copy = copy),                     BPPARAM = BPPARAM) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"split","dir":"Articles","previous_headings":"API > Optional methods","what":"split()","title":"Creating new `MsBackend` classes","text":"split() method allow split MsBackend list MsBackend objects. default implementation shown .","code":"setMethod(\"split\", \"MsBackend\", function(x, f, drop = FALSE, ...) {     split.default(x, f, drop = drop, ...) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"supportssetbackend","dir":"Articles","previous_headings":"API > Optional methods","what":"supportsSetBackend()","title":"Creating new `MsBackend` classes","text":"Whether MsBackend supports setBackend() method allows change backend Spectra object one another backend. support setBackend() backend needs parameter data backendInitialize() method allows initialized DataFrame containing full spectra data. default implementation shown .","code":"setMethod(\"supportsSetBackend\", \"MsBackend\", function(object, ...) {     !isReadOnly(object) })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterdataorigin","dir":"Articles","previous_headings":"API > Optional methods","what":"filterDataOrigin()","title":"Creating new `MsBackend` classes","text":"filter* methods expected take MsBackend subset based criteria. also [ method used perform subset operation, methods might allow efficient ways subset data e.g. performing operation within database dedicated SQL call. default implementation available every filter function thus method needs implemented data storage/representation within backend allow efficient operation. filter methods expected return subset backend (.e. instance backend class , less spectra). filterDataOrigin() subset backend spectra dataOrigin spectra variable matching values provided dataOrigin parameter. default implementation MsBackend shown .","code":"setMethod(\"filterDataOrigin\", \"MsBackend\",           function(object, dataOrigin = character()) {               if (length(dataOrigin)) {                   object <- object[dataOrigin(object) %in% dataOrigin]                   if (is.unsorted(dataOrigin))                       object[order(match(dataOrigin(object), dataOrigin))]                   else object               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterdatastorage","dir":"Articles","previous_headings":"API > Optional methods","what":"filterDataStorage()","title":"Creating new `MsBackend` classes","text":"Similar filterDataOrigin(), filterDataStorage() subset backend spectra dataStorage spectra variable matching values provided dataStorage parameter.","code":"setMethod(\"filterDataStorage\", \"MsBackend\",           function(object, dataStorage = character()) {               if (length(dataStorage)) {                   object <- object[dataStorage(object) %in% dataStorage]                   if (is.unsorted(dataStorage))                       object[order(match(dataStorage(object), dataStorage))]                   else object               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filteremptyspectra","dir":"Articles","previous_headings":"API > Optional methods","what":"filterEmptySpectra()","title":"Creating new `MsBackend` classes","text":"filterEmptySpectra() remove empty spectra (.e. spectra without mass peaks) backend. method expected return subset backend. default implementation MsBackend shown .","code":"setMethod(\"filterEmptySpectra\", \"MsBackend\", function(object, ...) {     if (!length(object)) return(object)     object[as.logical(lengths(object))] })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterisolationwindow","dir":"Articles","previous_headings":"API > Optional methods","what":"filterIsolationWindow()","title":"Creating new `MsBackend` classes","text":"filterIsolationWindow() filters backend spectra provided mz value within isolationWindowLowerMz() isolationWindowUpperMz(). parameter mz defining target m/z expected numeric length 1. default implementation MsBackend shown .","code":"setMethod(\"filterIsolationWindow\", \"MsBackend\",           function(object, mz = numeric(), ...) {               if (length(mz)) {                   if (length(mz) > 1)                       stop(\"'mz' is expected to be a single m/z value\")                   keep <- which(isolationWindowLowerMz(object) <= mz &                                 isolationWindowUpperMz(object) >= mz)                   object[keep]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filtermslevel","dir":"Articles","previous_headings":"API > Optional methods","what":"filterMsLevel()","title":"Creating new `MsBackend` classes","text":"filterMsLevel() method expected reduce backend spectra provided MS level(s). Parameter msLevel integer (length). default implementation MsBackend shown .","code":"setMethod(\"filterMsLevel\", \"MsBackend\",           function(object, msLevel = integer()) {               if (length(msLevel)) {                   object[msLevel(object) %in% msLevel]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterpolarity","dir":"Articles","previous_headings":"API > Optional methods","what":"filterPolarity()","title":"Creating new `MsBackend` classes","text":"filterPolarity() method expected subset backend spectra matching provided polarity (polarities). Parameter polarity integer (length). default implementation MsBackend shown .","code":"setMethod(\"filterPolarity\", \"MsBackend\",           function(object, polarity = integer()) {               if (length(polarity))                   object[polarity(object) %in% polarity]               else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterprecursormzrange","dir":"Articles","previous_headings":"API > Optional methods","what":"filterPrecursorMzRange()","title":"Creating new `MsBackend` classes","text":"filterPrecursorMzRange() method filters backend spectra precursorMz provided m/z range (parameter mz). method previously named filterPrecursorMz(). Parameter mz expected numeric length 2 defining lower upper limit precursor m/z range. default implementation MsBackend shown .","code":"library(MsCoreUtils) ##  ## Attaching package: 'MsCoreUtils' ## The following objects are masked from 'package:Spectra': ##  ##     bin, entropy, smooth ## The following objects are masked from 'package:ProtGenerics': ##  ##     bin, smooth ## The following object is masked from 'package:stats': ##  ##     smooth setMethod(\"filterPrecursorMzRange\", \"MsBackend\",           function(object, mz = numeric()) {               if (length(mz)) {                   mz <- range(mz)                   keep <- which(between(precursorMz(object), mz))                   object[keep]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterprecursormzvalues","dir":"Articles","previous_headings":"API > Optional methods","what":"filterPrecursorMzValues()","title":"Creating new `MsBackend` classes","text":"filterPrecursorMzValues() method filters backend spectra m/z values matching provided m/z value(s). Parameters ppm tolerance (expected numeric length 1) allow define conditions relaxed matching. Parameter mz numeric (length). default implementation MsBackend shown . .values_match_mz function used function defined :","code":"setMethod(\"filterPrecursorMzValues\", \"MsBackend\",           function(object, mz = numeric(), ppm = 20, tolerance = 0) {               if (length(mz)) {                   object[.values_match_mz(precursorMz(object), mz = mz,                                           ppm = ppm, tolerance = tolerance)]               } else object           }) .values_match_mz <- function(x, mz, ppm = 20, tolerance = 0) {     o <- order(x, na.last = NA)     cmn <- common(x[o], sort(mz), tolerance = tolerance, ppm = ppm,                   duplicates = \"keep\", .check = FALSE)     sort(o[cmn]) }"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterprecursorcharge","dir":"Articles","previous_headings":"API > Optional methods","what":"filterPrecursorCharge()","title":"Creating new `MsBackend` classes","text":"filterPrecursorCharge() method filters backend spectra matching precursor charge. Parameter z defining requested precursor charge integer (length). default implementation MsBackend shown .","code":"setMethod(\"filterPrecursorCharge\", \"MsBackend\",           function(object, z = integer()) {               if (length(z)) {                   keep <- which(precursorCharge(object) %in% z)                   object[keep]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterprecursorscan","dir":"Articles","previous_headings":"API > Optional methods","what":"filterPrecursorScan()","title":"Creating new `MsBackend` classes","text":"filterPrecursorScan() method filters backend parent (e.g. MS1) children scans (e.g. MS2) acquisition number acquisitionNum. Parameter f defines backend split (default original data file) avoid selecting spectra different samples/files. default implementation MsBackend shown .","code":"setMethod(\"filterPrecursorScan\", \"MsBackend\",           function(object, acquisitionNum = integer(), f = dataOrigin(object)) {               if (length(acquisitionNum) && length(f)) {                   if (!is.factor(f))                       f <- factor(f, exclude = character())                   keep <- unsplit(lapply(split(object, f = f), function(z, an) {                       .filterSpectraHierarchy(acquisitionNum(z),                                               precScanNum(z),                                               an)                   }, an = acquisitionNum), f = f)                   object[keep]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"filterrt","dir":"Articles","previous_headings":"API > Optional methods","what":"filterRt()","title":"Creating new `MsBackend` classes","text":"filterRt() method filters backend spectra retention time provided rt range. Parameter rt expected numeric length 2 defining lower upper bound range. Parameter msLevel. (note . name parameter!) can optionally used restrict filtering selected MS levels (.e. RT filter applied spectra selected MS levels spectra different MS level returned well). default implementation MsBackend shown .","code":"setMethod(\"filterRt\", \"MsBackend\",           function(object, rt = numeric(), msLevel. = uniqueMsLevels(object)) {               if (length(rt)) {                   rt <- range(rt)                   sel_ms <- msLevel(object) %in% msLevel.                   sel_rt <- between(rtime(object), rt) & sel_ms                   object[sel_rt | !sel_ms]               } else object           })"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"implementation-notes","dir":"Articles","previous_headings":"API","what":"Implementation notes","title":"Creating new `MsBackend` classes","text":"tutorial implemented simple -memory MsBackend scratch. many real-life situation might however better extend pre-defined backend classes Spectra package avoid duplicating functionality. good starting point might MsBackendMemory backend -memory data representation, MsBackendCached backends retrieve data inherently read-resources (database connection raw data files) still need support adding spectra variables changing values spectra variables. Similarly, purpose backend import export data specific format, MsBackendMemory might extended single method (backendInitialize()) need implemented new class: new backendInitialize() call code import data new file format store within available slots MsBackendMemory object. Examples backends provided MsBackendMgf MsBackendMsp classes.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"testing-the-validity-of-the-backend","dir":"Articles","previous_headings":"","what":"Testing the validity of the backend","title":"Creating new `MsBackend` classes","text":"Spectra package provides set unit tests allow check backend compliance MsBackend. load test suite call tests. tests performed variable current workspace (case instance MsBackendTest class).","code":"library(testthat) test_suite <- system.file(\"test_backends\", \"test_MsBackend\",                           package = \"Spectra\") test_dir(test_suite, stop_on_failure = TRUE)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/MsBackend.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Creating new `MsBackend` classes","text":"","code":"sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ## [1] MsCoreUtils_1.17.0  IRanges_2.39.2      Spectra_1.15.7      ## [4] ProtGenerics_1.37.1 BiocParallel_1.39.0 S4Vectors_0.43.2    ## [7] BiocGenerics_0.51.0 BiocStyle_2.33.1    ##  ## loaded via a namespace (and not attached): ##  [1] cli_3.6.3              knitr_1.48             rlang_1.1.4            ##  [4] xfun_0.46              textshaping_0.4.0      clue_0.3-65            ##  [7] jsonlite_1.8.8         htmltools_0.5.8.1      ragg_1.3.2             ## [10] sass_0.4.9             rmarkdown_2.27         evaluate_0.24.0        ## [13] jquerylib_0.1.4        MASS_7.3-61            fastmap_1.2.0          ## [16] yaml_2.3.10            lifecycle_1.0.4        bookdown_0.40          ## [19] BiocManager_1.30.23    cluster_2.1.6          compiler_4.4.1         ## [22] codetools_0.2-20       fs_1.6.4               htmlwidgets_1.6.4      ## [25] MetaboCoreUtils_1.13.0 systemfonts_1.1.0      digest_0.6.36          ## [28] R6_2.5.1               parallel_4.4.1         bslib_0.8.0            ## [31] tools_4.4.1            pkgdown_2.1.0.9000     cachem_1.1.0           ## [34] desc_1.4.3"},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Large-scale data handling and processing with Spectra","text":"Spectra package supports handling processing also large mass spectrometry (MS) data sets. dedicated backends, load MS data requested/needed, memory demand can minimized. Examples backends MsBackendMzR MsBackendOfflineSql (defined MsBackendSql package). addition, Spectra supports chunk-wise data processing, hence parts data loaded memory processed time. document provide information large scale data can best processed Spectra package.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"memory-requirements-of-different-data-representations","dir":"Articles","previous_headings":"","what":"Memory requirements of different data representations","title":"Large-scale data handling and processing with Spectra","text":"Spectra package separates functionality process analyze MS data (implemented Spectra class) code defines MS data stored. latter, different implementations MsBackend class available, either optimized performance (MsBackendMemory MsBackendDataFrame) low memory requirement (MsBackendMzR, MsBackendOfflineSql implemented MsBackendSql package, smallest possible memory footprint enables also analysis large data sets). load MS data 4 test files Spectra using MsBackendMzR backend. resulting Spectra uses MsBackendMzR data representation. backend load general spectra data memory full MS data (.e., m/z intensity values individual mass peaks) loaded requested needed. contrast -memory backend, memory footprint backend thus lower. create Spectra keeps full data memory changing backend MsBackendMemory backend compare sizes objects. Keeping full data memory requires thus considerably memory. next disable parallel processing Spectra allow unbiased estimation memory usage.","code":"library(Spectra)  #' Define the file names from which to import the data fls <- c(     system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\"),     system.file(\"TripleTOF-SWATH\", \"PestMix1_SWATH.mzML\", package = \"msdata\"),     system.file(\"sciex\", \"20171016_POOL_POS_1_105-134.mzML\",                 package = \"msdata\"),     system.file(\"sciex\", \"20171016_POOL_POS_3_105-134.mzML\",                 package = \"msdata\"))  #' Creating a Spectra object representing the MS data sps_mzr <- Spectra(fls, source = MsBackendMzR()) sps_mzr ## MSn data (Spectra) with 18463 spectra in a MsBackendMzR backend: ##         msLevel     rtime scanIndex ##       <integer> <numeric> <integer> ## 1             1     0.231         1 ## 2             1     0.351         2 ## 3             1     0.471         3 ## 4             1     0.591         4 ## 5             1     0.711         5 ## ...         ...       ...       ... ## 18459         1   258.636       927 ## 18460         1   258.915       928 ## 18461         1   259.194       929 ## 18462         1   259.473       930 ## 18463         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## PestMix1_DDA.mzML ## PestMix1_SWATH.mzML ## 20171016_POOL_POS_1_105-134.mzML ##  ... 1 more files sps_mem <- setBackend(sps_mzr, MsBackendMemory())  print(object.size(sps_mzr), units = \"MB\") ## 5.2 Mb print(object.size(sps_mem), units = \"MB\") ## 140.1 Mb #' Disable parallel processing globally register(SerialParam())"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"chunk-wise-and-parallel-processing","dir":"Articles","previous_headings":"","what":"Chunk-wise and parallel processing","title":"Large-scale data handling and processing with Spectra","text":"Operations peaks data time memory demanding tasks. generally apply function , modify m/z /intensity values. Among functions example functions filter, remove combine mass peaks (filterMzRange(), filterIntensity() combinePeaks()) functions perform calculations peaks data (bin() pickPeaks()) also functions provide information , summarize spectra (lengths() ionCount()). functions, peaks data needs present memory -disk backends, MsBackendMzR, need thus first import data data storage. However, loading full peaks data memory might possible large data sets. Loading processing data smaller chunks however reduce memory demand hence allow process also data sets. MsBackendMzR MsBackendHdf5Peaks backends data automatically split processed data storage files. backends chunk-wise processing can enabled defining processingChunkSize Spectra, .e. number spectra peaks data loaded processed iteration. processingChunkFactor() function can used evaluate data split. use function evaluate chunk-wise processing performed two Spectra objects. Spectra -memory backend empty factor() returned, thus, chunk-wise processing performed. next evaluate whether Spectra MsBackendMzR -disk backend use chunk-wise processing. data thus split processed original file, data imported. next specifically define chunk-size Spectra processingChunkSize() function. setting chunk size, also Spectra -memory backend use chunk-wise processing. repeat Spectra object: Spectra MsBackendMzR backend now split data equally sized arbitrary chunks longer original data file. Setting processingChunkSize thus overrides splitting suggested backend. set processingChunkSize, operation involving peaks data default performed chunk-wise manner. Thus, calling ionCount() Spectra now split data chunks 3000 spectra sum intensities (per spectrum) chunk chunk. chunk-wise processing reduces memory demand operations, splitting merging data results can negatively impact performance. Thus, small data sets Spectra -memory backends generally benefit type processing. computationally intense operation hand, chunk-wise processing advantage, chunks can () processed parallel (depending parallel processing setup). Note chunk-wise processing affects functions involve actual peak data. Subset operations reduce number spectra (filterRt() [) bypass mechanism applied immediately data. evaluation chunk-wise processing see also issue Spectra github repository.","code":"processingChunkFactor(sps_mem) ## factor() ## Levels: processingChunkFactor(sps_mzr) |> table() ##  ##      /__w/_temp/Library/msdata/TripleTOF-SWATH/PestMix1_DDA.mzML  ##                                                             7602  ##    /__w/_temp/Library/msdata/TripleTOF-SWATH/PestMix1_SWATH.mzML  ##                                                             8999  ## /__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML  ##                                                              931  ## /__w/_temp/Library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML  ##                                                              931 processingChunkSize(sps_mem) <- 3000 processingChunkFactor(sps_mem) |> table() ##  ##    1    2    3    4    5    6    7  ## 3000 3000 3000 3000 3000 3000  463 processingChunkSize(sps_mzr) <- 3000 processingChunkFactor(sps_mzr) |> table() ##  ##    1    2    3    4    5    6    7  ## 3000 3000 3000 3000 3000 3000  463 tic <- ionCount(sps_mem)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"notes-and-suggestions-for-parallel-or-chunk-wise-processing","dir":"Articles","previous_headings":"","what":"Notes and suggestions for parallel or chunk-wise processing","title":"Large-scale data handling and processing with Spectra","text":"Estimating memory usage R tends difficult, MS data sets 100 samples whenever processing tends take longer expected suggested enable chunk-wise processing (already used, MsBackendMzR). Spectra uses BiocParallel package parallel processing. parallel processing setup can configured globally registering preferred setup using register() function (e.g. register(SnowParam(4)) use socket-based parallel processing Windows using 4 different R processes). Parallel processing can disabled setting register(SerialParam()). Chunk-wise processing default run parallel, depending configured parallel processing setup. Parallel processing (also chunk-wise processing) computational overhead, data needs split merged. Thus, operations data sets avoiding mechanism can efficient (e.g. -memory backends small data sets).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"spectra-functions-supporting-or-using-parallel-processing","dir":"Articles","previous_headings":"","what":"Spectra functions supporting or using parallel processing","title":"Large-scale data handling and processing with Spectra","text":"functions allow configure parallel processing using dedicated parameter allows define split data parallel (chunk-wise) processing. functions : applyProcessing(): parameter f (defaults processingChunkFactor(object)) can used define split process data parallel. combineSpectra(): parameter p (defaults x$dataStorage) defines data split processed parallel. estimatePrecursorIntensity(): parameter f (defaults dataOrigin(x)) defines splitting processing. represent original data files spectra data derives . intensity(): parameter f (defaults processingChunkFactor(object)) defines data split parallel processing. mz(): parameter f (defaults processingChunkFactor(object)) defines data split parallel processing. peaksData(): parameter f (defaults processingChunkFactor(object)) defines data split parallel processing. setBackend(): parameter f (defaults processingChunkFactor(object)) defines data split parallel processing. Functions perform chunk-wise (parallel) processing natively, .e., based processingChunkFactor: containsMz(). containsNeutralLoss(). ionCount(). isCentroided(). isEmpty().","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra-large-scale.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Large-scale data handling and processing with Spectra","text":"","code":"sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ## [1] Spectra_1.15.7      ProtGenerics_1.37.1 BiocParallel_1.39.0 ## [4] S4Vectors_0.43.2    BiocGenerics_0.51.0 BiocStyle_2.33.1    ##  ## loaded via a namespace (and not attached): ##  [1] jsonlite_1.8.8         compiler_4.4.1         BiocManager_1.30.23    ##  [4] Rcpp_1.0.13            Biobase_2.65.0         parallel_4.4.1         ##  [7] cluster_2.1.6          jquerylib_0.1.4        systemfonts_1.1.0      ## [10] IRanges_2.39.2         textshaping_0.4.0      yaml_2.3.10            ## [13] fastmap_1.2.0          R6_2.5.1               knitr_1.48             ## [16] htmlwidgets_1.6.4      MASS_7.3-61            bookdown_0.40          ## [19] desc_1.4.3             bslib_0.8.0            rlang_1.1.4            ## [22] cachem_1.1.0           xfun_0.46              fs_1.6.4               ## [25] MsCoreUtils_1.17.0     sass_0.4.9             cli_3.6.3              ## [28] pkgdown_2.1.0.9000     ncdf4_1.22             digest_0.6.36          ## [31] mzR_2.37.3             MetaboCoreUtils_1.13.0 lifecycle_1.0.4        ## [34] clue_0.3-65            evaluate_0.24.0        codetools_0.2-20       ## [37] ragg_1.3.2             rmarkdown_2.27         tools_4.4.1            ## [40] htmltools_0.5.8.1"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Description and usage of Spectra objects","text":"Spectra package provides scalable flexible infrastructure represent, retrieve handle mass spectrometry (MS) data. Spectra object provides user single standardized interface access manipulate MS data supporting, concept exchangeable backends, large variety different ways store retrieve mass spectrometry data. backends range mzML/mzXML/CDF files, simple flat files, database systems. vignette provides general examples descriptions Spectra package. Additional information tutorials available, SpectraTutorials, MetaboAnnotationTutorials, also (Rainer et al. 2022). information handle (parallel) process large-scale data sets see Large-scale data handling processing Spectra vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Description and usage of Spectra objects","text":"package can installed BiocManager package. install BiocManager use install.packages(\"BiocManager\") , , BiocManager::install(\"Spectra\") install Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"general-usage","dir":"Articles","previous_headings":"","what":"General usage","title":"Description and usage of Spectra objects","text":"Mass spectrometry data Spectra objects can thought list individual spectra, spectrum set variables associated . Besides core spectra variables (MS level retention time) arbitrary number optional variables can assigned spectrum. core spectra variables accessor method guaranteed value returned (NA information available). core variables data type (alphabetically ordered): acquisitionNum integer(1): index acquisition spectrum MS run. centroided logical(1): whether spectrum profile centroid mode. collisionEnergy numeric(1): collision energy used create MSn spectrum. dataOrigin character(1): origin spectrum’s data, e.g. mzML file read. dataStorage character(1): (current) storage location spectrum data. value depends backend used handle provide data. -memory backend like MsBackendDataFrame \"<memory>\", -disk backend MsBackendHdf5Peaks name HDF5 file spectrum’s peak data stored. intensity numeric: intensity values spectrum’s peaks. isolationWindowLowerMz numeric(1): lower m/z isolation window (MSn) spectrum measured. isolationWindowTargetMz numeric(1): target m/z isolation window (MSn) spectrum measured. isolationWindowUpperMz numeric(1): upper m/z isolation window (MSn) spectrum measured. msLevel integer(1): MS level spectrum. mz numeric: m/z values spectrum’s peaks. polarity integer(1): polarity spectrum (0 1 representing negative positive polarity, respectively). precScanNum integer(1): scan (acquisition) number precursor MSn spectrum. precursorCharge integer(1): charge precursor MSn spectrum. precursorIntensity numeric(1): intensity precursor MSn spectrum. precursorMz numeric(1): m/z precursor MSn spectrum. rtime numeric(1): retention time spectrum. scanIndex integer(1): index spectrum within (raw) file. smoothed logical(1): whether spectrum smoothed. details individual variables getter/setter function see help Spectra (?Spectra). Also note variables suggested, required characterize spectrum. Also, make sense MSn, MS1 spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"creating-spectra-objects","dir":"Articles","previous_headings":"General usage","what":"Creating Spectra objects","title":"Description and usage of Spectra objects","text":"simplest way create Spectra object defining DataFrame corresponding spectra data (using corresponding spectra variable names column names) passing Spectra constructor function. create object set 3 spectra providing MS level, olarity also additional annotations ID HMDB (human metabolome database) name. m/z intensity values spectrum provided list numeric values. Alternatively, possible import spectra data mass spectrometry raw files mzML/mzXML CDF format. create Spectra object two mzML files define use MsBackendMzR backend store data (note requires mzR package installed). backend, specifically designed raw MS data, keeps subset spectra variables memory reading m/z intensity values original data files demand. See section Backends details backends properties. Spectra object sps_sciex allows now access spectra data 1862 MS1 spectra uses MsBackendMzR backend (Spectra object sps created previous code block uses default MsBackendMemory).","code":"library(Spectra)  spd <- DataFrame(     msLevel = c(2L, 2L, 2L),     polarity = c(1L, 1L, 1L),     id = c(\"HMDB0000001\", \"HMDB0000001\", \"HMDB0001847\"),     name = c(\"1-Methylhistidine\", \"1-Methylhistidine\", \"Caffeine\"))  ## Assign m/z and intensity values. spd$mz <- list(     c(109.2, 124.2, 124.5, 170.16, 170.52),     c(83.1, 96.12, 97.14, 109.14, 124.08, 125.1, 170.16),     c(56.0494, 69.0447, 83.0603, 109.0395, 110.0712,       111.0551, 123.0429, 138.0662, 195.0876)) spd$intensity <- list(     c(3.407, 47.494, 3.094, 100.0, 13.240),     c(6.685, 4.381, 3.022, 16.708, 100.0, 4.565, 40.643),     c(0.459, 2.585, 2.446, 0.508, 8.968, 0.524, 0.974, 100.0, 40.994))  sps <- Spectra(spd) sps ## MSn data (Spectra) with 3 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ##  ... 18 more variables/columns. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE) sps_sciex <- Spectra(fls, source = MsBackendMzR()) sps_sciex ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"accessing-spectrum-data","dir":"Articles","previous_headings":"General usage","what":"Accessing spectrum data","title":"Description and usage of Spectra objects","text":"detailed Spectra objects can contain arbitrary number properties spectrum (called spectra variables). available variables can listed spectraVariables() method: two Spectra contain different set variables: besides \"msLevel\", \"polarity\", \"id\" \"name\", specified Spectra object sps, contains variables \"rtime\", \"acquisitionNum\" \"scanIndex\". part core variables defining spectrum accessor methods exist. use msLevel() rtime() access MS levels retention times spectra sps. specify retention times spectra sps thus NA returned . Spectra object sps_sciex contains many variables, extracted mzML files. extract retention times first spectra object. Note addition accessor functions also possible use $ extract specific spectra variable. extract name compounds sps can use sps$name, , extract MS levels sps$msLevel. also replace specific spectra variables using either dedicated method $. specify spectra sps represent centroided data. $ operator can also used add arbitrary new spectra variables Spectra object. add SPLASH key spectra. new spectra variable now listed additional variable result spectraVariables() function can directly access content sps$splash. spectrum can different number mass peaks, consisting mass--charge (m/z) associated intensity value. can extracted mz() intensity() functions, return list numeric values. Peak data can also extracted peaksData() function returns list numerical matrices peak variables m/z intensity values. peak variables available Spectra object can determined peaksVariables() function. can passed peaksData() function parameter columns extract peak variables interest. default peaksData() extracts m/z intensity values. Note get result using () method coerce Spectra object list SimpleList: spectraData() function returns DataFrame full data spectrum (except m/z intensity values), selected spectra variables (can specified columns parameter). extract spectra data variables \"msLevel\", \"id\" \"name\". Spectra one-dimensional objects storing spectra, even different files samples, single list. Specific variables thus used define originating file extracted sample measured. data origin spectrum can extracted dataOrigin() function. sps, Spectra created DataFrame, NA specify data origin: dataOrigin sps_sciex, Spectra initialized data mzML files, contrast, returns originating file names: current data storage location spectrum can retrieved dataStorage variable, return arbitrary string Spectra use -memory backend file data stored -disk backends: Certain backends (MsBackendMemory MsBackendDataFrame) support also additional peaks variables. present, must already present backend gets initialized. future dedicated function allowing add peaks variables available. thus first extract full data (including peaks variables) sps spectra object add column \"peak_anno\" peak annotations individual peak. Importantly, peak variables, value needs assigned individual peak, even NA (lengths() new peak variable must match lengths() mz intensity, .e. number peaks per spectrum). parameter peaksVariables() (currently available backendInitialize() method MsBackendMemory MsBackendDataFrame) allows define columns input data contain peaks variables (case \"mz\", \"intensity\" additional \"peak_anno\" column). Full peak data can extracted peaksData() function second parameter columns allowing define peak variables return. extract peak data second spectrum. can also use peaksData() function extract values individual peak variables. Peak variables can also extracted using $ method: Similar spectra variables also possible replace values existing peaks variables using $<- function.","code":"spectraVariables(sps) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"dataStorage\"             \"dataOrigin\"              ##  [7] \"centroided\"              \"smoothed\"                ##  [9] \"polarity\"                \"precScanNum\"             ## [11] \"precursorMz\"             \"precursorIntensity\"      ## [13] \"precursorCharge\"         \"collisionEnergy\"         ## [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [17] \"isolationWindowUpperMz\"  \"id\"                      ## [19] \"name\" spectraVariables(sps_sciex) ##  [1] \"msLevel\"                  \"rtime\"                    ##  [3] \"acquisitionNum\"           \"scanIndex\"                ##  [5] \"dataStorage\"              \"dataOrigin\"               ##  [7] \"centroided\"               \"smoothed\"                 ##  [9] \"polarity\"                 \"precScanNum\"              ## [11] \"precursorMz\"              \"precursorIntensity\"       ## [13] \"precursorCharge\"          \"collisionEnergy\"          ## [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  ## [17] \"isolationWindowUpperMz\"   \"peaksCount\"               ## [19] \"totIonCurrent\"            \"basePeakMZ\"               ## [21] \"basePeakIntensity\"        \"ionisationEnergy\"         ## [23] \"lowMZ\"                    \"highMZ\"                   ## [25] \"mergedScan\"               \"mergedResultScanNum\"      ## [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   ## [29] \"injectionTime\"            \"filterString\"             ## [31] \"spectrumId\"               \"ionMobilityDriftTime\"     ## [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\" msLevel(sps) ## [1] 2 2 2 rtime(sps) ## [1] NA NA NA head(rtime(sps_sciex)) ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 sps$name ## [1] \"1-Methylhistidine\" \"1-Methylhistidine\" \"Caffeine\" sps$msLevel ## [1] 2 2 2 sps$centroided <- TRUE  centroided(sps) ## [1] TRUE TRUE TRUE sps$splash <- c(     \"splash10-00di-0900000000-037d24a7d65676b7e356\",     \"splash10-00di-0900000000-03e99316bd6c098f5d11\",     \"splash10-000i-0900000000-9af60e39c843cb715435\") mz(sps) ## NumericList of length 3 ## [[1]] 109.2 124.2 124.5 170.16 170.52 ## [[2]] 83.1 96.12 97.14 109.14 124.08 125.1 170.16 ## [[3]] 56.0494 69.0447 83.0603 109.0395 110.0712 111.0551 123.0429 138.0662 195.0876 intensity(sps) ## NumericList of length 3 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 peaksVariables(sps) ## [1] \"mz\"        \"intensity\" pks <- peaksData(sps) pks[[1]] ##          mz intensity ## [1,] 109.20     3.407 ## [2,] 124.20    47.494 ## [3,] 124.50     3.094 ## [4,] 170.16   100.000 ## [5,] 170.52    13.240 as(sps, \"SimpleList\") ## List of length 3 spectraData(sps, columns = c(\"msLevel\", \"id\", \"name\")) ## DataFrame with 3 rows and 3 columns ##     msLevel          id              name ##   <integer> <character>       <character> ## 1         2 HMDB0000001 1-Methylhistidine ## 2         2 HMDB0000001 1-Methylhistidine ## 3         2 HMDB0001847          Caffeine dataOrigin(sps) ## [1] NA NA NA head(basename(dataOrigin(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" dataStorage(sps) ## [1] \"<memory>\" \"<memory>\" \"<memory>\" head(basename(dataStorage(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## Extract the full data from a spectrum spd <- spectraData(sps, columns = union(spectraVariables(sps),                                         peaksVariables(sps))) ## Add a new column with a *annotation* for each peak spd$peak_anno <- list(c(\"a\", NA_character_, \"b\", \"c\", \"d\"),                       c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"),                       c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\")) ## lengths have to match: lengths(spd$peak_anno) ## [1] 5 7 9 lengths(spd$mz) ## [1] 5 7 9 sps2 <- Spectra(spd, backend = MsBackendMemory(),                 peaksVariables = c(\"mz\", \"intensity\", \"peak_anno\")) peaksVariables(sps2) ## [1] \"mz\"        \"intensity\" \"peak_anno\" peaksData(sps2, columns = peaksVariables(sps2))[[2L]] ##       mz intensity peak_anno ## 1  83.10     6.685         a ## 2  96.12     4.381         b ## 3  97.14     3.022         c ## 4 109.14    16.708         d ## 5 124.08   100.000         e ## 6 125.10     4.565         f ## 7 170.16    40.643         g ## Peak annotations for the first spectrum peaksData(sps2, \"peak_anno\")[[1L]] ##   peak_anno ## 1         a ## 2      <NA> ## 3         b ## 4         c ## 5         d ## Peak annotations for the second spectrum peaksData(sps2, \"peak_anno\")[[2L]] ##   peak_anno ## 1         a ## 2         b ## 3         c ## 4         d ## 5         e ## 6         f ## 7         g sps2$peak_anno ## [[1]] ## [1] \"a\" NA  \"b\" \"c\" \"d\" ##  ## [[2]] ## [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" ##  ## [[3]] ## [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"filtering-aggregating-and-merging-spectra-data","dir":"Articles","previous_headings":"General usage","what":"Filtering, aggregating and merging spectra data","title":"Description and usage of Spectra objects","text":"Various functions available filter, subset merge Spectra objects. can generally subdivided functions subset filter spectra data operations filter mass peak data. third category function allows aggregate data within Spectra merge combine multiple Spectra objects one. Functions various categories described following subsections. Please refer function’s documentation details information.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"filter-spectra-data","dir":"Articles","previous_headings":"General usage > Filtering, aggregating and merging spectra data","what":"Filter spectra data","title":"Description and usage of Spectra objects","text":"functions comprise subset operations reduce total number spectra Spectra object well filter functions reduce content Spectra’s spectra data (.e. content spectraVariables()). functions thus don’t change affect mass peaks data Spectra’s individual spectra. [: operation reduce Spectra object selected elements. dropNaSpectraVariables(): drops spectraVariables() contain missing values. function returns Spectra object number elements, eventually fewer spectra variables. filterAcquisitionNum(): retains spectra certain acquisition numbers. filterDataOrigin(): subsets spectra specific origins. filterDataStorage(): subsets spectra certain data storage files. filterEmptySpectra(): removes spectra without mass peaks. filterIsolationWindow(): keeps spectra provided mz isolation window (m/z range). filterMsLevel(): filters MS level. filterPolarity(): filters polarity. filterPrecursorCharge(): retains (MSn) spectra specified precursor charge(s). filterPrecursorIsotopes(): identifies precursor ions (fragment spectra) represent isotopes molecule. spectra groups spectrum monoisotopic precursor ion returned. MS1 spectra returned without filtering. filterPrecursorMaxIntensity(): filters spectra keeping, groups spectra similar precursor m/z, one spectrum highest precursor intensity. MS1 spectra returned without filtering. filterPrecursorMzRange(): retains (MSn) spectra precursor m/z within provided m/z range. filterPrecursorMzValues((): retains (MSn) spectra precursor m/z value matching provided value(s) considering also tolerance ppm. filterPrecursorScan(): retains (parent children) scans acquisition number. filterRanges(): filters Spectra object based (multiple) user defined numeric ranges one available (numeric) spectra variables. filterRt(): filters based retention time range. filterValues(): filters Spectra object based similarities numeric values one available spectra variables. selectSpectraVariables(): reduces (spectra) data within object selected spectra variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"filter-or-aggregate-mass-peak-data","dir":"Articles","previous_headings":"General usage > Filtering, aggregating and merging spectra data","what":"Filter or aggregate mass peak data","title":"Description and usage of Spectra objects","text":"function filter aggregate mass peak data (peaksData()) spectrum Spectra without changing total number spectra. combinePeaks(): groups peaks within spectrum based similarity m/z values combines single peak per peak group. deisotopeSpectra(): deisotopes individual spectrum keeping monoisotopic peak peaks groups potential isotopologues. filterFourierTransformArtefacts(): removes (Orbitrap) fast fourier transform artifact peaks spectra. filterIntensity(): filter spectrum keeping peaks intensities meeting certain criteria. filterMzRange(): filters mass peaks keeping (removing) m/z within provided m/z range. filterMzValues(): filters mass peaks within spectrum keeping (removing) m/z matching provided value(s). filterPeaksRanges(): filters mass peaks using set range-based filters numeric spectra peaks variables. filterPrecursorPeaks(): removes peaks either m/z value matching precursor m/z respective spectrum (parameter mz = \"==\") peaks m/z value larger equal precursor m/z (parameter mz = \">=\"). reduceSpectra(): filters individual spectra keeping largest peak groups peaks similar m/z values.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"merging-aggregating-and-splitting","dir":"Articles","previous_headings":"General usage > Filtering, aggregating and merging spectra data","what":"Merging, aggregating and splitting","title":"Description and usage of Spectra objects","text":"c(): combine several Spectra single Spectra object. combineSpectra(): allows combine MS data sets spectra single spectrum per set. Thus, instead filtering data, function aggregates . joinSpectraData(): merge DataFrame existing spectra data. split(): splits Spectra object based provided grouping factor.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"examples-and-use-cases-for-filter-operations","dir":"Articles","previous_headings":"General usage > Filtering, aggregating and merging spectra data","what":"Examples and use cases for filter operations","title":"Description and usage of Spectra objects","text":"example, use filterValues() function retain spectra base peak m/z close 100 (+/- 30 ppm) retention time around 230 (+/- 5 s). , demonstrate usage filterRanges() function filter spectra based ranges values variables base peak m/z, peak count, retention time. one spectrum matches ranges. Another option filterValues() filterRanges() use parameter match = \"\", retains spectra match one conditions instead match . Let’s run code change match parameter time: can see many spectra passed filtering step time. example use specific functions select spectra measured second mzML file subsequently filter retain spectra measured 175 189 seconds measurement run. addition, Spectra support also subsetting [. perform filtering [ -based subsetting. equivalent using filter function shown , added benefit filtering recorded processing slot. Note use filter functions might efficient backends, depending implementation, (e.g. database-based backends translate filter function SQL condition perform subsetting already within database). Multiple Spectra objects can also combined single Spectra c() concatenateSpectra() function. resulting Spectra object contain union spectra variables individual objects. combine Spectra object sps additional object containing another MS2 spectrum Caffeine. Next combine two objects. resulting object contains now data 4 MS2 spectra union spectra variables objects. second object additional spectra variable instrument present sps spectra object thus get value NA variable. Sometimes spectra variables might required (e.g. also many empty). might specifically interesting also Spectra containing data large experiments, can significantly reduce object’s size memory. cases selectSpectraVariables() function can used retain specified spectra variables.","code":"sps_sub <- filterValues(sps_sciex, spectraVariables = c(\"basePeakMZ\", \"rtime\"),                         values = c(123.089, 230), tolerance = c(0,5),                         ppm = c(30, 0), match = \"all\") length(sps_sub) ## [1] 72 sps_ranges <- filterRanges(sps_sciex,                            spectraVariables = c(\"basePeakMZ\",\"peaksCount\",                                                 \"rtime\"),                            ranges = c(123.09,124, 3500, 3520, 259, 260),                            match = \"all\") length(sps_ranges) ## [1] 1 sps_ranges <- filterRanges(sps_sciex,                            spectraVariables = c(\"basePeakMZ\",                                                 \"peaksCount\", \"rtime\"),                            ranges = c(123.09, 124, 3500, 3520, 259, 260),                            match = \"any\") length(sps_ranges) ## [1] 473 fls <- unique(dataOrigin(sps_sciex)) file_2 <- filterDataOrigin(sps_sciex, dataOrigin = fls[2]) length(file_2) ## [1] 931 sps_sub <- filterRt(file_2, rt = c(175, 189)) length(sps_sub) ## [1] 50 sps_sciex[sps_sciex$dataOrigin == fls[2] &           sps_sciex$rtime >= 175 &           sps_sciex$rtime <= 189] ## MSn data (Spectra) with 50 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           1   175.212       628 ## 2           1   175.491       629 ## 3           1   175.770       630 ## 4           1   176.049       631 ## 5           1   176.328       632 ## ...       ...       ...       ... ## 46          1   187.768       673 ## 47          1   188.047       674 ## 48          1   188.326       675 ## 49          1   188.605       676 ## 50          1   188.884       677 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML sps_sciex |>     filterDataOrigin(fls[2]) |>     filterRt(c(175, 189)) ## MSn data (Spectra) with 50 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           1   175.212       628 ## 2           1   175.491       629 ## 3           1   175.770       630 ## 4           1   176.049       631 ## 5           1   176.328       632 ## ...       ...       ...       ... ## 46          1   187.768       673 ## 47          1   188.047       674 ## 48          1   188.326       675 ## 49          1   188.605       676 ## 50          1   188.884       677 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select data origin(s) /__w/_temp/Library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML [Thu Aug  1 12:48:24 2024] ##  Filter: select retention time [175..189] on MS level(s) 1 [Thu Aug  1 12:48:24 2024] caf_df <- DataFrame(msLevel = 2L, name = \"Caffeine\",                     id = \"HMDB0001847\",                     instrument = \"Agilent 1200 RRLC; Agilent 6520 QTOF\",                     splash = \"splash10-0002-0900000000-413259091ba7edc46b87\",                     centroided = TRUE) caf_df$mz <- list(c(110.0710, 138.0655, 138.1057, 138.1742, 195.9864)) caf_df$intensity <- list(c(3.837, 32.341, 0.84, 0.534, 100))  caf <- Spectra(caf_df) sps <- concatenateSpectra(sps, caf) sps ## MSn data (Spectra) with 4 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Processing: ##  Merge 2 Spectra into one [Thu Aug  1 12:48:24 2024] spectraVariables(sps) ##  [1] \"msLevel\"                 \"rtime\"                   ##  [3] \"acquisitionNum\"          \"scanIndex\"               ##  [5] \"dataStorage\"             \"dataOrigin\"              ##  [7] \"centroided\"              \"smoothed\"                ##  [9] \"polarity\"                \"precScanNum\"             ## [11] \"precursorMz\"             \"precursorIntensity\"      ## [13] \"precursorCharge\"         \"collisionEnergy\"         ## [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" ## [17] \"isolationWindowUpperMz\"  \"id\"                      ## [19] \"name\"                    \"splash\"                  ## [21] \"instrument\" sps$instrument ## [1] NA                                     ## [2] NA                                     ## [3] NA                                     ## [4] \"Agilent 1200 RRLC; Agilent 6520 QTOF\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"data-manipulations","dir":"Articles","previous_headings":"General usage","what":"Data manipulations","title":"Description and usage of Spectra objects","text":"analyses require manipulation mass peak data (.e. m/z /intensity values). One example remove peaks spectrum intensity lower certain threshold. perform operation replaceIntensitiesBelow() function replace peak intensities 10 spectrum sps value 0. result intensities 10 set 0 peaks. Zero-intensity peaks (peaks missing intensities) can removed filterIntensity() function specifying lower required intensity level optionally also upper intensity limit. filterIntensity() supports also user-provided function passed parameter intensity allow e.g. remove peaks smaller median peak intensity spectrum. See examples ?filterIntensity help page details. Note data manipulations Spectra objects immediately applied peak data. added called processing queue applied time peak data accessed (peaksData(), mz() intensity() functions). Thanks processing queue data manipulation operations also possible read-backends (e.g. mzML-file based backends database-based backends). information number processing steps can seen (next Lazy evaluation queue). possible add also custom functions processing queue Spectra object. function must take peaks matrix first argument, ... function definition must return peaks matrix (peaks matrix numeric two-column matrix first column containing peaks’ m/z values second corresponding intensities). define function divides intensities peak value can passed argument y. Object sps_2 now 3 processing steps lazy evaluation queue. Calling intensity() object now return intensities half intensities original objects sps. Alternatively define function returns maximum peak spectrum (note: use unname() function remove names results): spectrum sps_2 thus contains single peak. parameter spectraVariables addProcessing() function allows addition define spectra variables passed (addition peaks matrix) user-provided function. enable example calculate neutral loss spectra Spectra subtracting precursor m/z m/z spectrum (note also dedicated neutralLoss() function perform operation efficiently). tool example precursor m/z values defined, thus first set arbitrary values. define function neutral_loss calculates difference precursor m/z fragment peak’s m/z. addition need ensure peaks resulting spectra ordered (delta) m/z values. Note , order able access precursor m/z spectrum within function, add parameter function name spectrum variable want access (case precursorMz). call addProcessing() spectraVariables = \"precursorMz\" specify spectra variable passed along function. can see, precursor m/z subtracted m/z respective spectrum. better version function, calculates neutral loss spectra MS level 2 spectra neutral_loss function . Since accessing also spectrum’s MS level call addProcessing() adding also spectra variable msLevel spectraVariables parameter. Note however msLevel spectra variable default renamed spectrumMsLevel prior passing function. thus use parameter called spectrumMsLevel neutral_loss function instead msLevel. Using concept also possible provide spectrum-specific user-defined value processing function. variable simply added first new spectra variable Spectra object variable passed along function way passed precursor m/z function . Another example spectra processing potentially helpful spectral matching reference fragment spectra libraries function removes fragment peaks m/z matching precursor m/z spectrum. define function takes peaks matrix precursor m/z input evaluates closest() function MsCoreUtils whether spectrum contains peaks m/z value matching one precursor (given tolerance ppm). returned peaks matrix contains peaks except matching precursor m/z. can now add processing step Spectra object. result, peaks matching precursor m/z (tolerance = 0.1 ppm = 0) removed. reference, original peak matrices shown . Note can also perform relaxed matching m/z values passing different value tolerance function: Since data manipulations change original intensity m/z values, possible restore original data. can done reset() function empty lazy evaluation queue call reset() method storage backend. call reset() sps_2 object hence restore data original state. Finally, Spectra use writeable backend, MsBackendMemory, MsBackendDataFrame MsBackendHdf5Peaks, possible apply processing queue peak data write back data storage applyProcessing() function. use make data manipulations peak data sps_rep object persistent. applyProcessing() lazy evaluation queue contained 2 processing steps, applied peak data written data storage. Note calling reset() applyProcessing() can longer restore data.","code":"sps_rep <- replaceIntensitiesBelow(sps, threshold = 10, value = 0) intensity(sps_rep) ## NumericList of length 4 ## [[1]] 0 47.494 0 100 13.24 ## [[2]] 0 0 0 16.708 100 0 40.643 ## [[3]] 0 0 0 0 0 0 0 100 40.994 ## [[4]] 0 32.341 0 0 100 sps_rep <- filterIntensity(sps_rep, intensity = c(0.1, Inf)) intensity(sps_rep) ## NumericList of length 4 ## [[1]] 47.494 100 13.24 ## [[2]] 16.708 100 40.643 ## [[3]] 100 40.994 ## [[4]] 32.341 100 sps_rep ## MSn data (Spectra) with 4 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Lazy evaluation queue: 2 processing step(s) ## Processing: ##  Merge 2 Spectra into one [Thu Aug  1 12:48:24 2024] ##  Signal <= 10 in MS level(s) 2 set to 0 [Thu Aug  1 12:48:25 2024] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Thu Aug  1 12:48:25 2024] ## Define a function that takes a matrix as input, divides the second ## column by parameter y and returns it. Note that ... is required in ## the function's definition. divide_intensities <- function(x, y, ...) {     x[, 2] <- x[, 2] / y     x }  ## Add the function to the procesing queue sps_2 <- addProcessing(sps_rep, divide_intensities, y = 2) sps_2 ## MSn data (Spectra) with 4 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Lazy evaluation queue: 3 processing step(s) ## Processing: ##  Merge 2 Spectra into one [Thu Aug  1 12:48:24 2024] ##  Signal <= 10 in MS level(s) 2 set to 0 [Thu Aug  1 12:48:25 2024] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Thu Aug  1 12:48:25 2024] intensity(sps_2) ## NumericList of length 4 ## [[1]] 23.747 50 6.62 ## [[2]] 8.354 50 20.3215 ## [[3]] 50 20.497 ## [[4]] 16.1705 50 intensity(sps_rep) ## NumericList of length 4 ## [[1]] 47.494 100 13.24 ## [[2]] 16.708 100 40.643 ## [[3]] 100 40.994 ## [[4]] 32.341 100 max_peak <- function(x, ...) {     unname(x[which.max(x[, 2]), , drop = FALSE]) }  sps_2 <- addProcessing(sps_rep, max_peak) lengths(sps_2) ## [1] 1 1 1 1 intensity(sps_2) ## NumericList of length 4 ## [[1]] 100 ## [[2]] 100 ## [[3]] 100 ## [[4]] 100 sps_rep$precursorMz <- c(170.5, 170.5, 195.1, 195.1)  neutral_loss <- function(x, precursorMz, ...) {     x[, \"mz\"] <- precursorMz - x[, \"mz\"]     x[order(x[, \"mz\"]), , drop = FALSE] } sps_3 <- addProcessing(sps_rep, neutral_loss,                        spectraVariables = \"precursorMz\") mz(sps_rep) ## NumericList of length 4 ## [[1]] 124.2 170.16 170.52 ## [[2]] 109.14 124.08 170.16 ## [[3]] 138.0662 195.0876 ## [[4]] 138.0655 195.9864 mz(sps_3) ## NumericList of length 4 ## [[1]] -0.0200000000000102 0.340000000000003 46.3 ## [[2]] 0.340000000000003 46.42 61.36 ## [[3]] 0.0123999999999853 57.0338 ## [[4]] -0.886400000000009 57.0345 neutral_loss <- function(x, spectrumMsLevel, precursorMz, ...) {     if (spectrumMsLevel == 2L) {         x[, \"mz\"] <- precursorMz - x[, \"mz\"]         x <- x[order(x[, \"mz\"]), , drop = FALSE]     }     x } sps_3 <- addProcessing(sps_rep, neutral_loss,                        spectraVariables = c(\"msLevel\", \"precursorMz\")) mz(sps_3) ## NumericList of length 4 ## [[1]] -0.0200000000000102 0.340000000000003 46.3 ## [[2]] 0.340000000000003 46.42 61.36 ## [[3]] 0.0123999999999853 57.0338 ## [[4]] -0.886400000000009 57.0345 library(MsCoreUtils) ##  ## Attaching package: 'MsCoreUtils' ## The following objects are masked from 'package:Spectra': ##  ##     bin, entropy, smooth ## The following objects are masked from 'package:ProtGenerics': ##  ##     bin, smooth ## The following object is masked from 'package:stats': ##  ##     smooth remove_precursor <- function(x, precursorMz, tolerance = 0.1, ppm = 0, ...) {     if (!is.na(precursorMz)) {         keep <- is.na(closest(x[, \"mz\"], precursorMz, tolerance = tolerance,                              ppm = ppm, .check = FALSE))         x[keep, , drop = FALSE]     } else x } sps_4 <- addProcessing(sps_rep, remove_precursor,                        spectraVariables = \"precursorMz\")  peaksData(sps_4) |> as.list() ## [[1]] ##          mz intensity ## [1,] 124.20    47.494 ## [2,] 170.16   100.000 ##  ## [[2]] ##          mz intensity ## [1,] 109.14    16.708 ## [2,] 124.08   100.000 ## [3,] 170.16    40.643 ##  ## [[3]] ##            mz intensity ## [1,] 138.0662       100 ##  ## [[4]] ##            mz intensity ## [1,] 138.0655    32.341 ## [2,] 195.9864   100.000 peaksData(sps_rep) |> as.list() ## [[1]] ##          mz intensity ## [1,] 124.20    47.494 ## [2,] 170.16   100.000 ## [3,] 170.52    13.240 ##  ## [[2]] ##          mz intensity ## [1,] 109.14    16.708 ## [2,] 124.08   100.000 ## [3,] 170.16    40.643 ##  ## [[3]] ##            mz intensity ## [1,] 138.0662   100.000 ## [2,] 195.0876    40.994 ##  ## [[4]] ##            mz intensity ## [1,] 138.0655    32.341 ## [2,] 195.9864   100.000 sps_4 <- addProcessing(sps_rep, remove_precursor, tolerance = 0.6,                        spectraVariables = \"precursorMz\") peaksData(sps_4) |> as.list() ## [[1]] ##         mz intensity ## [1,] 124.2    47.494 ##  ## [[2]] ##          mz intensity ## [1,] 109.14    16.708 ## [2,] 124.08   100.000 ##  ## [[3]] ##            mz intensity ## [1,] 138.0662       100 ##  ## [[4]] ##            mz intensity ## [1,] 138.0655    32.341 ## [2,] 195.9864   100.000 sps_2_rest <- reset(sps_2)  intensity(sps_2_rest) ## NumericList of length 4 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 ## [[4]] 3.837 32.341 0.84 0.534 100 intensity(sps) ## NumericList of length 4 ## [[1]] 3.407 47.494 3.094 100 13.24 ## [[2]] 6.685 4.381 3.022 16.708 100 4.565 40.643 ## [[3]] 0.459 2.585 2.446 0.508 8.968 0.524 0.974 100 40.994 ## [[4]] 3.837 32.341 0.84 0.534 100 length(sps_rep@processingQueue) ## [1] 2 sps_rep <- applyProcessing(sps_rep) length(sps_rep@processingQueue) ## [1] 0 sps_rep ## MSn data (Spectra) with 4 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2        NA        NA ## 2         2        NA        NA ## 3         2        NA        NA ## 4         2        NA        NA ##  ... 20 more variables/columns. ## Processing: ##  Merge 2 Spectra into one [Thu Aug  1 12:48:24 2024] ##  Signal <= 10 in MS level(s) 2 set to 0 [Thu Aug  1 12:48:25 2024] ##  Remove peaks with intensities outside [0.1, Inf] in spectra of MS level(s) 2. [Thu Aug  1 12:48:25 2024] ##  ...1 more processings. Use 'processingLog' to list all."},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"visualizing-spectra","dir":"Articles","previous_headings":"General usage","what":"Visualizing Spectra","title":"Description and usage of Spectra objects","text":"Spectra package provides following functions visualize spectra data: - plotSpectra(): plot spectrum Spectra panel. - plotSpectraOverlay(): plot multiple spectra plot. use plotSpectra() plot 4 spectra sps object using names (provided spectra variable \"name\") plot titles.  also possible label individual peaks plot. use m/z value peak label. example define function accesses information spectrum (z) returns character peak text used label. Parameters labelSrt, labelPos labelOffset define rotation label text position relative x y coordinates peak.  plots rather busy peaks m/z values overplotted. define label function indicate m/z peaks intensity higher 30.  Sometimes might interest plot multiple spectra plot (e.g. directly compare peaks multiple spectra). can done plotSpectraOverlay() use create overlay-plot 4 example spectra, using different color spectrum.  Lastly, plotSpectraMirror() allows plot two spectra mirror plot ideal visualize spectra comparison results. plot spectrum 1-Methylhistidine one Caffeine.  upper panel shows spectrum 1-Methylhistidine, lower one Caffeine. None peaks two spectra match. plot two spectra 1-Methylhistidine two Caffeine matching peaks ppm 50.  See also ?plotSpectra plotting options examples.","code":"plotSpectra(sps, main = sps$name) plotSpectra(sps, main = sps$name,             labels = function(z) format(mz(z)[[1L]], digits = 4),             labelSrt = -30, labelPos = 2, labelOffset = 0.1) mzLabel <- function(z) {     z <- peaksData(z)[[1L]]     lbls <- format(z[, \"mz\"], digits = 4)     lbls[z[, \"intensity\"] < 30] <- \"\"     lbls } plotSpectra(sps, main = sps$name, labels = mzLabel,             labelSrt = -30, labelPos = 2, labelOffset = 0.1) cols <- c(\"#E41A1C80\", \"#377EB880\", \"#4DAF4A80\", \"#984EA380\") plotSpectraOverlay(sps, lwd = 2, col = cols) legend(\"topleft\", col = cols, legend = sps$name, pch = 15) plotSpectraMirror(sps[1], sps[3]) par(mfrow = c(1, 2)) plotSpectraMirror(sps[1], sps[2], main = \"1-Methylhistidine\", ppm = 50) plotSpectraMirror(sps[3], sps[4], main = \"Caffeine\", ppm = 50)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"aggregating-spectra-data","dir":"Articles","previous_headings":"General usage","what":"Aggregating spectra data","title":"Description and usage of Spectra objects","text":"Spectra package provides combineSpectra() function allows aggregate multiple spectra single one. main parameters function f, defines sets spectra combined, FUN, allows define function performs actual aggregation. default aggregation function combinePeaksData() (see ?combinePeaksData details) combines multiple spectra single spectrum peaks input spectra (additional paramter peaks = \"union\"), peaks present certain proportion input spectra (parameter peaks = \"intersect\"; parameter minProp allows define minimum required proportion spectra peak needs present. important mention , default, function combines mass peaks spectra similar m/z value single, representative mass peak aggregating intensities one. avoid resulting intensity affected potential noise peaks might advised first clean individual mass spectra using e.g. combinePeaks() reduceSpectra() functions first aggregate mass peaks within individual spectrum. example use combineSpectra() combine spectra 1-methylhistidine caffeine single spectrum compound. use spectra variable $name, contains names compounds, define spectra grouped together. result, 4 spectra got aggregated two.  default, peaks present spectra reported. alternative, specifying peaks = \"intersect\" minProp = 1, combine spectra keeping peaks present input spectra.  results thus single peak 1-methylhistidine none caffeine - ? reason difference peaks’ m/z values larger default tolerance used peak grouping (defaults combinePeaksData() tolerance = 0 ppm = 0). however already see previous section reported peaks’ m/z values larger measurement error (likely fragment spectra measured different instruments different precision). Thus, next increase tolerance ppm parameters group also peaks larger difference m/z values.  Whether real analysis OK large tolerance however questionable. Note: m/z intensity reported aggregated spectra can defined parameters intensityFun mzFun combinePeaksData() (see ?combinePeaksData information). combinePeaksData() function indeed helpful combine peaks different spectra, combineSpectra() function addition also allow us provide , custom, peak aggregation function. simple example, instead combining spectra, like select one input spectra representative spectrum grouped input spectra. combineSpectra() supports function takes list peak matrices input returns single peak matrix output. thus define function calculates total signal (TIC) input peak matrix, returns one peak matrix largest TIC. can now use function combineSpectra() select compound spectrum largest TIC.","code":"sps_agg <- combineSpectra(sps, f = sps$name) plotSpectra(sps_agg, main = sps_agg$name) sps_agg <- combineSpectra(sps, f = sps$name, peaks = \"intersect\", minProp = 1) plotSpectra(sps_agg, main = sps_agg$name) sps_agg <- combineSpectra(sps, f = sps$name, peaks = \"intersect\",                           minProp = 1, tolerance = 0.2) plotSpectra(sps_agg, main = sps_agg$name) #' function to select and return the peak matrix with the largest tic from #' the provided list of peak matrices. maxTic <- function(x, ...) {     tic <- vapply(x, function(z) sum(z[, \"intensity\"], na.rm = TRUE),                   numeric(1))     x[[which.max(tic)]] } sps_agg <- combineSpectra(sps, f = sps$name, FUN = maxTic) plotSpectra(sps_agg, main = sps_agg$name)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"comparing-spectra","dir":"Articles","previous_headings":"General usage","what":"Comparing spectra","title":"Description and usage of Spectra objects","text":"Spectra can compared compareSpectra() function, allows calculate similarities spectra using variety methods. compareSpectra() implements similarity scoring two-step approach: first peaks pair spectra compared matched (mapped) similarity score calculated . MAPFUN parameter compareSpectra() defines function match (map) peaks spectra parameter FUN specifies function calculate similarity. default, compareSpectra() uses MAPFUN = joinPeaks (see ?joinPeaks description alternative options) FUN = ndotproduct (normalized dot-product spectra similarity score). Parameters configure functions can passed compareSpectra() additional parameter (e.g. ppm define m/z-relative tolerance peak matching joinPeaks()). calculate pairwise similarities spectra sps accepting 50 ppm difference peaks’ m/z values considered matching. resulting matrix provides similarity scores pairwise comparison. expected, first two last two spectra similar, albeit moderately, spectra 1-Methylhistidine don’t share similarity Caffeine. Similarities Spectra objects can calculated calls form compareSpectra(, b) b two Spectra objects compare. result n x m matrix returned n (rows) spectra m (columns) spectra b. similarity calculated default (normalized) dot-product, also similarity scores can used instead. Either one metrics provided MsCoreUtils used (see ?MsCoreUtils::distance list available options) external user-provided similarity scoring function. example, use spectral entropy similarity score introduced (Y et al. 2021) provided msentropy package. Since msentropy_similarity() function performs also mapping peaks compared spectra internally (along spectra cleaning), disable compareSpectra() function using MAPFUN = joinPeaksNone. configure similarity scoring can pass additional parameters msentropy_similarity() (see ?msentropy_similarity) compareSpectra() call. use ms2_tolerance_in_ppm = 50 set tolerance m/z-relative peak matching (equivalent ppm = 50 used ) ms2_tolerance_in_da = -1 disable absolute tolerance matching. Note also GNPS-like scores can calculated MAPFUN = joinPeaksGnps FUN = MsCoreUtils::gnps. additional information examples see also (Rainer et al. 2022) SpectraTutorials tutorial. Another way comparing spectra bin spectra cluster based similar intensity values. Spectra binning ensures binned m/z values comparable across spectra. bin spectra using bin size 0.1 (.e. peaks m/z smaller 0.1 aggregated one binned peak. , explicitly set zero.rm = FALSE retain bins generated function, including intensity zero. spectra now number m/z values. intensity values however 0 (original spectra peak respective m/z bin present). ’re next creating intensity matrix Spectra object, row one spectrum columns representing binned m/z values. can now identify columns (m/z bins) 0s across spectra remove . associated m/z values bins can extracted mz() binned Spectra object. use column names intensity matrix. intensity matrix now example used cluster spectra based peak intensities.  expected, first 2 last 2 spectra similar clustered together.","code":"compareSpectra(sps, ppm = 50) ##           1         2         3         4 ## 1 1.0000000 0.1380817 0.0000000 0.0000000 ## 2 0.1380817 1.0000000 0.0000000 0.0000000 ## 3 0.0000000 0.0000000 1.0000000 0.1817149 ## 4 0.0000000 0.0000000 0.1817149 1.0000000 library(msentropy) ## Loading required package: Rcpp compareSpectra(sps, MAPFUN = joinPeaksNone, FUN = msentropy_similarity,                ms2_tolerance_in_ppm = 50, ms2_tolerance_in_da = -1) ##           1         2         3         4 ## 1 1.0000000 0.3002225 0.0000000 0.0000000 ## 2 0.3002225 1.0000000 0.0000000 0.0000000 ## 3 0.0000000 0.0000000 1.0000000 0.5144764 ## 4 0.0000000 0.0000000 0.5144764 1.0000000 sps_bin <- Spectra::bin(sps, binSize = 0.1, zero.rm = FALSE) lengths(sps_bin) ## [1] 1400 1400 1400 1400 intensity(sps_bin) ## NumericList of length 4 ## [[1]] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [[2]] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [[3]] 0.459 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 40.994 0 0 0 0 0 0 0 0 0 ## [[4]] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100 intmat <- do.call(rbind, intensity(sps_bin)) zeros <- colSums(intmat) == 0 intmat <- intmat[, !zeros] intmat ##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]   [,8]  [,9] [,10] [,11] [,12] ## [1,] 0.000 0.000 0.000 0.000 0.000 0.000 0.000  0.000 3.407 0.000 0.000 0.000 ## [2,] 0.000 0.000 0.000 6.685 4.381 3.022 0.000 16.708 0.000 0.000 0.000 0.000 ## [3,] 0.459 2.585 2.446 0.000 0.000 0.000 0.508  0.000 0.000 8.968 0.524 0.974 ## [4,] 0.000 0.000 0.000 0.000 0.000 0.000 0.000  0.000 0.000 3.837 0.000 0.000 ##      [,13]  [,14] [,15] [,16]   [,17] [,18]   [,19] [,20]  [,21] [,22] ## [1,]     0 47.494 3.094 0.000   0.000 0.000 100.000 13.24  0.000     0 ## [2,]   100  0.000 0.000 4.565   0.000 0.000  40.643  0.00  0.000     0 ## [3,]     0  0.000 0.000 0.000 100.000 0.000   0.000  0.00 40.994     0 ## [4,]     0  0.000 0.000 0.000  32.341 1.374   0.000  0.00  0.000   100 colnames(intmat) <- mz(sps_bin)[[1L]][!zeros] heatmap(intmat)"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"exporting-spectra","dir":"Articles","previous_headings":"General usage","what":"Exporting spectra","title":"Description and usage of Spectra objects","text":"Spectra data can exported export() method. method takes Spectra supposed exported backend (parameter backend) used export data additional parameters export function backend. backend thus defines format exported file. Note however MsBackend classes might support data export. backend classes currently supporting data export format : - MsBackendMzR (Spectra package): export data mzML mzXML format. Can export custom, user specified spectra variables. - MsBackendMgf (MsBackendMgf package): exports data Mascot Generic Format (mgf). Exports spectra variables individual spectrum fields mgf file. - MsBackendMsp (MsBackendMsp): exports data NIST MSP format. - MsBackendMassbank (MsBackendMassbank) exports data Massbank text file format. example use MsBackendMzR export spectra variable sps mzML file. thus pass data, backend used export file name result file (temporary file) export() function (see also help page export,MsBackendMzR function additional supported parameters). evaluate spectra variables exported, load exported data identify spectra variables original file exported (defined variables mzML standard). additional variables thus exported. data export performed handled depends also used backend. MsBackendMzR example exports spectra default single file (specified file parameter), allows also specify individual spectrum Spectra file exported (parameter file thus length equal number spectra). example export spectrum 1 3 one file spectra 2 4 another. realistic use case mzML export export MS data processing, smoothing (using smooth() function) centroiding (using pickPeaks() function) raw profile-mode MS data.","code":"fl <- tempfile() export(sps, MsBackendMzR(), file = fl) ## Writing file file25d54ff67c39...OK sps_im <- Spectra(backendInitialize(MsBackendMzR(), fl)) spectraVariables(sps)[!spectraVariables(sps) %in% spectraVariables(sps_im)] ## [1] \"id\"         \"name\"       \"splash\"     \"instrument\" fls <- c(tempfile(), tempfile()) export(sps, MsBackendMzR(), file = fls[c(1, 2, 1, 2)]) ## Writing file file25d569f8f6d5...OK ## Writing file file25d533c11325...OK"},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"changing-backends","dir":"Articles","previous_headings":"General usage","what":"Changing backends","title":"Description and usage of Spectra objects","text":"previous sections learned already Spectra object can use different backends actual data handling. also possible change backend Spectra different one setBackend() function. example change (MsBackendMzR) backend sps_sciex object MsBackendMemory backend enable use data even without need keep original mzML files. change backend sps_sciex -memory MsBackendMemory backend. call full peak data imported original mzML files object. obviously impact object’s size, now much larger . dataStorage spectrum variable now changed, dataOrigin still keeps information originating files:","code":"print(object.size(sps_sciex), units = \"Mb\") ## 0.4 Mb sps_sciex <- setBackend(sps_sciex, MsBackendMemory()) sps_sciex ## MSn data (Spectra) with 1862 spectra in a MsBackendMemory backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ## Processing: ##  Switch backend from MsBackendMzR to MsBackendMemory [Thu Aug  1 12:48:30 2024] print(object.size(sps_sciex), units = \"Mb\") ## 53.2 Mb head(dataStorage(sps_sciex)) ## [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" head(basename(dataOrigin(sps_sciex))) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [5] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"backends","dir":"Articles","previous_headings":"","what":"Backends","title":"Description and usage of Spectra objects","text":"Backends allow use different backends store mass spectrometry data providing via Spectra class unified interface use data. abstraction -disk -memory data modes MSnbase (Gatto, Gibb, Rainer 2020). Spectra package defines set example backends object extending base MsBackend class used instead. default backends : MsBackendMemory: default backend store data memory. Due design MsBackendMemory provides fast access peaks matrices (using peaksData() function) also optimized fast access spectra variables subsetting. Since data kept memory, backend relatively large memory footprint (depending data) thus suggested large MS experiments. MsBackendDataFrame: mass spectrometry data stored (-memory) DataFrame. Keeping data memory guarantees high performance also, depending number mass peaks spectrum, much higher memory footprint. MsBackendMzR: backend keeps general spectra variables memory relies mzR package read mass peaks (m/z intensity values) original MS files -demand. MsBackendHdf5Peaks: similar MsBackendMzR backend reads peak data -demand disk spectra variables kept memory. peak data stored Hdf5 files guarantees scalability. mentioned backends support changing spectra variables, except MsBackendMzR support changing m/z intensity values mass peaks. example load data single mzML file use MsBackendHdf5Peaks backend data storage. hdf5path parameter allows us specify storage location HDF5 file. (possibly incomplete) list R packages providing additional backends add support additional data types storage options provided : MsBackendMgf: support import/export mass spectrometry files mascot generic format (MGF). MsBackendMsp: allows import/export data NIST MSP format. Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendMassbank (package MsBackendMassbank): allows import/export data MassBank text file format. Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendMassbankSql (package MsBackendMassbank): allows directly connect MassBank SQL database retrieve MS data variables. minimal memory footprint data retrieved --fly SQL database. MsBackendSql: stores MS data SQL database thus minimal memory footprint. MsBackendCompDb (package CompoundDb): provides access spectra data (spectra peaks variables) CompDb database. small memory footprint data (except precursor m/z values) retrieved --fly database. MsBackendRawFileReader: implements backend reading MS data Thermo Fisher Scientific’s raw data files using manufacturer’s NewRawFileReader .Net libraries. package generalizes functionality introduced rawrr package, see also (Kockmann Panse 2021). MsBackendHmdbXml (package MsbackendHmdb): allows import MS data xml files Human Metabolome Database (HMDB). Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendTimsTof (package MsBackendTimsTof: allows import data Bruker TimsTOF raw data files (using opentimsr R package). MsBackendWeizMass (package MsBackendWeizMass: allows access MS data WeizMass MS/MS spectral databases.","code":"library(msdata) fl <- proteomics(full.names = TRUE)[5]  sps_tmt <- Spectra(fl, backend = MsBackendHdf5Peaks(), hdf5path = tempdir()) head(basename(dataStorage(sps_tmt))) ## [1] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [2] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [3] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [4] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [5] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\" ## [6] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.h5\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"handling-very-large-data-sets","dir":"Articles","previous_headings":"","what":"Handling very large data sets","title":"Description and usage of Spectra objects","text":"Spectra package designed support also efficient processing large data sets. functionality require keep full MS data memory (specifically, peaks data, .e., m/z intensity values, represent largest chunk data MS experiments). functions however peaks data needs loaded memory. One example lengths() function determine number peaks per spectra calculated (fly) evaluating number rows peaks matrix. Backends MsBackendMzR perform default data processing separately (eventually parallel) data file thus safe call functions Spectra object backend. backends (MsBackendSql MsBackendMassbankSql) however advised process data chunk-wise manner using spectrapply() function parameter chunkSize. split original Spectra object chunks size chunkSize applies function separately chunk. way data one chunk eventually loaded memory iteration enabling process also large Spectra objects computers limited hardware resources. Instead lengths(sps) call, number peaks per spectra also determined (less memory demanding way) spectrapply(sps, lengths, chunkSize = 5000L). way peak data 5000 spectra time loaded memory.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"serializing-saving-moving-and-loading-serialized-spectra-objects","dir":"Articles","previous_headings":"","what":"Serializing (saving), moving and loading serialized Spectra objects","title":"Description and usage of Spectra objects","text":"Serializing re-loading variables/objects analysis using e.g. save() load() functions common many workflows, especially tasks computationally intensive take long time. Sometimes serialized objects might even moved one computer (file system) another. operations unproblematic Spectra objects -memory backends MsBackendMemory MsBackendDataFrame, keep data memory, however break -disk backends MsBackendMzR file path original data files identical. thus suggested (size MS data respectively available system memory allows ) change backend Spectra objects MsBackendMemory serializing object save(). Spectra objects MsBackendMzR alternative option eventually update/adapt path directory containing raw (e.g. mzML) data files: assuming data files available computers, path directory containing can updated dataStorageBasePath<- function allowing thus move/copy serialized Spectra objects computers file systems. example workflow : files .mzML, b.mzML stored directory /data/mzML/ one computer. get loaded Spectra object MsBackendMzR serialized file .RData. Assuming file gets now copied another computer (data available folder /data/mzML/) loaded load(). Spectra object valid MsBackendMzR can longer access MS data original data files. Assuming user also copied data files .mzML b.mzML, folder /some_other_folder/, base storage path object need adapted match directory data files available second computer: pointing now storage path new storage location data files, Spectra object also usable second computer.","code":"A <- Spectra(c(\"/data/mzML/a.mzML\", \"/data/mzML/b.mzML\")) save(A, file = \"A.RData\") load(\"A.RData\") dataStorageBasePath(A) <- \"/some_other_folder\""},{"path":"https://rformassspectrometry.github.io/Spectra/articles/Spectra.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Description and usage of Spectra objects","text":"","code":"sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.4 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] msdata_0.45.0       msentropy_0.1.4     Rcpp_1.0.13         ##  [4] MsCoreUtils_1.17.0  Spectra_1.15.7      ProtGenerics_1.37.1 ##  [7] BiocParallel_1.39.0 S4Vectors_0.43.2    BiocGenerics_0.51.0 ## [10] BiocStyle_2.33.1    ##  ## loaded via a namespace (and not attached): ##  [1] jsonlite_1.8.8         highr_0.11             compiler_4.4.1         ##  [4] BiocManager_1.30.23    Biobase_2.65.0         rhdf5filters_1.17.0    ##  [7] parallel_4.4.1         cluster_2.1.6          jquerylib_0.1.4        ## [10] systemfonts_1.1.0      IRanges_2.39.2         textshaping_0.4.0      ## [13] yaml_2.3.10            fastmap_1.2.0          R6_2.5.1               ## [16] knitr_1.48             htmlwidgets_1.6.4      MASS_7.3-61            ## [19] bookdown_0.40          desc_1.4.3             bslib_0.8.0            ## [22] rlang_1.1.4            cachem_1.1.0           xfun_0.46              ## [25] fs_1.6.4               sass_0.4.9             cli_3.6.3              ## [28] Rhdf5lib_1.27.0        pkgdown_2.1.0.9000     ncdf4_1.22             ## [31] digest_0.6.36          mzR_2.37.3             MetaboCoreUtils_1.13.0 ## [34] rhdf5_2.49.0           lifecycle_1.0.4        clue_0.3-65            ## [37] evaluate_0.24.0        codetools_0.2-20       ragg_1.3.2             ## [40] rmarkdown_2.27         tools_4.4.1            htmltools_0.5.8.1"},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"RforMassSpectrometry Package Maintainer. Maintainer. Laurent Gatto. Author. Johannes Rainer. Author. Sebastian Gibb. Author. Philippine Louail. Author. Jan Stanstrup. Contributor. Nir Shahaf. Contributor. Mar Garcia-Aloy. Contributor.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J, Vicini , Salzer L, Stanstrup J, Badia JM, Neumann S, Stravs MA, Verri Hernandes V, Gatto L, Gibb S Wittin M. Modular Expandable Ecosystem Metabolomics Data Annotation R Metabolites 2022, 12, 173. https://doi.org/10.3390/metabo12020173","code":"@Article{,   title = {A Modular and Expandable Ecosystem for Metabolomics Data Annotation in R},   author = {Johannes Rainer and Andrea Vicini and Liesa Salzer and Jan Stanstrup and Josep M. Badia and Steffen Neumann and Michael A. Stravs and Vinicius {Verri Hernandes} and Laurent Gatto and Sebastian Gibb and Michael Witting},   journal = {Metabolites},   year = {2022},   doi = {10.3390/metabo12020173},   url = {https://www.mdpi.com/2218-1989/12/2/173},   volume = {12},   pages = {173}, }"},{"path":"https://rformassspectrometry.github.io/Spectra/index.html","id":"low-level-infrastructure-to-handle-ms-spectra","dir":"","previous_headings":"","what":"Spectra Infrastructure for Mass Spectrometry Data","title":"Spectra Infrastructure for Mass Spectrometry Data","text":"Spectra package defines efficient infrastructure storing handling mass spectrometry spectra functionality subset, process, visualize compare spectra data. provides different implementations (backends) store mass spectrometry data. comprise backends tuned fast data access processing backends large data sets ensuring small memory footprint. (possibly incomplete) list available backends (along link R package providing ) shown : MsBackendMemory (package: Spectra): default backend keeps data memory. Optimized fast processing. MsBackendDataFrame (package: Spectra): alternative MsBackendMemory also keeping data memory, supporting S4 objects spectra variables data stored internally DataFrame. MsBackendMzR (package: Spectra): using mzR package supports import MS data mzML, mzXML CDF files. backend keeps general spectra variables memory retrieves peaks data (m/z intensity values) --fly original data files. backend thus smaller memory footprint compared -memory backends. MsBackendHdf5Peaks (package: Spectra): -disk backend similar MsBackendMzR, peaks data stored HDF5 files (general spectra variables kept memory). MsBackendMgf (package MsBackendMgf: allows import/export data mascot generic format (MGF). Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendMsp (package MsbackendMsp: allows import/export data NIST MSP format. Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendMassbank (package MsBackendMassbank): allows import/export data MassBank text file format. Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendMassbankSql (package MsBackendMassbank): allows directly connect MassBank SQL database retrieve MS data variables. minimal memory footprint data retrieved --fly SQL database. MsBackendRawFileReader (package MsBackendRawFileReader): implements backend reading MS data Thermo Fisher Scientific’s raw data files using manufacturer’s NewRawFileReader .Net libraries. package generalizes functionality introduced rawrr package. MsBackendHmdbXml (package MsbackendHmdb): allows import MS data xml files Human Metabolome Database (HMDB). Extends MsBackendDataFrame keeps thus data, import, memory. MsBackendSql (package MsBackendSql): stores MS data SQL database thus minimal memory footprint. MsBackendCompDb (package CompoundDb: provides access spectra data (spectra peaks variables) CompDb database. small memory footprint data (except precursor m/z values) retrieved --fly database. MsBackendTimsTof (package MsBackendTimsTof: allows import data Bruker TimsTOF raw data files (using opentimsr R package). MsBackendWeizMass (package MsBackendWeizMass: allows access MS data WeizMass MS/MS spectral databases. information see package homepage.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spectra Infrastructure for Mass Spectrometry Data","text":"package can installed ","code":"install.packages(\"BiocManager\") BiocManager::install(\"Spectra\")"},{"path":"https://rformassspectrometry.github.io/Spectra/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Spectra Infrastructure for Mass Spectrometry Data","text":"Contributions highly welcome follow contribution guidelines. Also, please check coding style guidelines RforMassSpectrometry vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":null,"dir":"Reference","previous_headings":"","what":"Mass spectrometry data backends — MsBackend","title":"Mass spectrometry data backends — MsBackend","text":"Note classes described meant used directly end-users material man page aimed package developers. MsBackend virtual class defines different backend needs provide. MsBackend objects provide access mass spectrometry data. backends can classified -memory -disk backends, depending data, .e spectra (m/z intensities) spectra annotation (MS level, charge, polarity, ...) stored. Typically, -memory backends keep data memory ensuring fast data access, -disk backends store (parts ) data disk retrieve demand. Backend functions implementation notes new backend classes section documents API backend must implement. Currently available backends : MsBackendMemory MsBackendDataFrame: store data memory. MsBackendMemory optimized accessing processing peak data (.e. numerical matrices m/z intensity values) MsBackendDataFrame keeps data DataFrame. MsBackendMzR: stores m/z intensities -disk raw data files (typically mzML mzXML) spectra annotation information (header) memory DataFrame. backend requires mzR package. MsBackendHdf5Peaks: stores m/z intensities -disk custom hdf5 data files remaining spectra variables memory (DataFrame). backend requires rhdf5 package. See details individual backends.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mass spectrometry data backends — MsBackend","text":"","code":"# S4 method for class 'MsBackend' backendBpparam(object, BPPARAM = bpparam())  # S4 method for class 'MsBackend' backendInitialize(object, ...)  # S4 method for class 'list' backendMerge(object, ...)  # S4 method for class 'MsBackend' backendMerge(object, ...)  # S4 method for class 'MsBackend' backendParallelFactor(object, ...)  # S4 method for class 'MsBackend' export(object, ...)  # S4 method for class 'MsBackend' acquisitionNum(object)  # S4 method for class 'MsBackend' peaksData(object, columns = c(\"mz\", \"intensity\"))  # S4 method for class 'MsBackend' peaksVariables(object)  # S4 method for class 'MsBackend' centroided(object)  # S4 method for class 'MsBackend' centroided(object) <- value  # S4 method for class 'MsBackend' collisionEnergy(object)  # S4 method for class 'MsBackend' collisionEnergy(object) <- value  # S4 method for class 'MsBackend' dataOrigin(object)  # S4 method for class 'MsBackend' dataOrigin(object) <- value  # S4 method for class 'MsBackend' dataStorage(object)  # S4 method for class 'MsBackend' dataStorage(object) <- value  # S4 method for class 'MsBackend' dropNaSpectraVariables(object)  # S4 method for class 'MsBackend' filterAcquisitionNum(object, n, file, ...)  # S4 method for class 'MsBackend' filterDataOrigin(object, dataOrigin = character())  # S4 method for class 'MsBackend' filterDataStorage(object, dataStorage = character())  # S4 method for class 'MsBackend' filterEmptySpectra(object, ...)  # S4 method for class 'MsBackend' filterIsolationWindow(object, mz = numeric(), ...)  # S4 method for class 'MsBackend' filterMsLevel(object, msLevel = integer())  # S4 method for class 'MsBackend' filterPolarity(object, polarity = integer())  # S4 method for class 'MsBackend' filterPrecursorMzRange(object, mz = numeric())  # S4 method for class 'MsBackend' filterPrecursorMz(object, mz = numeric())  # S4 method for class 'MsBackend' filterPrecursorMzValues(object, mz = numeric(), ppm = 20, tolerance = 0)  # S4 method for class 'MsBackend' filterPrecursorCharge(object, z = integer())  # S4 method for class 'MsBackend' filterPrecursorScan(object, acquisitionNum = integer(), f = dataOrigin(object))  # S4 method for class 'MsBackend' filterRanges(   object,   spectraVariables = character(),   ranges = numeric(),   match = c(\"all\", \"any\") )  # S4 method for class 'MsBackend' filterRt(object, rt = numeric(), msLevel. = uniqueMsLevels(object))  # S4 method for class 'MsBackend' filterValues(   object,   spectraVariables = character(),   values = numeric(),   ppm = 0,   tolerance = 0,   match = c(\"all\", \"any\") )  # S4 method for class 'MsBackend' intensity(object)  # S4 method for class 'MsBackend' intensity(object) <- value  # S4 method for class 'MsBackend' ionCount(object)  # S4 method for class 'MsBackend' isCentroided(object, ...)  # S4 method for class 'MsBackend' isEmpty(x)  # S4 method for class 'MsBackend' isolationWindowLowerMz(object)  # S4 method for class 'MsBackend' isolationWindowLowerMz(object) <- value  # S4 method for class 'MsBackend' isolationWindowTargetMz(object)  # S4 method for class 'MsBackend' isolationWindowTargetMz(object) <- value  # S4 method for class 'MsBackend' isolationWindowUpperMz(object)  # S4 method for class 'MsBackend' isolationWindowUpperMz(object) <- value  # S4 method for class 'MsBackend' isReadOnly(object)  # S4 method for class 'MsBackend' length(x)  # S4 method for class 'MsBackend' msLevel(object)  # S4 method for class 'MsBackend' mz(object)  # S4 method for class 'MsBackend' mz(object) <- value  # S4 method for class 'MsBackend' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackend' polarity(object)  # S4 method for class 'MsBackend' polarity(object) <- value  # S4 method for class 'MsBackend' precScanNum(object)  # S4 method for class 'MsBackend' precursorCharge(object)  # S4 method for class 'MsBackend' precursorIntensity(object)  # S4 method for class 'MsBackend' precursorMz(object)  # S4 method for class 'MsBackend' peaksData(object) <- value  # S4 method for class 'MsBackend' reset(object)  # S4 method for class 'MsBackend' rtime(object)  # S4 method for class 'MsBackend' rtime(object) <- value  # S4 method for class 'MsBackend' scanIndex(object)  # S4 method for class 'MsBackend' selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for class 'MsBackend' smoothed(object)  # S4 method for class 'MsBackend' smoothed(object) <- value  # S4 method for class 'MsBackend' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackend' spectraData(object) <- value  # S4 method for class 'MsBackend' spectraNames(object)  # S4 method for class 'MsBackend' spectraNames(object) <- value  # S4 method for class 'MsBackend' spectraVariables(object)  # S4 method for class 'MsBackend,ANY' split(x, f, drop = FALSE, ...)  # S4 method for class 'MsBackend' supportsSetBackend(object, ...)  # S4 method for class 'MsBackend' tic(object, initial = TRUE)  # S4 method for class 'MsBackend' x[i, j, ..., drop = FALSE]  # S4 method for class 'MsBackend' x$name  # S4 method for class 'MsBackend' x$name <- value  # S4 method for class 'MsBackend' x[[i, j, ...]]  # S4 method for class 'MsBackend' x[[i, j, ...]] <- value  # S4 method for class 'MsBackend' uniqueMsLevels(object, ...)  # S4 method for class 'MsBackend' dataStorageBasePath(object)  # S4 method for class 'MsBackend' dataStorageBasePath(object) <- value  MsBackendDataFrame()  # S4 method for class 'MsBackendDataFrame' backendInitialize(object, data, peaksVariables = c(\"mz\", \"intensity\"), ...)  MsBackendHdf5Peaks()  MsBackendMemory()  # S4 method for class 'MsBackendMemory' backendInitialize(object, data, peaksVariables = c(\"mz\", \"intensity\"), ...)  MsBackendMzR()"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mass spectrometry data backends — MsBackend","text":"object Object extending MsBackend. BPPARAM backendBpparam(): parameter object BiocParallel package defining parallel processing setup. Defaults BPPARAM = bpparam(). See bpparam() information. ... Additional arguments. columns spectraData() accessor: optional character column names (spectra variables) included returned DataFrame. default, columns returned. peaksData() accessor: optional character requested columns individual matrix returned list. Defaults peaksVariables(object) depends peaks variables backend provides. value replacement value <- methods. See individual method description expected data type. n filterAcquisitionNum(): integer acquisition numbers filter . file filterFile(): index name file(s) data subsetted. export(): character length 1 equal number spectra. dataOrigin filterDataOrigin(): character define spectra keep. filterAcquisitionNum(): optionally specify filtering occur spectra selected dataOrigin. dataStorage filterDataStorage(): character define spectra keep. filterAcquisitionNum(): optionally specify filtering occur spectra selected dataStorage. mz filterIsolationWindow(): numeric(1) m/z value filter object. filterPrecursorMzRange(): numeric(2) lower upper m/z boundary. filterPrecursorMzValues(): numeric m/z value(s) filter object. msLevel integer defining MS level spectra function applied. filterMsLevel(): MS level object subsetted. polarity filterPolarity(): integer specifying polarity subset object. ppm filterPrecursorMzValues(): numeric(1) m/z-relative maximal acceptable difference m/z considered matching. See closest() details. filterValues(): numeric length allowing define maximal accepted difference user input values spectraVariables values.  equal length value provided parameter spectraVariables, ppm[1] recycled. tolerance filterPrecursorMzValues(): numeric(1) maximal absolute acceptable difference m/z value considered matching. See closest() details. filterValues(): numeric accepted tolerance values spectra variables. Defaults tolerance = 0. equal length value provided parameter spectraVariables, tolerance[1] recycled. z filterPrecursorCharge(): integer() precursor charges used filter. acquisitionNum filterPrecursorScan(): integer acquisition number spectra object subsetted. f factor defining grouping split x. See split(). filterPrecursorScan(): factor defining original data files spectra derive avoid selecting spectra different samples/files. Defaults f = dataOrigin(object). spectraVariables selectSpectraVariables(): character names spectra variables backend subsetted. filterRanges() filterValues(): character vector specifying column(s) spectraData(object) filter data correspond names spectra variables used filtering. ranges filterRanges(): numeric vector paired values (upper lower boundary) define ranges filter object. paired values need order spectraVariables parameter (see ). match filterRanges() filterValues(): character(1)  defining whether condition match provided ranges/values (match = \"\"; default), (match = \"\") spectra retained. rt filterRt(): numeric(2) defining retention time range used subset/filter object. msLevel. msLevel . values filterValues(): numeric vector define values filter object. values needs length parameter spectraVariables order. x Object extending MsBackend. use.names lengths(): whether spectrum names used. drop [: considered. initial tic(): logical(1) whether initially reported total ion current reported, whether total ion current (re)calculated actual data (initial = FALSE). [: integer, logical character subset object. j [: supported. name $ $<-: name spectra variable return set. data backendInitialize(): DataFrame spectrum metadata/data. parameter can empty MsBackendMzR backends needs provided MsBackendDataFrame backends. peaksVariables backendInitialize() MsBackendMemory: character specifying columns provided data contain peaks variables (.e. information individual mass peaks). Defaults peaksVariables = c(\"mz\", \"intensity\"). \"mz\" \"intensity\" always specified.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mass spectrometry data backends — MsBackend","text":"See documentation respective function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Mass spectrometry data backends — MsBackend","text":"Backends extending MsBackend must implement methods (listed ). Developers new MsBackends follow MsBackendMemory implementation. ensure new implementation conform MsBackend definition, developers included test suites provided package unit test setup. variable created package's \"testthat.R\" file represents (initialized) instance developed backend. path test suites defined test_suite <- system.file(\"test_backends\", \"test_MsBackend\", package = \"Spectra\") followed test_dir(test_suite) run test files directory. Individual unit test files run test_file(file.path(test_suite, \"test_spectra_variables.R\"), stop_on_failure = TRUE) (note without stop_on_failure = TRUE tests fail silently) . Adding code packages \"testthat.R\" file ensures tests checking validity MsBackend instance defined Spectra package also run newly develped backend class. MsBackend defines following slots: @readonly: logical(1) whether backend supports writing/replacing m/z intensity values. Backends extending MsBackend must implement methods (listed ). Developers new MsBackends follow MsBackendDataFrame implementation. MsBackendCached() backend provides caching mechanism allow read backends add change spectra variables. backend used , meant extended. See MsBackendCached() details. MsBackend defines following slots: @readonly: logical(1) whether backend supports writing/replacing m/z intensity values.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"backend-functions","dir":"Reference","previous_headings":"","what":"Backend functions","title":"Mass spectrometry data backends — MsBackend","text":"New backend classes must extend base MsBackend class implement following methods (see MsBackend vignette detailed description examples): [: subset backend. subsetting element (row/) allowed. Parameter support integer indices logical throw error bounds. MsCoreUtils::i2index used check input . = integer() empty backend returned. $, $<-: access set/add single spectrum variable (column) backend. Using value NULL allow deleting specified spectra variable. error thrown spectra variable available. [[, [[<-: access set/add single spectrum variable (column) backend. default implementation uses $, thus methods implemented new classes extending MsBackend. acquisitionNum(): returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). backendBpparam(): return parallel processing setup supported backend class. function can used higher level function evaluate whether provided parallel processing setup (default one returned bpparam()) supported backend. Backends supporting parallel processing (e.g. contain connection database can shared across processes) extend method return SerialParam() hence disable parallel processing () methods functions. See also backendParallelFactor() function provide preferred splitting backend parallel processing. backendInitialize(): initialises backend. method supposed called rights creating instance backend class prepare backend (e.g. set data memory backend read spectra header data MsBackendMzR backend). Parameters can defined freely backend, depending needed initialize backend. however suggested also support parameter data can used submit full spectra data DataFrame backend. allow backend also usable setBackend() function Spectra. Note eventually (read-backends) also supportsSetBackend method need implemented return TRUE. backendInitialize() method also ensure correctly set spectra variable dataStorage. backendMerge(): merges (combines) MsBackend objects single instance. objects merged type (e.g. MsBackendDataFrame()). backendParallelFactor(): returns factor defining optimal (preferred) way backend can split parallel processing used peak data accessor data manipulation functions. default implementation returns factor length 0 (factor()) providing thus default splitting. backendParallelFactor() MsBackendMzR hand returns factor(dataStorage(object)) hence suggesting split object data file. dataOrigin(): gets character length equal number spectra object data origin spectrum. e.g. mzML file data read. dataStorage(): gets character length equal number spectra object data storage spectrum. Note missing values (NA_character_) supported dataStorage. dataStorageBasePath(), dataStorageBasePath<-: gets sets common *base* path directory containing data files. supported, function expected return (accept) characterof length 1. backends (example theMsBackendMemorywill support function anddataStorageBasePath()returnNA_character_. MsBackendMzR, function allows get change path directory containing original data files, required e.g. serialized MsBackendMzR` instance gets copied another computer file system. dropNaSpectraVariables(): removes spectra variables (.e. columns object's spectraData contain missing values (NA). Note columns NAs removed, spectraData() call dropNaSpectraVariables() might still show columns containing NA values core spectra variables. centroided(), centroided<-: gets sets centroiding information spectra. centroided() returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided() estimating spectrum data whether spectrum centroided.  value centroided<- either single logical logical length equal number spectra object. collisionEnergy(), collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy() returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. export(): exports data Spectra class file. method called export,Spectra method passes second argument function. export,MsBackend implementation thus expected take Spectra class second argument data exported. Taking data Spectra class ensures also eventual data manipulations (cached Spectra's lazy evaluation queue) applied prior export - possible MsBackend class. example implementation export() method MsBackendMzR backend supports export data mzML mzXML format. See documentation MsBackendMzR class information. filterAcquisitionNum(): filters object keeping spectra matching provided acquisition numbers (argument n). dataOrigin dataStorage also provided, object subsetted spectra acquisition number equal n spectra matching dataOrigin dataStorage values retaining spectra. filterDataOrigin(): filters object retaining spectra matching provided dataOrigin. Parameter dataOrigin type character needs match exactly data origin value spectra subset. filterDataOrigin() return data ordered provided dataOrigin parameter, .e. dataOrigin = c(\"2\", \"1\") provided, spectra resulting object ordered accordingly (first spectra data origin \"2\" \"1\"). Implementation method optional since default implementation MsBackend available. filterDataStorage(): filters object retaining spectra matching provided dataStorage. Parameter dataStorage type character needs match exactly data storage value spectra subset. filterDataStorage() return data ordered provided dataStorage parameter, .e. dataStorage = c(\"2\", \"1\") provided, spectra resulting object ordered accordingly (first spectra data storage \"2\" \"1\"). Implementation method optional since default implementation MsBackend available. filterEmptySpectra(): removes empty spectra (.e. spectra without peaks). Implementation method optional since default implementation MsBackend available. filterFile(): retains data files matching file index file name provided parameter file. filterIsolationWindow(): retains spectra contain mz isolation window m/z range (.e. isolationWindowLowerMz <= mz isolationWindowUpperMz >= mz. Implementation method optional since default implementation MsBackend available. filterMsLevel(): retains spectra MS level msLevel. Implementation method optional since default implementation MsBackend available. filterPolarity(): retains spectra polarity polarity. Implementation method optional since default implementation MsBackend available. filterPrecursorMzRange() (previously filterPrecursorMz): retains spectra precursor m/z within provided m/z range. Implementation method optional since default implementation MsBackend available. filterPrecursorMzValues(): retains spectra precursor m/z matching provided m/z values (given ppm tolerance). Implementation method optional since default implementation MsBackend available. filterPrecursorCharge(): retains spectra defined precursor charge(s). Implementation method optional since default implementation MsBackend available. filterPrecursorScan(): retains parent (e.g. MS1) children scans (e.g. MS2) acquisition number acquisitionNum. Parameter f supposed define origin spectra (.e. original data file) ensure related spectra file/sample selected retained. Implementation method optional since default implementation MsBackend available. filterRanges(): allows filtering Spectra object based user defined numeric ranges (parameter ranges) one available spectra variables object (spectra variable names can specified parameter spectraVariables). Spectra value spectra variable within defined range retained. multiple ranges/spectra variables defined, match parameter can used specify whether conditions (match = \"\"; default) conditions must match (match = \"\"; spectra values within provided ranges retained). Implementation method optional since default implementation MsBackend available. filterRt(): retains spectra MS level msLevel retention times within (>=) rt[1] (<=) rt[2]. Implementation method optional since default implementation MsBackend available. filterValues(): allows filtering Spectra object based similarities numeric values one spectraVariables(object) (parameter spectraVariables) provided values (parameter values) given acceptable differences (parameters tolerance ppm). multiple values/spectra variables defined, match parameter can used specify whether conditions (match = \"\"; default) conditions must match (match = \"\"; spectra values within provided ranges retained). Implementation method optional since default implementation MsBackend available. intensity(): gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. intensity<-: replaces intensity values. value list (NumericList()) length equal number spectra number values within list element identical number peaks spectrum (.e. lengths(x)). Note just writeable backends support method. ionCount(): returns numeric sum intensities spectrum. spectrum empty (see isEmpty()), NA_real_ returned. isCentroided(): heuristic approach assessing spectra object profile centroided mode. function takes qtl th quantile top peaks, calculates difference adjacent m/z value returns TRUE first quartile greater k. (See Spectra:::.peaks_is_centroided code.) isEmpty(): checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz(), isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz(), isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz(), isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. isReadOnly(): returns logical(1) whether backend read allow also write/update data. length(): returns number spectra object. lengths(): gets number peaks (m/z-intensity values) per spectrum.  Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel(): gets spectra's MS level. Returns integer vector (length equal number spectra) MS level spectrum (NA_integer_ available). mz(): gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. mz<-: replaces m/z values. value list length equal number spectra number values within list element identical number peaks spectrum (.e. lengths(x)). Note just writeable backends support method. polarity(), polarity<-: gets sets polarity spectrum.  polarity() returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge(), precursorIntensity(), precursorMz(), precScanNum(), precAcquisitionNum(): get charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. peaksData() returns list spectras' peak data, .e. m/z intensity values peak variables. length list equal number spectra object. element list two-dimensional array (matrix data.frame) columns depending provided columns parameter (default \"mz\" \"intensity\", depends backend's available peaksVariables). empty spectrum, matrix (data.frame) 0 rows columns according columns returned. optional parameter columns, supported backend, allows define peak variables returned numeric peak matrix. default c(\"mz\", \"intensity\") used. peaksData<- replaces peak data (m/z intensity values) backend. method expects list two dimensional arrays (matrix data.frame) columns representing peak variables. existing peaks data expected replaced new values. length list match number spectra object. Note writeable backends need support method. peaksVariables(): lists available variables mass peaks. Default peak variables \"mz\" \"intensity\" (backends need support provide), backends might provide additional variables. variables expected returned (requested) peaksData() function. reset() backend (supported). method called backend reset,Spectra method supposed restore data original state (see reset,Spectra details). function returns reset backend. default implementation MsBackend returns backend -. rtime(), rtime<-: gets sets retention times spectrum (seconds). rtime() returns numeric vector (length equal number spectra) retention time spectrum. rtime<- expects numeric vector length equal number spectra. scanIndex(): returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum() spectrum index spectrum reported mzML file. selectSpectraVariables(): reduces information within backend selected spectra variables. suggested remove values \"dataStorage\" variable, since might required backends work properly (MsBackendMzR). smoothed(),smoothed<-: gets sets whether spectrum smoothed. smoothed() returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraData(), spectraData<-: gets sets general spectrum metadata (annotation, also called header).  spectraData() returns DataFrame, spectraData<- expects DataFrame number rows spectra object. Note spectraData() return full data, .e. also m/z intensity values (list SimpleList columns \"mz\" \"intensity\". spectraNames(): returns character vector names spectra object NULL set. spectraNames<- allows set spectra names (object read-). spectraVariables(): returns character vector available spectra variables (columns, fields attributes) available object. return spectra variables present object, also \"mz\" \"intensity\" (default returned spectraVariables,Spectra method). split(): splits backend list backends (depending parameter f). default method MsBackend uses split.default(), thus backends extending MsBackend necessarily need implement method. supportsSetBackend(): whether MsBackend supports Spectra setBackend() function. MsBackend support setBackend() needs parameter called data backendInitialize() method support receiving spectra data DataFrame another backend initialize backend data. general read-backends support setBackend() hence, default implementation supportsSetBackend() returns !isReadOnly(object). read-backend support setBackend() initialized DataFrame implementation method backend defined returns TRUE (see also MsBackend vignette details examples). tic(): gets total ion current/count (sum signal spectrum) spectra object. default, value reported original raw data file returned. empty spectrum, NA_real_ returned. uniqueMsLevels(): gets unique MS levels spectra object. default implementation calls unique(msLevel(object)) efficient implementations defined specific backends.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"subsetting-and-merging-backend-classes","dir":"Reference","previous_headings":"","what":"Subsetting and merging backend classes","title":"Mass spectrometry data backends — MsBackend","text":"Backend classes must support (implement) [ method subset object. method support subsetting spectra (rows, ) return MsBackend class. Backends extending MsBackend also implement backendMerge() method support combining backend instances (backend classes type merged). Merging follow following rules: whole spectrum data various objects merged. resulting merged object contain union individual objects' spectra variables (columns/fields), eventually missing variables one object filled NA.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"in-memory-data-backends","dir":"Reference","previous_headings":"","what":"In-memory data backends","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendMemory MsBackendDataFrame: MsBackendMemory MsBackendDataFrame objects keep MS data memory thus ideal fast data processing. Due large memory footprint however suited large scale experiments. two backends store data different. MsBackendDataFrame stores data DataFrame thus supports also S4-classes spectra variables. Also, sepratate access m/z intensity values (.e. using mz() intensity() methods) faster MsBackendDataFrame. MsBackendMemory hand, due way data organized internally, provides much faster access full peak data (.e. numerical matrices m/z intensity values). Also subsetting access spectra variable (except \"mz\" \"intensity\") fastest MsBackendMemory. Thus, use cases, MsBackendMemory provides higher performance flexibility MsBackendDataFrame thus preferred. See also issue 246 performance comparison. New objects can created MsBackendMemory() MsBackendDataFrame() function, respectively. backends can subsequently initialized backendInitialize() method, taking DataFrame (data.frame) (full) MS data first parameter data. second parameter peaksVariables allows define columns data contain peak variables m/z intensity values individual peaks per spectrum. default parameter peaksVariables = c(\"mz\", \"intensity\"). Note supported provide either \"mz\" \"intensity\", provided, need present data frame. Alternatively, function also supports data frame without m/z intensity values, case Spectra without mass peaks created. Suggested columns DataFrame : \"msLevel\": integer MS levels spectra. \"rt\": numeric retention times spectra. \"acquisitionNum\": integer acquisition number spectrum. \"scanIndex\": integer index scan/spectrum within mzML/mzXML/CDF file. \"dataOrigin\": character defining data origin. \"dataStorage\": character indicating grouping spectra different e.g. input files. Note missing values supported. \"centroided\": logical whether spectrum centroided. \"smoothed\": logical whether spectrum smoothed. \"polarity\": integer polarity information spectra. \"precScanNum\": integer specifying index (MS1) spectrum containing precursor (MS2) spectrum. \"precursorMz\": numeric m/z value precursor. \"precursorIntensity\": numeric intensity value precursor. \"precursorCharge\": integer charge precursor. \"collisionEnergy\": numeric collision energy. \"mz\": NumericList() numeric vectors representing m/z values spectrum. \"intensity\": NumericList() numeric vectors representing intensity values spectrum. Additional columns allowed . peaksData() function MsBackendMemory MsBackendDataFrame returns list numeric matrix default (parameter columns = c(\"mz\", \"intensity\")). peak variables requested, list data.frame returned (ensuring m/z intensity values always numeric).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"msbackendmzr-on-disk-ms-data-backend","dir":"Reference","previous_headings":"","what":"MsBackendMzR, on-disk MS data backend","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendMzR keeps limited amount data memory, spectra data (m/z intensity values) fetched raw files -demand. backend uses mzR package data import retrieval hence requires package installed. Also, can used import represent data stored mzML, mzXML CDF files. MsBackendMzR backend extends MsBackendDataFrame backend using DataFrame keep spectra variables (except m/z intensity) memory. New objects can created MsBackendMzR() function can subsequently filled data calling backendInitialize() passing file names input data files argument files. backend provides export() method export data Spectra mzML mzXML format. definition function : export(object, x, file = tempfile(), format = c(\"mzML\", \"mzXML\"), copy = FALSE) parameters : object: instance MsBackendMzR class. x: Spectra object exported. file: character (full) output file name(s). length 1 equal length(x). single file specified, spectra exported file. Alternatively possible specify spectrum x name file exported (hence file length equal length(x)). format: character(1), either \"mzML\" \"mzXML\" defining output file format. copy: logical(1) whether general file information copied original MS data files. works x uses MsBackendMzR backend dataOrigin(x) contains original MS data file names. BPPARAM: parallel processing settings. See examples Spectra vignette details examples. MsBackendMzR ignores parameter columns peaksData() function returns always m/z intensity values.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"msbackendhdf-peaks-on-disk-ms-data-backend","dir":"Reference","previous_headings":"","what":"MsBackendHdf5Peaks, on-disk MS data backend","title":"Mass spectrometry data backends — MsBackend","text":"MsBackendHdf5Peaks keeps, similar MsBackendMzR, peak data (.e. m/z intensity values) custom data files (HDF5 format) disk remaining spectra variables kept memory. backend supports updating writing manipulated peak data data files. New objects can created MsBackendHdf5Peaks() function can subsequently filled data calling object's backendInitialize() method passing desired file names HDF5 data files along spectra variables form DataFrame (see MsBackendDataFrame expected format). optional parameter hdf5path allows specify folder HDF5 data files stored . provided, added path submitted file names (parameter files). default backendInitialize() store peak data single HDF5 file name provided parameter files. store peak data across several HDF5 files data contain column \"dataStorage\" defines grouping spectra/peaks files: peaks spectra value \"dataStorage\" saved HDF5 file. parameter files omitted, value dataStorage used file name (replacing file ending \".h5\". specify file names, files' length match number unique elements \"dataStorage\". details see examples Spectra() help page. MsBackendHdf5Peaks ignores parameter columns peaksData() function returns always m/z intensity values.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mass spectrometry data backends — MsBackend","text":"Johannes Rainer, Sebastian Gibb, Laurent Gatto, Philippine Louail","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mass spectrometry data backends — MsBackend","text":"","code":"## The MsBackend class is a virtual class and can not be instantiated ## directly. Below we define a new backend class extending this virtual ## class MsBackendDummy <- setClass(\"MsBackendDummy\", contains = \"MsBackend\") MsBackendDummy() #> An object of class \"MsBackendDummy\" #> Slot \"readonly\": #> [1] FALSE #>  #> Slot \"version\": #> [1] \"0.1\" #>   ## This class inherits now all methods from `MsBackend`, all of which ## however throw an error. These methods would have to be implemented ## for the new backend class. try(mz(MsBackendDummy())) #> Error in .local(object, ...) : Not implemented for MsBackendDummy.  ## See `MsBackendDataFrame` as a reference implementation for a backend ## class (in the *R/MsBackendDataFrame.R* file).  ## MsBackendDataFrame ## ## The `MsBackendDataFrame` uses a `S4Vectors::DataFrame` to store all MS ## data. Below we create such a backend by passing a `DataFrame` with all ## data to it. data <- DataFrame(msLevel = c(1L, 2L, 1L), scanIndex = 1:3) data$mz <- list(c(1.1, 1.2, 1.3), c(1.4, 54.2, 56.4, 122.1), c(15.3, 23.2)) data$intensity <- list(c(3, 2, 3), c(45, 100, 12.2, 1), c(123, 12324.2))  ## Backends are supposed to be created with their specific constructor ## function be <- MsBackendDataFrame()  be #> MsBackendDataFrame with 0 spectra  ## The `backendInitialize()` method initializes the backend filling it with ## data. This method can take any parameters needed for the backend to ## get loaded with the data (e.g. a file name from which to load the data, ## a database connection or, in this case, a data frame containing the data). be <- backendInitialize(be, data)  be #> MsBackendDataFrame with 3 spectra #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1        NA         1 #> 2         2        NA         2 #> 3         1        NA         3 #>  ... 16 more variables/columns.  ## Data can be accessed with the accessor methods msLevel(be) #> [1] 1 2 1  mz(be) #> NumericList of length 3 #> [[1]] 1.1 1.2 1.3 #> [[2]] 1.4 54.2 56.4 122.1 #> [[3]] 15.3 23.2  ## Even if no data was provided for all spectra variables, its accessor ## methods are supposed to return a value. precursorMz(be) #> [1] NA NA NA  ## The `peaksData()` method is supposed to return the peaks of the spectra as ## a `list`. peaksData(be) #> [[1]] #>       mz intensity #> [1,] 1.1         3 #> [2,] 1.2         2 #> [3,] 1.3         3 #>  #> [[2]] #>         mz intensity #> [1,]   1.4      45.0 #> [2,]  54.2     100.0 #> [3,]  56.4      12.2 #> [4,] 122.1       1.0 #>  #> [[3]] #>        mz intensity #> [1,] 15.3     123.0 #> [2,] 23.2   12324.2 #>   ## List available peaks variables peaksVariables(be) #> [1] \"mz\"        \"intensity\"  ## Use columns to extract specific peaks variables. Below we extract m/z and ## intensity values, but in reversed order to the default. peaksData(be, columns = c(\"intensity\", \"mz\")) #> [[1]] #>      intensity  mz #> [1,]         3 1.1 #> [2,]         2 1.2 #> [3,]         3 1.3 #>  #> [[2]] #>      intensity    mz #> [1,]      45.0   1.4 #> [2,]     100.0  54.2 #> [3,]      12.2  56.4 #> [4,]       1.0 122.1 #>  #> [[3]] #>      intensity   mz #> [1,]     123.0 15.3 #> [2,]   12324.2 23.2 #>   ## List available spectra variables (i.e. spectrum metadata) spectraVariables(be) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"mz\"                      \"intensity\"               #>  [7] \"dataStorage\"             \"dataOrigin\"              #>  [9] \"centroided\"              \"smoothed\"                #> [11] \"polarity\"                \"precScanNum\"             #> [13] \"precursorMz\"             \"precursorIntensity\"      #> [15] \"precursorCharge\"         \"collisionEnergy\"         #> [17] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [19] \"isolationWindowUpperMz\"   ## Extract precursor m/z, rtime, MS level spectra variables spectraData(be, c(\"precursorMz\", \"rtime\", \"msLevel\")) #> DataFrame with 3 rows and 3 columns #>   precursorMz     rtime   msLevel #>     <numeric> <numeric> <integer> #> 1          NA        NA         1 #> 2          NA        NA         2 #> 3          NA        NA         1  ## MsBackendMemory ## ## The `MsBackendMemory` uses a more efficient internal data organization ## and allows also adding arbitrary additional peaks variables (annotations) ## Below we thus add a column \"peak_ann\" with arbitrary names/ids for each ## peak and add the name of this column to the `peaksVariables` parameter ## of the `backendInitialize()` method (in addition to `\"mz\"` and ## `\"intensity\"` that should **always** be specified. data$peak_ann <- list(c(\"a\", \"\", \"d\"), c(\"\", \"d\", \"e\", \"f\"), c(\"h\", \"i\")) be <- backendInitialize(MsBackendMemory(), data,     peaksVariables = c(\"mz\", \"intensity\", \"peak_ann\")) be #> MsBackendMemory with 3 spectra #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1        NA         1 #> 2         2        NA         2 #> 3         1        NA         3 #>  ... 17 more variables/columns.  spectraVariables(be) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"mz\"                      \"intensity\"               #>  [7] \"dataStorage\"             \"dataOrigin\"              #>  [9] \"centroided\"              \"smoothed\"                #> [11] \"polarity\"                \"precScanNum\"             #> [13] \"precursorMz\"             \"precursorIntensity\"      #> [15] \"precursorCharge\"         \"collisionEnergy\"         #> [17] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [19] \"isolationWindowUpperMz\"  \"peak_ann\"                 ## peak_ann is also listed as a peaks variable peaksVariables(be) #> [1] \"mz\"        \"intensity\" \"peak_ann\"   ## The additional peaks variable can be accessed using the `peaksData()` ## function peaksData(be, \"peak_ann\") #> [[1]] #>   peak_ann #> 1        a #> 2          #> 3        d #>  #> [[2]] #>   peak_ann #> 1          #> 2        d #> 3        e #> 4        f #>  #> [[3]] #>   peak_ann #> 1        h #> 2        i #>   ## The $<- method can be used to replace values of an existing peaks ## variable. It is important that the number of elements matches the ## number of peaks per spectrum. be$peak_ann <- list(1:3, 1:4, 1:2)  ## A peaks variable can again be removed by setting it to NULL be$peak_ann <- NULL  peaksVariables(be) #> [1] \"mz\"        \"intensity\""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":null,"dir":"Reference","previous_headings":"","what":"Base MsBackend class providing data caching mechanism — MsBackendCached","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"MsBackendCached class rudimentary implementation MsBackend providing simple mechanism cache spectra data locally. class thought used base class MsBackend implementations reuse caching mechanism avoid re-implement commonly used methods. class thus thought used directly user. MsBackendCached caching mechanism allows MsBackend instances add replace spectra variables even backend used allow alter values (e.g. SQL database used backend). replacement operation $<- add specified values local data.frame within MsBackendCached class allows cache values (increasing obviously memory demand object). data accessor functions extending MsBackend class ($ msLevel() spectraData()) first use callNextMethod() call respective accessor MsBackendCached evaluate requested spectra variable(s) local cache return . requested spectra variables neither local cache, listed @spectraVariables slot (defines spectra variables can requested extending MsBackend class) core spectra variables missing values correct data type returned.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"","code":"MsBackendCached()  # S4 method for class 'MsBackendCached' backendInitialize(   object,   data = data.frame(),   nspectra = 0L,   spectraVariables = character(),   ... )  # S4 method for class 'MsBackendCached' dataStorage(object)  # S4 method for class 'MsBackendCached' length(x)  # S4 method for class 'MsBackendCached' spectraVariables(object)  # S4 method for class 'MsBackendCached' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackendCached' spectraData(object) <- value  # S4 method for class 'MsBackendCached' x[i, j, ..., drop = FALSE]  # S4 method for class 'MsBackendCached' x$name  # S4 method for class 'MsBackendCached' x$name <- value  # S4 method for class 'MsBackendCached' selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for class 'MsBackendCached' show(object)  # S4 method for class 'MsBackendCached' acquisitionNum(object)  # S4 method for class 'MsBackendCached' centroided(object)  # S4 method for class 'MsBackendCached' centroided(object) <- value  # S4 method for class 'MsBackendCached' collisionEnergy(object)  # S4 method for class 'MsBackendCached' collisionEnergy(object) <- value  # S4 method for class 'MsBackendCached' dataOrigin(object)  # S4 method for class 'MsBackendCached' dataOrigin(object) <- value  # S4 method for class 'MsBackendCached' msLevel(object)  # S4 method for class 'MsBackendCached' intensity(object)  # S4 method for class 'MsBackendCached' ionCount(object)  # S4 method for class 'MsBackendCached' isEmpty(x)  # S4 method for class 'MsBackendCached' isolationWindowLowerMz(object)  # S4 method for class 'MsBackendCached' isolationWindowLowerMz(object) <- value  # S4 method for class 'MsBackendCached' isolationWindowTargetMz(object)  # S4 method for class 'MsBackendCached' isolationWindowTargetMz(object) <- value  # S4 method for class 'MsBackendCached' isolationWindowUpperMz(object)  # S4 method for class 'MsBackendCached' isolationWindowUpperMz(object) <- value  # S4 method for class 'MsBackendCached' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackendCached' mz(object)  # S4 method for class 'MsBackendCached' polarity(object)  # S4 method for class 'MsBackendCached' polarity(object) <- value  # S4 method for class 'MsBackendCached' precursorCharge(object)  # S4 method for class 'MsBackendCached' precursorIntensity(object)  # S4 method for class 'MsBackendCached' precursorMz(object)  # S4 method for class 'MsBackendCached' rtime(object)  # S4 method for class 'MsBackendCached' rtime(object) <- value  # S4 method for class 'MsBackendCached' scanIndex(object)  # S4 method for class 'MsBackendCached' smoothed(object)  # S4 method for class 'MsBackendCached' smoothed(object) <- value"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"object MsBackendCached object. data backendInitialize(): (optional) data.frame cached values. number rows (order) match number spectra. nspectra backendInitialize(): integer number spectra. spectraVariables backendInitialize(): character names spectra variables provided extending backend. selectSpectraVariables(): character specifying spectra variables keep. ... ignored x MsBackendCached object. columns spectraData(): character names spectra variables retrieve. value replacement value <- methods. See individual method description expected data type. [: integer indices subset object. j [: ignored. drop [: considered. name $<-: name spectra variable set. use.names lengths(): whether spectrum names used.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"See documentation respective function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"Classes extending MsBackendCached need call backendInitialize() method class backendInitialize() method set least number spectra nspectra parameter spectraVariables available (extending) backend class. implement spectraData() method also calls spectraData() method MsBackendCached also retrieve cached values (e.g. using res <- callNextMethod() beginning spectraData function). spectraData,MsBackendCached method return NULL selected spectra variables cached core spectra variables provided extending backend. Thus, extending backend can proceed retrieve respective values backend/data storage. implement eventually [ method calls addition [ MsBackendCached. methods accessing setting spectra variables need implemented extending backend class (default implementations MsBackendCached used instead; ensure cached values returned first). Spectra variables can modified added using $<- method MsBackendCached. Replacing adding multiple variables using spectraData<- supported MsBackendCached. extending backend might however implement method internally uses $<- add/replace single variables. MsBackendCached following slots: nspectra: integer(1) defining number spectra backend. variable needs set must match number rows localData actual number spectra (extending) backend. localData: data.frame cached local data. replacement operation $<- set/add column respective values. spectraVariables: character defining spectra variables provided extending MsBackend class (e.g. spectra variables can retrieved data base original data files).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"available-methods","dir":"Reference","previous_headings":"","what":"Available methods","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"acquisitionNum(): returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). backendInitialize(): initializes backend. method takes parameters data (data.frame cached data), nspectra (integer defining number spectra) spectraVariables (character spectra variables provided extending backend. centroided(), centroided<-: gets sets centroiding information spectra. centroided returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided estimating spectrum data whether spectrum centroided.  value centroided<- either single logical logical length equal number spectra object. collisionEnergy(), collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy() returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. dataOrigin(): gets character length equal number spectra object data origin spectrum. e.g. mzML file data read. intensity(): gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. ionCount(): returns numeric sum intensities spectrum. spectrum empty (see isEmpty()), NA_real_ returned. isEmpty(): checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz(), isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz(), isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz(), isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. length(): returns number spectra (.e. @nspectra). lengths(): gets number peaks (m/z-intensity values) per spectrum.  Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel(): gets spectra's MS level. Returns integer vector (length equal number spectra) MS level spectrum (NA_integer_ available). mz(): gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. polarity(), polarity<-: gets sets polarity spectrum.  polarity returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge(), precursorIntensity(), precursorMz(), precScanNum(), precAcquisitionNum(): get charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. rtime(), rtime<-: gets sets retention times spectrum (seconds). rtime() returns numeric vector (length equal number spectra) retention time spectrum. rtime<- expects numeric vector length equal number spectra. scanIndex(): returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum() spectrum index spectrum reported mzML file. selectSpectraVariables(): subset object specified spectra variables. eventually remove spectra variables listed @spectraVariables also drop columns local cache among spectraVariables. smoothed(),smoothed<-: gets sets whether spectrum smoothed. smoothed() returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraVariables(): returns available spectra variables, .e. unique set core spectra variables, cached spectra variables spectra variables defined @spectraVariables slot (.e. spectra variables thought provided extending MsBackend instance). spectraData(): returns DataFrame cached spectra variablers initialized core spectra variables. Parameter spectraVariables allows specify variables retrieve. function returns NULL requested variables cached provided extending backend. Note method returns cached spectra variables core spectra variables provided extending backend. responsibility extending backend add/provide . [: subsets cached data. Parameter needs integer vector. $, $<-: access set/add single spectrum variable (column) backend.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/reference/MsBackendCached.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Base MsBackend class providing data caching mechanism — MsBackendCached","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":null,"dir":"Reference","previous_headings":"","what":"The Spectra class to manage and access MS data — applyProcessing","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra class encapsules spectral mass spectrometry data related metadata. supports multiple data backends, e.g. -memory (MsBackendMemory, MsBackendDataFrame()), -disk mzML (MsBackendMzR()) HDF5 (MsBackendHdf5Peaks()).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Spectra class to manage and access MS data — applyProcessing","text":"","code":"applyProcessing(   object,   f = processingChunkFactor(object),   BPPARAM = bpparam(),   ... )  concatenateSpectra(x, ...)  combineSpectra(   x,   f = x$dataStorage,   p = x$dataStorage,   FUN = combinePeaksData,   ...,   BPPARAM = bpparam() )  joinSpectraData(x, y, by.x = \"spectrumId\", by.y, suffix.y = \".y\")  processingLog(x)  deisotopeSpectra(   x,   substDefinition = isotopicSubstitutionMatrix(\"HMDB_NEUTRAL\"),   tolerance = 0,   ppm = 20,   charge = 1 )  reduceSpectra(x, tolerance = 0, ppm = 20)  filterPrecursorMaxIntensity(x, tolerance = 0, ppm = 20)  filterPrecursorIsotopes(   x,   tolerance = 0,   ppm = 20,   substDefinition = isotopicSubstitutionMatrix(\"HMDB_NEUTRAL\") )  scalePeaks(x, by = sum, msLevel. = uniqueMsLevels(x))  filterPrecursorPeaks(   object,   tolerance = 0,   ppm = 20,   mz = c(\"==\", \">=\"),   msLevel. = uniqueMsLevels(object) )  # S4 method for class 'missing' Spectra(   object,   processingQueue = list(),   metadata = list(),   ...,   backend = MsBackendMemory(),   BPPARAM = bpparam() )  # S4 method for class 'MsBackend' Spectra(   object,   processingQueue = list(),   metadata = list(),   ...,   BPPARAM = bpparam() )  # S4 method for class 'character' Spectra(   object,   processingQueue = list(),   metadata = list(),   source = MsBackendMzR(),   backend = source,   ...,   BPPARAM = bpparam() )  # S4 method for class 'ANY' Spectra(   object,   processingQueue = list(),   metadata = list(),   source = MsBackendMemory(),   backend = source,   ...,   BPPARAM = bpparam() )  # S4 method for class 'Spectra,MsBackend' setBackend(   object,   backend,   f = processingChunkFactor(object),   ...,   BPPARAM = bpparam() )  # S4 method for class 'Spectra' c(x, ...)  # S4 method for class 'Spectra,ANY' split(x, f, drop = FALSE, ...)  # S4 method for class 'Spectra' export(object, backend, ...)  # S4 method for class 'Spectra' acquisitionNum(object)  # S4 method for class 'Spectra' peaksData(   object,   columns = c(\"mz\", \"intensity\"),   f = processingChunkFactor(object),   ...,   BPPARAM = bpparam() )  # S4 method for class 'Spectra' peaksVariables(object)  # S4 method for class 'Spectra' centroided(object)  # S4 method for class 'Spectra' centroided(object) <- value  # S4 method for class 'Spectra' collisionEnergy(object)  # S4 method for class 'Spectra' collisionEnergy(object) <- value  # S4 method for class 'Spectra' dataOrigin(object)  # S4 method for class 'Spectra' dataOrigin(object) <- value  # S4 method for class 'Spectra' dataStorage(object)  # S4 method for class 'Spectra' dropNaSpectraVariables(object)  # S4 method for class 'Spectra' intensity(object, f = processingChunkFactor(object), ...)  # S4 method for class 'Spectra' ionCount(object)  # S4 method for class 'Spectra' isCentroided(object, ...)  # S4 method for class 'Spectra' isEmpty(x)  # S4 method for class 'Spectra' isolationWindowLowerMz(object)  # S4 method for class 'Spectra' isolationWindowLowerMz(object) <- value  # S4 method for class 'Spectra' isolationWindowTargetMz(object)  # S4 method for class 'Spectra' isolationWindowTargetMz(object) <- value  # S4 method for class 'Spectra' isolationWindowUpperMz(object)  # S4 method for class 'Spectra' isolationWindowUpperMz(object) <- value  # S4 method for class 'Spectra' containsMz(   object,   mz = numeric(),   tolerance = 0,   ppm = 20,   which = c(\"any\", \"all\"),   BPPARAM = bpparam() )  # S4 method for class 'Spectra' containsNeutralLoss(   object,   neutralLoss = 0,   tolerance = 0,   ppm = 20,   BPPARAM = bpparam() )  # S4 method for class 'Spectra' spectrapply(   object,   FUN,   ...,   chunkSize = integer(),   f = factor(),   BPPARAM = SerialParam() )  # S4 method for class 'Spectra' length(x)  # S4 method for class 'Spectra' msLevel(object)  # S4 method for class 'Spectra' mz(object, f = processingChunkFactor(object), ...)  # S4 method for class 'Spectra' lengths(x, use.names = FALSE)  # S4 method for class 'Spectra' polarity(object)  # S4 method for class 'Spectra' polarity(object) <- value  # S4 method for class 'Spectra' precScanNum(object)  # S4 method for class 'Spectra' precursorCharge(object)  # S4 method for class 'Spectra' precursorIntensity(object)  # S4 method for class 'Spectra' precursorMz(object)  # S4 method for class 'Spectra' rtime(object)  # S4 method for class 'Spectra' rtime(object) <- value  # S4 method for class 'Spectra' scanIndex(object)  # S4 method for class 'Spectra' selectSpectraVariables(   object,   spectraVariables = union(spectraVariables(object), peaksVariables(object)) )  # S4 method for class 'Spectra' smoothed(object)  # S4 method for class 'Spectra' smoothed(object) <- value  # S4 method for class 'Spectra' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'Spectra' spectraData(object) <- value  # S4 method for class 'Spectra' spectraNames(object)  # S4 method for class 'Spectra' spectraNames(object) <- value  # S4 method for class 'Spectra' spectraVariables(object)  # S4 method for class 'Spectra' tic(object, initial = TRUE)  # S4 method for class 'Spectra' x$name  # S4 method for class 'Spectra' x$name <- value  # S4 method for class 'Spectra' x[[i, j, ...]]  # S4 method for class 'Spectra' x[[i, j, ...]] <- value  # S4 method for class 'Spectra' x[i, j, ..., drop = FALSE]  # S4 method for class 'Spectra' filterAcquisitionNum(   object,   n = integer(),   dataStorage = character(),   dataOrigin = character() )  # S4 method for class 'Spectra' filterEmptySpectra(object)  # S4 method for class 'Spectra' filterDataOrigin(object, dataOrigin = character())  # S4 method for class 'Spectra' filterDataStorage(object, dataStorage = character())  # S4 method for class 'Spectra' filterFourierTransformArtefacts(   object,   halfWindowSize = 0.05,   threshold = 0.2,   keepIsotopes = TRUE,   maxCharge = 5,   isotopeTolerance = 0.005 )  # S4 method for class 'Spectra' filterIntensity(   object,   intensity = c(0, Inf),   msLevel. = uniqueMsLevels(object),   ... )  # S4 method for class 'Spectra' filterIsolationWindow(object, mz = numeric())  # S4 method for class 'Spectra' filterMsLevel(object, msLevel. = integer())  # S4 method for class 'Spectra' filterMzRange(   object,   mz = numeric(),   msLevel. = uniqueMsLevels(object),   keep = TRUE )  # S4 method for class 'Spectra' filterMzValues(   object,   mz = numeric(),   tolerance = 0,   ppm = 20,   msLevel. = uniqueMsLevels(object),   keep = TRUE )  # S4 method for class 'Spectra' filterPolarity(object, polarity = integer())  # S4 method for class 'Spectra' filterPrecursorMz(object, mz = numeric())  # S4 method for class 'Spectra' filterPrecursorMzRange(object, mz = numeric())  # S4 method for class 'Spectra' filterPrecursorMzValues(object, mz = numeric(), ppm = 20, tolerance = 0)  # S4 method for class 'Spectra' filterPrecursorCharge(object, z = integer())  # S4 method for class 'Spectra' filterPrecursorScan(object, acquisitionNum = integer(), f = dataOrigin(object))  # S4 method for class 'Spectra' filterRt(object, rt = numeric(), msLevel. = uniqueMsLevels(object))  # S4 method for class 'Spectra' reset(object, ...)  # S4 method for class 'Spectra' filterRanges(   object,   spectraVariables = character(),   ranges = numeric(),   match = c(\"all\", \"any\") )  # S4 method for class 'Spectra' filterValues(   object,   spectraVariables = character(),   values = numeric(),   ppm = 0,   tolerance = 0,   match = c(\"all\", \"any\") )  # S4 method for class 'Spectra' bin(   x,   binSize = 1L,   breaks = NULL,   msLevel. = uniqueMsLevels(x),   FUN = sum,   zero.rm = TRUE )  # S4 method for class 'Spectra,Spectra' compareSpectra(   x,   y,   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 20,   FUN = ndotproduct,   ...,   SIMPLIFY = TRUE )  # S4 method for class 'Spectra,missing' compareSpectra(   x,   y = NULL,   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 20,   FUN = ndotproduct,   ...,   SIMPLIFY = TRUE )  # S4 method for class 'Spectra' pickPeaks(   object,   halfWindowSize = 2L,   method = c(\"MAD\", \"SuperSmoother\"),   snr = 0,   k = 0L,   descending = FALSE,   threshold = 0,   msLevel. = uniqueMsLevels(object),   ... )  # S4 method for class 'Spectra' replaceIntensitiesBelow(   object,   threshold = min,   value = 0,   msLevel. = uniqueMsLevels(object) )  # S4 method for class 'Spectra' smooth(   x,   halfWindowSize = 2L,   method = c(\"MovingAverage\", \"WeightedMovingAverage\", \"SavitzkyGolay\"),   msLevel. = uniqueMsLevels(x),   ... )  # S4 method for class 'Spectra' addProcessing(object, FUN, ..., spectraVariables = character())  coreSpectraVariables()  # S4 method for class 'Spectra' uniqueMsLevels(object, ...)  # S4 method for class 'Spectra' backendBpparam(object, BPPARAM = bpparam())  # S4 method for class 'Spectra' combinePeaks(   object,   tolerance = 0,   ppm = 20,   intensityFun = base::mean,   mzFun = base::mean,   weighted = TRUE,   msLevel. = uniqueMsLevels(object),   ... )  # S4 method for class 'Spectra' entropy(object, normalized = TRUE)  # S4 method for class 'ANY' entropy(object, ...)  # S4 method for class 'Spectra' dataStorageBasePath(object)  # S4 method for class 'Spectra' dataStorageBasePath(object) <- value  asDataFrame(   object,   i = seq_along(object),   spectraVars = spectraVariables(object) )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Spectra class to manage and access MS data — applyProcessing","text":"object Spectra(): either DataFrame missing. See section creation Spectra objects details. methods Spectra object. f split(): factor defining split x. See base::split() details. setBackend(): factor defining split data parallelized copying spectra data new backend. backends changing parameter can lead errors. combineSpectra(): factor defining grouping spectra combined. spectrapply(): factor object splitted. filterPrecursorScan(): defining spectra belong original data file (sample): Defaults f = dataOrigin(x). intensity(), mz() peaksData(): factor defining data chunk-wise loaded processed. Defaults processingChunkFactor(). BPPARAM Parallel setup configuration. See bpparam() information. passed directly backendInitialize() method MsBackend. ... Additional arguments. x Spectra object. p combineSpectra(): factor defining split input Spectra parallel processing. Defaults x$dataStorage, .e., depending used backend, per-file parallel processing performed. FUN addProcessing(): function applied peak matrix spectrum object. compareSpectra(): function compare intensities peaks two spectra . combineSpectra(): function combine (peak matrices) spectra. See section Data manipulations examples details. bin(): function aggregate intensity values peaks falling bin. Defaults FUN = sum thus summing intensities. spectrapply() chunkapply(): function applied Spectra. y Spectra object. DataFrame joinSpectraData(). .x character(1) specifying spectra variable used merging. Default \"spectrumId\". .y character(1) specifying column used merging. Set .x missing. suffix.y character(1) specifying suffix used making names columns merged spectra variables unique. suffix used amend names(y), spectraVariables(x) remain unchanged. substDefinition deisotopeSpectra() filterPrecursorIsotopes(): matrix data.frame definitions isotopic substitutions. Uses default isotopic substitutions defined compounds Human Metabolome Database (HMDB). See isotopologues() isotopicSubstitutionMatrix() details. tolerance compareSpectra(), containsMz(), deisotopeSpectra(), filterMzValues() reduceSpectra(): numeric(1) allowing define constant maximal accepted difference m/z values peaks matched (grouped). containsMz() can also length equal mz specify different tolerance m/z value. filterPrecursorMaxIntensity(): numeric(1) defining (constant) maximal accepted difference precursor m/z values spectra grouping precursor groups. filterPrecursorIsotopes(): passed directly isotopologues() function. filterValues(): numeric length allowing define maximal accepted difference user input values spectraVariables values. equal length value provided parameter spectraVariables, tolerance[1] recycled. Default tolerance = 0 ppm compareSpectra(), containsMz(), deisotopeSpectra(), filterMzValues() reduceSpectra(): numeric(1) defining relative, m/z-dependent, maximal accepted difference m/z values peaks matched (grouped). filterPrecursorMaxIntensity(): numeric(1) defining relative maximal accepted difference precursor m/z values spectra grouping precursor groups. filterPrecursorIsotopes(): passed directly isotopologues() function. filterValues(): numeric length allowing define maximal accepted difference user input values spectraVariables values.  equal length value provided parameter spectraVariables, ppm[1] recycled. charge deisotopeSpectra(): expected charge ionized compounds. See isotopologues() details. scalePeaks(): function calculate single numeric intensity values spectrum intensities (spectrum) divided . default = sum divide intensities spectrum sum intensities spectrum. msLevel. integer defining MS level(s) spectra function applied (defaults MS levels object. filterMsLevel(): MS level object subsetted. mz filterIsolationWindow(): numeric(1) m/z value filter object. filterPrecursorMz() filterMzRange(): numeric(2) defining lower upper m/z boundary. filterMzValues() filterPrecursorMzValues(): numeric m/z values match peaks precursor m/z . processingQueue Spectra(): optional list ProcessingStep objects. metadata Spectra(): optional list metadata information. backend Spectra(): MsBackend used backend. See section creation Spectra objects details. setBackend(): instance MsBackend supports setBackend() (.e. supportsSetBackend() returns TRUE). backends parameter data backendInitialize() function support passing full spectra data initialize method. See section creation Spectra objects details. export(): MsBackend used export data. source Spectra(): instance MsBackend can used import spectrum data provided files. See section Creation objects, conversion changing backend details. drop [, split(): considered. columns spectraData() accessor: optional character column names (spectra variables) included returned DataFrame. default, columns returned. peaksData() accessor: optional character requested columns individual matrix returned list. Defaults c(\"mz\", \"value\") values returned peaksVariables(object) object Spectra object supported. value replacement value <- methods. See individual method description expected data type. containsMz(): either \"\" \"\" defining whether (default) provided mz present spectrum. neutralLoss containsNeutralLoss(): numeric(1) defining value subtracted spectrum's precursor m/z. chunkSize spectrapply(): size chunks Spectra split. parameter overrides parameters f BPPARAM. use.names lengths(): ignored. spectraVariables selectSpectraVariables(): character names spectra variables backend subsetted. addProcessing(): character additional spectra variables passed along function defined FUN. See function description details. filterRanges() filterValues(): character vector specifying column(s) spectraData(object) filter data correspond names spectra variables used filtering. initial tic(): logical(1) whether initially reported total ion current reported, whether total ion current (re)calculated actual data (initial = FALSE, ionCount()). name $ $<-: name spectra variable return set. [: integer, logical character subset object. asDataFrame() numeric indicating scans coerce DataFrame (default seq_along(object)). j [: supported. n filterAcquisitionNum(): integer acquisition numbers filter . dataStorage filterDataStorage(): character define spectra keep. filterAcquisitionNum(): optionally specify filtering occur spectra selected dataStorage. dataOrigin filterDataOrigin(): character define spectra keep. filterAcquisitionNum(): optionally specify filtering occurr spectra selected dataOrigin. halfWindowSize pickPeaks(): integer(1), used identification mass peaks: local maximum maximum window (- halfWindowSize):(+ halfWindowSize). smooth(): integer(1), used smoothing algorithm, window reaches (- halfWindowSize):(+ halfWindowSize). filterFourierTransformArtefacts(): numeric(1) defining m/z window left right peak remove fourier transform artefacts. threshold pickPeaks(): double(1) defining proportion maximal peak intensity. Just values used weighted mean calculation. replaceIntensitiesBelow(): numeric(1) defining threshold function calculate threshold spectrum intensity values. Defaults threshold = min. filterFourierTransformArtefacts(): relative intensity (peak) peaks considered fourier artefacts. Defaults threshold = 0.2 hence removing peaks intensity 0.2 times intensity tested peak (within selected halfWindowSize). keepIsotopes filterFourierTransformArtefacts(): whether isotope peaks removed fourier artefacts. maxCharge filterFourierTransformArtefacts(): maximum charge considered isotopes. isotopeTolerance filterFourierTransformArtefacts(): m/z tolerance used define whether peaks might isotopes current tested peak. intensity filterIntensity(): numeric length 1 2 defining either lower lower upper intensity limit filtering, function takes intensities input returns logical (length peaks spectrum) whether peak retained . Defaults intensity = c(0, Inf) thus peaks NA intensity removed. keep filterMzValues() filterMzRange(): logical(1) whether  matching peaks retained (keep = TRUE, default) dropped (keep = FALSE). polarity filterPolarity(): integer specifying polarity subset object. z filterPrecursorCharge(): integer() precursor charges used filter. acquisitionNum filterPrecursorScan(): integer acquisition number spectra object subsetted. rt filterRt(): numeric(2) defining retention time range used subset/filter object. ranges filterRanges(): numeric vector paired values (upper lower boundary) define ranges filter object. paired values need order spectraVariables parameter (see ). match filterRanges() filterValues(): character(1)  defining whether condition match provided ranges/values (match = \"\"; default), (match = \"\") spectra retained. values filterValues(): numeric vector define values filter Spectra data. values need order spectraVariables parameter. binSize bin(): numeric(1) defining size m/z bins. Defaults binSize = 1. breaks bin(): numeric defining m/z breakpoints bins. zero.rm logical. bin(): indicating whether remove bins zero intensity. Defaults TRUE, meaning function discard bins created intensity 0 enhance memory efficiency. MAPFUN compareSpectra(): function map/match peaks two compared spectra. See joinPeaks() information possible functions. SIMPLIFY compareSpectra() whether result matrix simplified numeric possible (.e. either x y length 1). method pickPeaks(): character(1), noise estimators used, currently Median Absolute Deviation (method = \"MAD\") Friedman's Super Smoother (method = \"SuperSmoother\") supported. smooth(): character(1), smoothing function used, currently, Moving-Average- (method = \"MovingAverage\"), Weighted-Moving-Average- (method = \"WeightedMovingAverage\"), Savitzky-Golay-Smoothing (method = \"SavitzkyGolay\") supported. snr pickPeaks(): double(1) defining Signal--Noise-Ratio. intensity local maximum higher snr * noise considered peak. k pickPeaks(): integer(1), number values left right peak considered weighted mean calculation. descending pickPeaks(): logical, TRUE just values nearest valleys around peak centroids used. intensityFun combinePeaks(): function used aggregate intensities peaks peak group single intensity value. mzFun combinePeaks(): function aggregate m/z values peaks within peak group single m/z value. parameter ignored weighted = TRUE (default). weighted combinePeaks(): logical(1) whether m/z values peaks within peak group aggregated single m/z value using intensity-weighted mean. Defaults weighted = TRUE. normalized entropy(): logical(1) whether normalized entropy calculated (default). See also nentropy() details. spectraVars character() indicating spectra variables add DataFrame. Default spectraVariables(object), .e. available variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Spectra class to manage and access MS data — applyProcessing","text":"See individual method description return value.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra class uses default lazy data manipulation strategy, .e. data manipulations performed replaceIntensitiesBelow() applied immediately data, applied --fly spectrum data retrieved. backends allow write data back data storage (MsBackendMemory(), MsBackendDataFrame() MsBackendHdf5Peaks()) possible apply queue applyProcessing function. See *Data manipulation analysis methods section details. information parallel chunk-wise processing (especially helpful large data sets) see processingChunkSize(). apply arbitrary functions Spectra use spectrapply() function (directly chunkapply() chunk-wise processing). See description spectrapply() function details. details plotting spectra, see plotSpectra(). Clarifications regarding scan/acquisition numbers indices: spectrumId (spectrumID) vendor specific field mzML file contains information run/spectrum, e.g.: controllerType=0 controllerNumber=1 scan=5281 file=2 acquisitionNum less sanitize spectrum id generated spectrumId field mzR (see ). scanIndex mzR generated sequence number spectrum raw file (acquisitionNum) See also issue.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"creation-of-objects-conversion-changing-the-backend-and-export","dir":"Reference","previous_headings":"","what":"Creation of objects, conversion, changing the backend and export","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Spectra classes can created Spectra() constructor function supports following formats: parameter object data.frame DataFrame containing spectrum data. provided backend (default MsBackendMemory) initialized data. parameter object MsBackend (assumed already initialized). parameter object missing, case supposed data provided MsBackend class passed along backend argument. parameter object type character expected file names(s) spectra imported. Parameter source allows define MsBackend able import data provided source files. default value source MsBackendMzR() allows import spectra data mzML, mzXML CDF files. ... additional arguments can passed backend's backendInitialize() method. Parameter backend allows specify MsBackend used data storage. backend Spectra object can changed setBackend() method takes instance new backend second parameter backend. call setBackend(sps, backend = MsBackendDataFrame()) example change backend sps -memory MsBackendDataFrame. Changing backend supported backend data parameter backendInitialize() method supportsSetBackend() returns TRUE backend. setBackend() transfer full spectra data originating backend DataFrame new backend. read-backends support setBackend(). example possible change backend read-backend (MsBackendMzR() backend). definition function : setBackend(object, backend, ..., f = dataStorage(object), BPPARAM = bpparam()) parameters : parameter object: Spectra object. parameter backend: instance new backend, e.g. [MsBackendMemory()]. parameter f: factor allowing parallelize change backends. default process copying spectra data original new backend performed separately (parallel) file. Users advised use default setting. parameter ...: optional additional arguments passed backendInitialize() method new backend. parameter BPPARAM: setup parallel processing. See bpparam() details. Data Spectra object can exported file export() function. actual export data performed export method MsBackend class defined mandatory parameter backend. Note however backend classes support export data. MsBackend classes Spectra package currently MsBackendMzR backend supports data export (mzML/mzXML file(s)); see help page MsBackend information arguments examples vignette examples. definition function export(object, backend,  ...) parameters : object: Spectra object exported. backend: instance class extending MsBackend supports export data (.e. defined export method). ...: additional parameters specific MsBackend passed parameter backend. dataStorageBasePath() dataStorageBasePath<- functions allow, backend classes support operation, get change base path directory backend stores data. -memory backends MsBackendMemory MsBackendDataFrame keeping MS data memory support, need, function, MsBackendMzR function can used update/adapt path directory containing original data files. Thus, Spectra objects (using backend) moved another file system computer, functions allow adjust/adapt base file path.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"accessing-spectra-data","dir":"Reference","previous_headings":"","what":"Accessing spectra data","title":"The Spectra class to manage and access MS data — applyProcessing","text":"$, $<-: gets (sets) spectra variable spectra object. See examples details. Note replacing values peaks variable supported non-empty processing queue, .e. filtering data manipulations peaks data performed. cases applyProcessing() needs called first apply cached data operations. [[, [[<-: access set/add single spectrum variable (column) backend. acquisitionNum(): returns acquisition number spectrum. Returns integer length equal number spectra (NA_integer_ available). centroided(), centroided<-: gets sets centroiding information spectra. centroided() returns logical vector length equal number spectra TRUE spectrum centroided, FALSE profile mode NA undefined. See also isCentroided() estimating spectrum data whether spectrum centroided. value centroided<- either single logical logical length equal number spectra object. collisionEnergy(), collisionEnergy<-: gets sets collision energy spectra object. collisionEnergy() returns numeric length equal number spectra (NA_real_ present/defined), collisionEnergy<- takes numeric length equal number spectra object. coreSpectraVariables(): returns core spectra variables along expected data type. dataOrigin(), dataOrigin<-: gets sets data origin spectrum. dataOrigin() returns character vector (length object) origin spectra. dataOrigin<- expects character vector (length object) replacement values data origin spectrum. dataStorage(): returns character vector (length object) data storage location spectrum. intensity(): gets intensity values spectra. Returns NumericList() numeric vectors (intensity values spectrum). length list equal number spectra object. ionCount(): returns numeric sum intensities spectrum. spectrum empty (see isEmpty()), NA_real_ returned. isCentroided(): heuristic approach assessing spectra object profile centroided mode. function takes qtlth quantile top peaks, calculates difference adjacent m/z value returns TRUE first quartile greater k. (See Spectra:::.isCentroided() code.) isEmpty(): checks whether spectrum object empty (.e. contain peaks). Returns logical vector length equal number spectra. isolationWindowLowerMz(), isolationWindowLowerMz<-: gets sets lower m/z boundary isolation window. isolationWindowTargetMz(), isolationWindowTargetMz<-: gets sets target m/z isolation window. isolationWindowUpperMz(), isolationWindowUpperMz<-: gets sets upper m/z boundary isolation window. containsMz(): checks spectra whether contain mass peaks m/z equal mz (given acceptable difference defined parameters tolerance ppm - see common() details). Parameter allows define whether (= \"\", default) (= \"\") mz match. function returns NA mz length 0 NA. containsNeutralLoss(): checks spectrum object peak m/z value equal precursor m/z - neutralLoss (given acceptable difference defined parameters tolerance ppm). Returns NA MS1 spectra (spectra without precursor m/z). length(): gets number spectra object. lengths(): gets number peaks (m/z-intensity values) per spectrum. Returns integer vector (length equal number spectra). empty spectra, 0 returned. msLevel(): gets spectra's MS level. Returns integer vector (names spectrum names, length equal number spectra) MS level spectrum. mz(): gets mass--charge ratios (m/z) spectra. Returns NumericList() length equal number spectra, element numeric vector m/z values one spectrum. peaksData(): gets peaks data spectra object. Peaks data consist m/z intensity values well possible additional annotations (variables) peaks spectrum. function returns SimpleList() two dimensional arrays (either matrix data.frame), array providing values requested peak variables (default \"mz\" \"intensity\"). Optional parameter columns passed backend's peaksData() function allow selection specific (additional) peaks variables (columns) extracted (available). Importantly, guaranteed backend supports parameter (backend must support extraction \"mz\" \"intensity\" columns). Parameter columns defaults c(\"mz\", \"intensity\") value returned peaksVariables(object) supported. Note also possible extract peak data (x, \"list\") (x, \"SimpleList\") list SimpleList, respectively. Note however , contrast peaksData(), () support parameter columns. peaksVariables(): lists available variables mass peaks provided backend. Default peak variables \"mz\" \"intensity\" (backends need support provide), backends might provide additional variables. variables correspond column names peak data array returned peaksData(). polarity(), polarity<-: gets sets polarity spectrum. polarity() returns integer vector (length equal number spectra), 0 1 representing negative positive polarities, respectively. polarity<- expects integer vector length 1 equal number spectra. precursorCharge(), precursorIntensity(), precursorMz(), precScanNum(), precAcquisitionNum(): gets charge (integer), intensity (numeric), m/z (numeric), scan index (integer) acquisition number (interger) precursor MS level > 2 spectra object. Returns vector length equal number spectra object. NA reported MS1 spectra precursor information available. rtime(), rtime<-: gets sets retention times (seconds) spectrum.  rtime() returns numeric vector (length equal number spectra) retention time spectrum.  rtime<- expects numeric vector length equal number spectra. scanIndex(): returns integer vector scan index spectrum. represents relative index spectrum within file. Note can different acquisitionNum spectrum represents index spectrum acquisition/measurement (reported mzML file). smoothed(),smoothed<-: gets sets whether spectrum smoothed. smoothed() returns logical vector length equal number spectra. smoothed<- takes logical vector length 1 equal number spectra object. spectraData(): gets general spectrum metadata (annotation, also called header). spectraData() returns DataFrame. Note method default return m/z intensity values. spectraData<-: replaces full spectra data Spectra object one provided value. spectraData<- function expects DataFrame passed value number rows spectra object. Note replacing values peaks variables supported non-empty processing queue, .e. filtering data manipulations peaks data performed. cases applyProcessing() needs called first apply cached data operations empty processing queue. spectraNames(), spectraNames<-: gets sets spectra names. spectraVariables(): returns character vector available spectra variables (columns, fields attributes spectrum) available object. Note spectraVariables() list peak variables (\"mz\", \"intensity\" eventual additional annotations MS peak). Peak variables returned peaksVariables(). tic(): gets total ion current/count (sum signal spectrum) spectra object. default, value reported original raw data file returned. empty spectrum, 0 returned. uniqueMsLevels(): get unique MS levels available object. function supposed efficient unique(msLevel(object)).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"filter-spectra-data","dir":"Reference","previous_headings":"","what":"Filter spectra data","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Filter Spectra object based spectra data. includes subset operations immediately reduce number spectra object well filters reduce content Spectra object. See section Filter peaks data functions filter peaks data Spectra. [: subsets spectra keeping selected elements (). method always returns Spectra object. dropNaSpectraVariables(): removes spectra variables (.e. columns object's spectraData contain missing values (NA). Note columns NAs removed, spectraData() call dropNaSpectraVariables() might still show columns containing NA values core spectra variables. total number spectra changed function. filterAcquisitionNum(): filters object keeping spectra matching provided acquisition numbers (argument n). dataOrigin dataStorage also provided, object subsetted spectra acquisition number equal n spectra matching dataOrigin dataStorage values retaining spectra. Returns filtered Spectra. filterDataOrigin(): filters object retaining spectra matching provided dataOrigin. Parameter dataOrigin type character needs match exactly data origin value spectra subset. Returns filtered Spectra object (spectra ordered according provided dataOrigin parameter). filterDataStorage(): filters object retaining spectra stored specified dataStorage. Parameter dataStorage type character needs match exactly data storage value spectra subset. Returns filtered Spectra object (spectra ordered according provided dataStorage parameter). filterEmptySpectra(): removes empty spectra (.e. spectra without peaks). Returns filtered Spectra object (spectra original order). filterIsolationWindow(): retains spectra contain mz isolation window m/z range (.e. isolationWindowLowerMz <= mz isolationWindowUpperMz >= mz. Returns filtered Spectra object (spectra original order). filterMsLevel(): filters object MS level keeping spectra matching MS level specified argument msLevel. Returns filtered Spectra (spectra original order). filterPolarity(): filters object keeping spectra matching provided polarity. Returns filtered Spectra (spectra original order). filterPrecursorCharge(): retains spectra defined precursor charge(s). filterPrecursorIsotopes(): groups MS2 spectra based precursor m/z precursor intensity predicted isotope groups keep spectrum representing monoisotopic precursor. MS1 spectra returned . See documentation deisotopeSpectra() details isotope prediction parameter description. filterPrecursorMaxIntensity(): filters Spectra keeping groups (MS2) spectra similar precursor m/z values (given parameters ppm tolerance) one highest precursor intensity. function filters MS2 spectra returns MS1 spectra. precursor intensities NA spectra within spectra group, first spectrum groups returned. Note: manufacturers provide precursor intensities. can however also estimated estimatePrecursorIntensity(). filterPrecursorMzRange() (previously filterPrecursorMz() now deprecated): retains spectra precursor m/z within provided m/z range. See examples details selecting spectra precursor m/z target m/z accepting small difference ppm. filterPrecursorMzValues(): retains spectra precursor m/z matching provided m/z values (given ppm tolerance). Spectra missing precursor m/z value (e.g. MS1 spectra) dropped. filterPrecursorScan(): retains parent (e.g. MS1) children scans (e.g. MS2) acquisition number acquisitionNum. Returns filtered Spectra (spectra original order). Parameter f allows define spectra belong sample original data file ( defaults f = dataOrigin(object)). filterRanges(): allows filtering Spectra object based user defined numeric ranges (parameter ranges) one available spectra variables object (spectra variable names can specified parameter spectraVariables). Spectra value spectra variable within defined range retained. multiple ranges/spectra variables defined, match parameter can used specify whether conditions (match = \"\"; default) conditions must match (match = \"\"; spectra values within provided ranges retained). filterRt(): retains spectra MS level msLevel retention times (seconds) within (>=) rt[1] (<=) rt[2]. Returns filtered Spectra (spectra original order). filterValues(): allows filtering Spectra object based similarities numeric values one spectraVariables(object) (parameter spectraVariables) provided values (parameter values) given acceptable differences (parameters tolerance ppm). multiple values/spectra variables defined, match parameter can used specify whether conditions (match = \"\"; default) conditions must match (match = \"\"; spectra values within provided ranges retained). selectSpectraVariables(): reduces information within object selected spectra variables: data variables specified dropped. mandatory columns (.e., listed coreSpectraVariables(), msLevel, rtime ...) values dropped variable . Additional (user defined) spectra variables completely removed. Returns filtered Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"filter-or-aggregate-mass-peak-data","dir":"Reference","previous_headings":"","what":"Filter or aggregate mass peak data","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Operations filter aggregate mass peak data spectrum without changing number spectra Spectra object. Also, actual subsetting/aggregation operation executed peaks data accessed (peaksData(), mz() intensity()) applyProcessing() called. combinePeaks(): combines mass peaks within spectrum difference m/z values smaller maximal acceptable difference defined ppm tolerance. Parameters intensityFun mzFun allow define functions aggregate intensity m/z values group peaks. weighted = TRUE (default), m/z value combined peak calculated using intensity-weighted mean parameter mzFun ignored. MsCoreUtils::group() function used grouping mass peaks. Parameter msLevel. allows define selected MS levels peaks combined. function returns Spectra number spectra input object, possibly combined peaks within spectrum. dropped (.e. values replaced NA) combined peaks unless constant across combined peaks. See also reduceSpectra() function select single representative mass peak peak group. deisotopeSpectra(): deisotopes spectrum keeping monoisotopic peak groups isotopologues. Isotopologues estimated using isotopologues() function MetaboCoreUtils package. Note default parameters isotope prediction/detection determined using data Human Metabolome Database (HMDB) isotopes elements CHNOPS might detected. See parameter substDefinition documentation isotopologues() information. approach code define parameters isotope prediction described . filterFourierTransformArtefacts(): removes (Orbitrap) fast fourier artefact peaks spectra (see examples ). function iterates intensity ordered peaks spectrum removes peaks m/z within +/- halfWindowSize current peak intensity lower threshold times current peak's intensity. Additional parameters keepIsotopes, maxCharge isotopeTolerance allow avoid removing potential [13]C isotope peaks (maxCharge maximum charge considered isotopeTolerance absolute acceptable tolerance matching m/z). See filterFourierTransformArtefacts() details background deisitopeSpectra() alternative. filterIntensity(): filters mass peaks spectrum keeping intensities within provided range match criteria provided function. former, parameter intensity numeric defining intensity range, latter function takes intensity values spectrum returns logical whether peak retained (see examples details) - additional parameters function can passed .... remove peaks intensities certain threshold, say 100, use intensity = c(100, Inf). Note: also single value can passed intensity parameter case upper limit Inf used. Note function removes also peaks missing intensities (.e. intensity NA). Parameter msLevel. allows restrict filtering spectra specified MS level(s). filterMzRange(): filters mass peaks object keeping removing spectrum within provided m/z range. Whether peaks retained removed can configured parameter keep (default keep = TRUE). filterMzValues(): filters mass peaks object keeping peaks spectrum match provided m/z value(s) (keep = TRUE, default) removing (keep = FALSE). m/z matching considers also absolute tolerance m/z-relative ppm values. tolerance ppm length 1. filterPeaksRanges(): filters mass peaks Spectra object using set range-based filters numeric spectra peaks variables. See filterPeaksRanges() information. filterPrecursorPeaks(): removes peaks spectrum object m/z equal larger m/z precursor, depending value parameter mz: mz = ==\" (default) peaks matching m/z (considering absolute relative acceptable difference depending toleranceandppm, respectively) removed. mz = \">=\"peaks m/z larger equal precursor m/z (minustoleranceand theppmof precursor m/z) removed. ParametermsLevel.allows restrict filter certain MS levels (default filter applied MS levels). Note peaks removed precursor m/z isNA` (e.g. typically MS1 spectra). reduceSpectra(): keeps groups peaks similar m/z values (given ppm tolerance) spectrum peak highest intensity removing peaks hence reducing spectrum highest intensity peaks per peak group. Peak groups defined using group() function MsCoreUtils package. See also combinePeaks() function alternative function combine peaks within spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"merging-aggregating-and-splitting","dir":"Reference","previous_headings":"","what":"Merging, aggregating and splitting","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Several Spectra objects can concatenated single object c() concatenateSpectra() function. Concatenation fail processing queue Spectra objects empty different backends used Spectra objects. Thus, cases, prior merging Spectra object suggested change backend MsBackendMemory using setBackend() function, apply data processing steps using applyProcessing(). spectra variables resulting Spectra object union spectra variables individual Spectra objects. combineSpectra(): combines MS data (.e. mass peaks) sets spectra single spectrum per set (contrast combinePeaks() reduceSpectra() combine mass peaks within spectrum). spectrum group (set), spectra variables first spectrum used peak matrices combined using function specified FUN, defaults combinePeaksData(). Please refer combinePeaksData() help page details options actual combination peaks across sets spectra package vignette examples alternative ways aggregate spectra. sets spectra can specified parameter f. addition possible define, parameter p split input data parallel processing. defaults p = x$dataStorage hence per-file parallel processing applied Spectra file-based backends (MsBackendMzR()). Prior combination spectra processings queued lazy evaluation queue applied. aware calling combineSpectra() Spectra object certain backends allow modifications might overwrite original data. happen MsBackendMemory MsBackendDataFrame backend, MsBackendHdf5Peaks backend m/z intensity values original hdf5 file(s) overwritten. function returns Spectra length equal unique levels f. joinSpectraData(): Individual spectra variables can directly added $<- [[<- syntax. joinSpectraData() function allows merge DataFrame existing spectra data. function diverges merge() method two main ways: .x .y column names must length 1. variable names shared x y, spectra variables x modified. y variables appended suffix defined suffix.y. avoid modifying core spectra variables lead invalid object. Duplicated Spectra keys (.e. x[[.x]]) allowed. Duplicated keys DataFrame (.e y[[.y]]) throw warning last occurrence kept. explored ideally removed using QFeatures::reduceDataFrame(), PMS::reducePSMs() similar functions. split(): splits Spectra object based parameter f list Spectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"data-manipulation-and-analysis-methods","dir":"Reference","previous_headings":"","what":"Data manipulation and analysis methods","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Many data manipulation operations, listed section, applied immediately spectra, added lazy processing/manipulation queue. Operations stored queue applied --fly spectra data time accessed. lazy execution guarantees functionality Spectra objects backend, .e. backends supporting save changes spectrum data (MsBackendMemory(), MsBackendDataFrame() MsBackendHdf5Peaks()) well read-backends (MsBackendMzR()). Note former possible apply processing queue write modified peak data back data storage applyProcessing() function. addProcessing(): adds arbitrary function applied peaks matrix every spectrum object. function (can passed parameter FUN) expected take peaks matrix input return peaks matrix. peaks matrix numeric matrix two columns, first containing m/z values peaks second corresponding intensities. function ... definition. Additional arguments can passed .... parameter spectraVariables possible define additional spectra variables object passed function FUN. passed name (e.g. specifying spectraVariables = \"precursorMz\" pass spectra's precursor m/z parameter named precursorMz function. exception spectra's MS level, passed function parameter called spectrumMsLevel (.e. spectraVariables = \"msLevel\" MS levels spectrum submitted function parameter called spectrumMsLevel). Examples provided package vignette. applyProcessing(): Spectra objects use writeable backend : apply steps lazy processing queue peak data write back data storage. Parameter f allows specify object split parallel processing. either equal dataStorage, f = rep(1, length(object)) disable parallel processing alltogether. partitionings might result errors (especially MsBackendHdf5Peaks backend used). bin(): aggregates individual spectra discrete (m/z) bins. Binning performed spectra specified MS level(s) (parameter msLevel, default MS levels x). bins can defined parameter breaks default equally sized bins, size defined parameter binSize, minimal maximal m/z spectra (MS level msLevel) within x. bins used spectra x. intensity values peaks falling bin aggregated using function provided parameter FUN (defaults FUN = sum, .e. intensities summed ). Note binning operation applied peak data --fly upon data access possible revert operation reset() function (see description reset() ). compareSpectra(): compares spectrum x spectrum y using function provided FUN (defaults ndotproduct()). y missing, spectrum x compared spectrum x. matching/mapping peaks compared spectra done MAPFUN function. default joinPeaks() matches peaks spectra allows keep peaks first spectrum (type = \"left\"), second (type = \"right\"), (type = \"outer\") keep matching peaks (type = \"inner\"); see joinPeaks() information examples). MAPFUN function parameters x, y, xPrecursorMz yPrecursorMz values passed function. addition joinPeaks() also joinPeaksGnps() supported GNPS-like similarity score calculations. Note joinPeaksGnps() used combination FUN = MsCoreUtils::gnps (see joinPeaksGnps() information details). Use MAPFUN = joinPeaksNone disable internal peak matching/mapping similarity scoring function used performs matching internally. FUN supposed function compare intensities (matched) peaks two spectra compared. function needs take two matrices columns \"mz\" \"intensity\" input supposed return single numeric result. addition two peak matrices spectra's precursor m/z values passed function parameters xPrecursorMz (precursor m/z x peak matrix) yPrecursorMz (precursor m/z y peak matrix). Additional parameters functions FUN MAPFUN can passed .... Parameters ppm tolerance passed MAPFUN FUN. function returns matrix results FUN comparison, number rows equal length(x) number columns equal length(y) (.e. element row 2 column 3 result comparison x[2] y[3]). SIMPLIFY = TRUE matrix simplified numeric length x y one. See also vignette additional examples, using spectral entropy similarity scoring. entropy(): calculates entropy spectra based metrics suggested Li et al. (https://doi.org/10.1038/s41592-021-01331-z). See also nentropy() MsCoreUtils package details. estimatePrecursorIntensity(): defines precursor intensities MS2 spectra using intensity matching MS1 peak closest MS1 spectrum (.e. last MS1 spectrum measured respective MS2 spectrum). method = \"interpolation\" also possible calculate precursor intensity based interpolation intensity values (retention times) matching MS1 peaks previous next MS1 spectrum. See estimatePrecursorIntensity() examples details. estimatePrecursorMz(): DDA data: allows estimate fragment spectra's precursor m/z based reported precursor m/z data previous MS1 spectrum. See estimatePrecursorMz() details. neutralLoss(): calculates neutral loss spectra fragment spectra. See neutralLoss() detailed documentation. processingLog(): returns character vector processing log messages. reset(): restores data original state (much possible): removes processing steps lazy processing queue calls reset() backend , depending backend, can also undo e.g. data filtering operations. Note reset*( call applyProcessing() effect. See examples information. scalePeaks(): scales intensities peaks within spectrum depending parameter . = sum (default) peak intensities divided sum peak intensities within spectrum. sum intensities thus 1 spectrum scaling. Parameter msLevel. allows apply scaling spectra certain MS level. default (msLevel. = uniqueMsLevels(x)) intensities spectra scaled. spectrapply(): applies given function individual spectrum sets Spectra object. default, Spectra split individual spectra (.e. Spectra length 1) function FUN applied . alternative splitting can defined parameter f. Parameters FUN can passed using .... returned result order depend function FUN object split (hence f, provided). Parallel processing supported can configured parameter BPPARAM, however suggested computational intense FUN. alternative (eventual parallel) processing full Spectra, spectrapply() supports also chunk-wise processing. , parameter chunkSize needs specified. object split chunks size chunkSize (stepwise) processed FUN. guarantees lower memory demand (especially -disk backends) since data one chunk needs loaded memory iteration. Note specifying chunkSize, parameters f BPPARAM ignored. See also chunkapply() examples details chunk-wise processing. smooth(): smooths individual spectra using moving window-based approach (window size = 2 * halfWindowSize). Currently, Moving-Average- (method = \"MovingAverage\"), Weighted-Moving-Average- (method = \"WeightedMovingAverage\"), weights depending distance center calculated 1/2^(-halfWindowSize:halfWindowSize)) Savitzky-Golay-Smoothing (method = \"SavitzkyGolay\") supported. details choose correct halfWindowSize please see MsCoreUtils::smooth(). pickPeaks(): picks peaks individual spectra using moving window-based approach (window size = 2 * halfWindowSize). noisy spectra currently two different noise estimators available, Median Absolute Deviation (method = \"MAD\") Friedman's Super Smoother (method = \"SuperSmoother\"), implemented MsCoreUtils::noise(). method supports also optionally refine m/z value identified centroids considering data points belong (likely) mass peak. Therefore m/z value calculated intensity weighted average m/z values within peak region. peak region defined m/z values (respective intensities) 2 * k closest signals centroid closest valleys (descending = TRUE) 2 * k region. latter k chosen general larger. See MsCoreUtils::refineCentroids() details. ratio signal highest intensity peak threshold ignored weighted average. replaceIntensitiesBelow(): replaces intensities specified threshold provided value. Parameter threshold can either single numeric value function applied non-NA intensities spectrum determine threshold value spectrum. default threshold = min replaces values <= minimum intensity spectrum value (default value 0). Note function specified threshold expected parameter na.rm since na.rm = TRUE passed function. spectrum profile mode, ranges successive non-0 peaks <= threshold set 0. Parameter msLevel. allows apply spectra certain MS level(s).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Spectra class to manage and access MS data — applyProcessing","text":"Nir Shahaf, Johannes Rainer Nir Shahaf Johannes Rainer Sebastian Gibb, Johannes Rainer, Laurent Gatto, Philippine Louail","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/Spectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Spectra class to manage and access MS data — applyProcessing","text":"","code":"## Create a Spectra providing a `DataFrame` containing the spectrum data.  spd <- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2)) spd$mz <- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2)) spd$intensity <- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))  data <- Spectra(spd) data #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 16 more variables/columns.  ## Get the number of spectra length(data) #> [1] 2  ## Get the number of peaks per spectrum lengths(data) #> [1] 4 3  ## Create a Spectra from mzML files and use the `MsBackendMzR` on-disk ## backend. sciex_file <- dir(system.file(\"sciex\", package = \"msdata\"),     full.names = TRUE) sciex <- Spectra(sciex_file, backend = MsBackendMzR()) sciex #> MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: #>        msLevel     rtime scanIndex #>      <integer> <numeric> <integer> #> 1            1     0.280         1 #> 2            1     0.559         2 #> 3            1     0.838         3 #> 4            1     1.117         4 #> 5            1     1.396         5 #> ...        ...       ...       ... #> 1858         1   258.636       927 #> 1859         1   258.915       928 #> 1860         1   259.194       929 #> 1861         1   259.473       930 #> 1862         1   259.752       931 #>  ... 33 more variables/columns. #>  #> file(s): #> 20171016_POOL_POS_1_105-134.mzML #> 20171016_POOL_POS_3_105-134.mzML  ## The MS data is on disk and will be read into memory on-demand. We can ## however change the backend to a MsBackendMemory backend which will ## keep all of the data in memory. sciex_im <- setBackend(sciex, MsBackendMemory()) sciex_im #> MSn data (Spectra) with 1862 spectra in a MsBackendMemory backend: #>        msLevel     rtime scanIndex #>      <integer> <numeric> <integer> #> 1            1     0.280         1 #> 2            1     0.559         2 #> 3            1     0.838         3 #> 4            1     1.117         4 #> 5            1     1.396         5 #> ...        ...       ...       ... #> 1858         1   258.636       927 #> 1859         1   258.915       928 #> 1860         1   259.194       929 #> 1861         1   259.473       930 #> 1862         1   259.752       931 #>  ... 33 more variables/columns. #> Processing: #>  Switch backend from MsBackendMzR to MsBackendMemory [Thu Aug  1 12:46:43 2024]   ## The `MsBackendMemory()` supports the `setBackend()` method: supportsSetBackend(MsBackendMemory()) #> [1] TRUE  ## Thus, it is possible to change to that backend with `setBackend()`. Most ## read-only backends however don't support that, such as the ## `MsBackendMzR` and `setBackend()` would fail to change to that backend. supportsSetBackend(MsBackendMzR()) #> [1] FALSE  ## The on-disk object `sciex` is light-weight, because it does not keep the ## MS peak data in memory. The `sciex_im` object in contrast keeps all the ## data in memory and its size is thus much larger. object.size(sciex) #> 395976 bytes object.size(sciex_im) #> 55802328 bytes  ## The spectra variable `dataStorage` returns for each spectrum the location ## where the data is stored. For in-memory objects: head(dataStorage(sciex_im)) #> [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\"  ## While objects that use an on-disk backend will list the files where the ## data is stored. head(dataStorage(sciex)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"  ## The spectra variable `dataOrigin` returns for each spectrum the *origin* ## of the data. If the data is read from e.g. mzML files, this will be the ## original mzML file name: head(dataOrigin(sciex)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" head(dataOrigin(sciex_im)) #> [1] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [2] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"   ## ---- ACCESSING AND ADDING DATA ----  ## Get the MS level for each spectrum. msLevel(data) #> [1] 1 2  ## Alternatively, we could also use $ to access a specific spectra variable. ## This could also be used to add additional spectra variables to the ## object (see further below). data$msLevel #> [1] 1 2  ## Get the intensity and m/z values. intensity(data) #> NumericList of length 2 #> [[1]] 200 400 34.2 17 #> [[2]] 12.3 15.2 6.8 mz(data) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 45.6 120.4 190.2  ## Determine whether one of the spectra has a specific m/z value containsMz(data, mz = 120.4) #> [1] FALSE  TRUE  ## Accessing spectra variables works for all backends: intensity(sciex) #> NumericList of length 1862 #> [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0 #> [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0 #> [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0 #> [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0 #> [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0 #> [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0 #> [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0 #> [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0 #> [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0 #> [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0 #> ... #> <1852 more elements> intensity(sciex_im) #> NumericList of length 1862 #> [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0 #> [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0 #> [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0 #> [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0 #> [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0 #> [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0 #> [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0 #> [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0 #> [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0 #> [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0 #> ... #> <1852 more elements>  ## Get the m/z for the first spectrum. mz(data)[[1]] #> [1] 100.0 103.2 104.3 106.5  ## Get the peak data (m/z and intensity values). pks <- peaksData(data) pks #> List of length 2 pks[[1]] #>         mz intensity #> [1,] 100.0     200.0 #> [2,] 103.2     400.0 #> [3,] 104.3      34.2 #> [4,] 106.5      17.0 pks[[2]] #>         mz intensity #> [1,]  45.6      12.3 #> [2,] 120.4      15.2 #> [3,] 190.2       6.8  ## Note that we could get the same resulb by coercing the `Spectra` to ## a `list` or `SimpleList`: as(data, \"list\") #> [[1]] #>         mz intensity #> [1,] 100.0     200.0 #> [2,] 103.2     400.0 #> [3,] 104.3      34.2 #> [4,] 106.5      17.0 #>  #> [[2]] #>         mz intensity #> [1,]  45.6      12.3 #> [2,] 120.4      15.2 #> [3,] 190.2       6.8 #>  as(data, \"SimpleList\") #> List of length 2  ## List all available spectra variables (i.e. spectrum data and metadata). spectraVariables(data) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"   ## For all *core* spectrum variables accessor functions are available. These ## return NA if the variable was not set. centroided(data) #> [1] NA NA dataStorage(data) #> [1] \"<memory>\" \"<memory>\" rtime(data) #> [1] 1.1 1.2 precursorMz(data) #> [1] NA NA  ## The core spectra variables are: coreSpectraVariables() #>                 msLevel                   rtime          acquisitionNum  #>               \"integer\"               \"numeric\"               \"integer\"  #>               scanIndex                      mz               intensity  #>               \"integer\"           \"NumericList\"           \"NumericList\"  #>             dataStorage              dataOrigin              centroided  #>             \"character\"             \"character\"               \"logical\"  #>                smoothed                polarity             precScanNum  #>               \"logical\"               \"integer\"               \"integer\"  #>             precursorMz      precursorIntensity         precursorCharge  #>               \"numeric\"               \"numeric\"               \"integer\"  #>         collisionEnergy  isolationWindowLowerMz isolationWindowTargetMz  #>               \"numeric\"               \"numeric\"               \"numeric\"  #>  isolationWindowUpperMz  #>               \"numeric\"   ## Add an additional metadata column. data$spectrum_id <- c(\"sp_1\", \"sp_2\")  ## List spectra variables, \"spectrum_id\" is now also listed spectraVariables(data) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"  \"spectrum_id\"              ## Get the values for the new spectra variable data$spectrum_id #> [1] \"sp_1\" \"sp_2\"  ## Extract specific spectra variables. spectraData(data, columns = c(\"spectrum_id\", \"msLevel\")) #> DataFrame with 2 rows and 2 columns #>   spectrum_id   msLevel #>   <character> <integer> #> 1        sp_1         1 #> 2        sp_2         2  ## Drop spectra variable data and/or columns. res <- selectSpectraVariables(data, c(\"mz\", \"intensity\"))  ## This removed the additional columns \"spectrum_id\" and deleted all values ## for all spectra variables, except \"mz\" and \"intensity\". spectraData(res) #> DataFrame with 2 rows and 17 columns #>     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin #>   <integer> <numeric>      <integer> <integer> <character> <character> #> 1        NA        NA             NA        NA    <memory>          NA #> 2        NA        NA             NA        NA    <memory>          NA #>   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity #>    <logical> <logical> <integer>   <integer>   <numeric>          <numeric> #> 1         NA        NA        NA          NA          NA                 NA #> 2         NA        NA        NA          NA          NA                 NA #>   precursorCharge collisionEnergy isolationWindowLowerMz #>         <integer>       <numeric>              <numeric> #> 1              NA              NA                     NA #> 2              NA              NA                     NA #>   isolationWindowTargetMz isolationWindowUpperMz #>                 <numeric>              <numeric> #> 1                      NA                     NA #> 2                      NA                     NA  ## Compared to the data before selectSpectraVariables. spectraData(data) #> DataFrame with 2 rows and 18 columns #>     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin #>   <integer> <numeric>      <integer> <integer> <character> <character> #> 1         1       1.1             NA        NA    <memory>          NA #> 2         2       1.2             NA        NA    <memory>          NA #>   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity #>    <logical> <logical> <integer>   <integer>   <numeric>          <numeric> #> 1         NA        NA        NA          NA          NA                 NA #> 2         NA        NA        NA          NA          NA                 NA #>   precursorCharge collisionEnergy isolationWindowLowerMz #>         <integer>       <numeric>              <numeric> #> 1              NA              NA                     NA #> 2              NA              NA                     NA #>   isolationWindowTargetMz isolationWindowUpperMz spectrum_id #>                 <numeric>              <numeric> <character> #> 1                      NA                     NA        sp_1 #> 2                      NA                     NA        sp_2   ## ---- SUBSETTING, FILTERING AND COMBINING  ## Subset to all MS2 spectra. data[msLevel(data) == 2] #> MSn data (Spectra) with 1 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         2       1.2        NA #>  ... 17 more variables/columns.  ## Same with the filterMsLevel function filterMsLevel(data, 2) #> MSn data (Spectra) with 1 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         2       1.2        NA #>  ... 17 more variables/columns. #> Processing: #>  Filter: select MS level(s) 2 [Thu Aug  1 12:46:44 2024]   ## Below we combine the `data` and `sciex_im` objects into a single one. data_comb <- c(data, sciex_im)  ## The combined Spectra contains a union of all spectra variables: head(data_comb$spectrum_id) #> [1] \"sp_1\" \"sp_2\" NA     NA     NA     NA     head(data_comb$rtime) #> [1] 1.100 1.200 0.280 0.559 0.838 1.117 head(data_comb$dataStorage) #> [1] \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" \"<memory>\" head(data_comb$dataOrigin) #> [1] NA                                                                 #> [2] NA                                                                 #> [3] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [4] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [5] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\" #> [6] \"/__w/_temp/Library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"  ## Filter a Spectra for a target precursor m/z with a tolerance of 10ppm spd$precursorMz <- c(323.4, 543.2302) data_filt <- Spectra(spd) filterPrecursorMzRange(data_filt, mz = 543.23 + ppm(c(-543.23, 543.23), 10)) #> MSn data (Spectra) with 0 spectra in a MsBackendMemory backend: #> Processing: #>  Filter: select spectra with a precursor m/z within [543.2354323, 543.2354323] [Thu Aug  1 12:46:44 2024]   ## Filter a Spectra keeping only peaks matching certain m/z values sps_sub <- filterMzValues(data, mz = c(103, 104), tolerance = 0.3) mz(sps_sub) #> NumericList of length 2 #> [[1]] 103.2 104.3 #> [[2]] numeric(0)  ## This function can also be used to remove specific peaks from a spectrum ## by setting `keep = FALSE`. sps_sub <- filterMzValues(data, mz = c(103, 104),     tolerance = 0.3, keep = FALSE) mz(sps_sub) #> NumericList of length 2 #> [[1]] 100 106.5 #> [[2]] 45.6 120.4 190.2  ## Note that `filterMzValues()` keeps or removes all peaks with a matching ## m/z given the provided `ppm` and `tolerance` parameters.  ## Filter a Spectra keeping only peaks within a m/z range sps_sub <- filterMzRange(data, mz = c(100, 300)) mz(sps_sub) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 120.4 190.2  ## Remove empty spectra variables sciex_noNA <- dropNaSpectraVariables(sciex)  ## Available spectra variables before and after `dropNaSpectraVariables()` spectraVariables(sciex) #>  [1] \"msLevel\"                  \"rtime\"                    #>  [3] \"acquisitionNum\"           \"scanIndex\"                #>  [5] \"dataStorage\"              \"dataOrigin\"               #>  [7] \"centroided\"               \"smoothed\"                 #>  [9] \"polarity\"                 \"precScanNum\"              #> [11] \"precursorMz\"              \"precursorIntensity\"       #> [13] \"precursorCharge\"          \"collisionEnergy\"          #> [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  #> [17] \"isolationWindowUpperMz\"   \"peaksCount\"               #> [19] \"totIonCurrent\"            \"basePeakMZ\"               #> [21] \"basePeakIntensity\"        \"ionisationEnergy\"         #> [23] \"lowMZ\"                    \"highMZ\"                   #> [25] \"mergedScan\"               \"mergedResultScanNum\"      #> [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   #> [29] \"injectionTime\"            \"filterString\"             #> [31] \"spectrumId\"               \"ionMobilityDriftTime\"     #> [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"     spectraVariables(sciex_noNA) #>  [1] \"msLevel\"                 \"rtime\"                   #>  [3] \"acquisitionNum\"          \"scanIndex\"               #>  [5] \"dataStorage\"             \"dataOrigin\"              #>  [7] \"centroided\"              \"smoothed\"                #>  [9] \"polarity\"                \"precScanNum\"             #> [11] \"precursorMz\"             \"precursorIntensity\"      #> [13] \"precursorCharge\"         \"collisionEnergy\"         #> [15] \"isolationWindowLowerMz\"  \"isolationWindowTargetMz\" #> [17] \"isolationWindowUpperMz\"  \"peaksCount\"              #> [19] \"totIonCurrent\"           \"basePeakMZ\"              #> [21] \"basePeakIntensity\"       \"ionisationEnergy\"        #> [23] \"lowMZ\"                   \"highMZ\"                  #> [25] \"injectionTime\"           \"spectrumId\"                ## Adding new spectra variables sciex1 <- filterDataOrigin(sciex, dataOrigin(sciex)[1]) spv <- DataFrame(spectrumId = sciex1$spectrumId[3:12], ## used for merging                  var1 = rnorm(10),                  var2 = sample(letters, 10)) spv #> DataFrame with 10 rows and 3 columns #>                spectrumId        var1        var2 #>               <character>   <numeric> <character> #> 1  sample=1 period=1 cy.. -1.40004352           w #> 2  sample=1 period=1 cy..  0.25531705           k #> 3  sample=1 period=1 cy.. -2.43726361           y #> 4  sample=1 period=1 cy.. -0.00557129           e #> 5  sample=1 period=1 cy..  0.62155272           u #> 6  sample=1 period=1 cy..  1.14841161           l #> 7  sample=1 period=1 cy.. -1.82181766           b #> 8  sample=1 period=1 cy.. -0.24732530           f #> 9  sample=1 period=1 cy.. -0.24419961           d #> 10 sample=1 period=1 cy.. -0.28270545           p  sciex2 <- joinSpectraData(sciex1, spv, by.y = \"spectrumId\")  spectraVariables(sciex2) #>  [1] \"msLevel\"                  \"rtime\"                    #>  [3] \"acquisitionNum\"           \"scanIndex\"                #>  [5] \"dataStorage\"              \"dataOrigin\"               #>  [7] \"centroided\"               \"smoothed\"                 #>  [9] \"polarity\"                 \"precScanNum\"              #> [11] \"precursorMz\"              \"precursorIntensity\"       #> [13] \"precursorCharge\"          \"collisionEnergy\"          #> [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  #> [17] \"isolationWindowUpperMz\"   \"peaksCount\"               #> [19] \"totIonCurrent\"            \"basePeakMZ\"               #> [21] \"basePeakIntensity\"        \"ionisationEnergy\"         #> [23] \"lowMZ\"                    \"highMZ\"                   #> [25] \"mergedScan\"               \"mergedResultScanNum\"      #> [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   #> [29] \"injectionTime\"            \"filterString\"             #> [31] \"spectrumId\"               \"ionMobilityDriftTime\"     #> [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"     #> [35] \"var1\"                     \"var2\"                     spectraData(sciex2)[1:13, c(\"spectrumId\", \"var1\", \"var2\")] #> DataFrame with 13 rows and 3 columns #>                 spectrumId      var1        var2 #>                <character> <numeric> <character> #> 1   sample=1 period=1 cy..        NA          NA #> 2   sample=1 period=1 cy..        NA          NA #> 3   sample=1 period=1 cy.. -1.400044           w #> 4   sample=1 period=1 cy..  0.255317           k #> 5   sample=1 period=1 cy.. -2.437264           y #> ...                    ...       ...         ... #> 9   sample=1 period=1 cy.. -1.821818           b #> 10  sample=1 period=1 cy.. -0.247325           f #> 11  sample=1 period=1 cy.. -0.244200           d #> 12  sample=1 period=1 cy.. -0.282705           p #> 13  sample=1 period=1 cy..        NA          NA  ## Removing fourier transform artefacts seen in Orbitra data.  ## Loading an Orbitrap spectrum with artefacts. data(fft_spectrum) plotSpectra(fft_spectrum, xlim = c(264.5, 265.5))  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   fft_spectrum <- filterFourierTransformArtefacts(fft_spectrum) fft_spectrum #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Thu Aug  1 12:46:44 2024]  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## Using a few examples peaks in your data you can optimize the parameters fft_spectrum_filtered <- filterFourierTransformArtefacts(fft_spectrum,                                                halfWindowSize = 0.2,                                                threshold = 0.005,                                                keepIsotopes = TRUE,                                                maxCharge = 5,                                                isotopeTolerance = 0.005                                                )  fft_spectrum_filtered #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 2 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Thu Aug  1 12:46:44 2024] #>  Remove fast fourier artefacts. [Thu Aug  1 12:46:44 2024]  length(mz(fft_spectrum_filtered)[[1]]) #> [1] 297 plotSpectra(fft_spectrum_filtered, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## Using filterRanges to filter spectra object based on variables available ## in `spectraData`. ## First, determine the variable(s) on which to base the filtering: sv <- c(\"rtime\", \"precursorMz\", \"peaksCount\") ## Note that ANY variables can be chosen here, and as many as wanted.  ## Define the ranges (pairs of values with lower and upper boundary) to be ## used for the individual spectra variables. The first two values will be ## used for the first spectra variable (e.g., rtime here), the next two for ## the second (e.g. precursorMz here) and so on: ranges <- c(30, 350, 200,500, 350, 600)  ## Input the parameters within the filterRanges function: filt_spectra <- filterRanges(sciex, spectraVariables = sv,                 ranges = ranges)  ## Using `filterRanges()` to filter spectra object with multiple ranges for ## the same `spectraVariable` (e.g, here rtime) sv <- c(\"rtime\", \"rtime\") ranges <- c(30, 100, 200, 300) filt_spectra <- filterRanges(sciex, spectraVariables = sv,                 ranges = ranges, match = \"any\")  ## Using filterValues in a similar way to a filter spectra object based on ## variables available in `spectraData`. However, this time not based on ## ranges but similarities to user input single values with given ## tolerance/ppm ## First determine the variable(s) on which to base the filtering: sv <- c(\"rtime\", \"precursorMz\") ## Note that ANY variables can be chosen here, and as many as wanted.  ## Define the values that will be used to filter the spectra based on their ## similarities to their respective spectraVariables. ## The first values in the parameters values, tolerance and ppm will be ## used for the first spectra variable (e.g. rtime here), the next for the ## second (e.g. precursorMz here) and so on: values <- c(350, 400) tolerance <- c(100, 0) ppm <- c(0,50)  ## Input the parameters within the `filterValues()` function: filt_spectra <- filterValues(sciex, spectraVariables = sv,                 values = values, tolerance = tolerance, ppm = ppm)  ## ---- DATA MANIPULATIONS AND OTHER OPERATIONS ----  ## Set the data to be centroided centroided(data) <- TRUE  ## Replace peak intensities below 40 with 3. res <- replaceIntensitiesBelow(data, threshold = 40, value = 3) res #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 17 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Signal <= 40 in MS level(s) 1, 2 set to 0 [Thu Aug  1 12:46:44 2024]   ## Get the intensities of the first and second spectrum. intensity(res)[[1]] #> [1] 200 400   3   3 intensity(res)[[2]] #> [1] 3 3 3  ## Remove all peaks with an intensity below 40. res <- filterIntensity(res, intensity = c(40, Inf))  ## Get the intensities of the first and second spectrum. intensity(res)[[1]] #> [1] 200 400 intensity(res)[[2]] #> numeric(0)  ## Lengths of spectra is now different lengths(mz(res)) #> [1] 2 0 lengths(mz(data)) #> [1] 4 3  ## In addition it is possible to pass a function to `filterIntensity()`: in ## the example below we want to keep only peaks that have an intensity which ## is larger than one third of the maximal peak intensity in that spectrum. keep_peaks <- function(x, prop = 3) {     x > max(x, na.rm = TRUE) / prop } res2 <- filterIntensity(data, intensity = keep_peaks) intensity(res2)[[1L]] #> [1] 200 400 intensity(data)[[1L]] #> [1] 200.0 400.0  34.2  17.0  ## We can also change the proportion by simply passing the `prop` parameter ## to the function. To keep only peaks that have an intensity which is ## larger than half of the maximum intensity: res2 <- filterIntensity(data, intensity = keep_peaks, prop = 2) intensity(res2)[[1L]] #> intensity  #>       400  intensity(data)[[1L]] #> [1] 200.0 400.0  34.2  17.0  ## Since data manipulation operations are by default not directly applied to ## the data but only added to the internal lazy evaluation queue, it is also ## possible to remove these data manipulations with the `reset()` function: res_rest <- reset(res) res_rest #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1       1.1        NA #> 2         2       1.2        NA #>  ... 17 more variables/columns. #> Processing: #>  Signal <= 40 in MS level(s) 1, 2 set to 0 [Thu Aug  1 12:46:44 2024] #>  Remove peaks with intensities outside [40, Inf] in spectra of MS level(s) 1, 2. [Thu Aug  1 12:46:44 2024] #>  Reset object. [Thu Aug  1 12:46:44 2024]  lengths(mz(res_rest)) #> [1] 4 3 lengths(mz(res)) #> [1] 2 0 lengths(mz(data)) #> [1] 4 3  ## `reset()` after a `applyProcessing()` can not restore the data, because ## the data in the backend was changed. Similarly, `reset()` after any ## filter operations can not restore data for a `Spectra` with a ## `MsBackendMemory` or `MsBackendDataFrame`. res_2 <- applyProcessing(res) res_rest <- reset(res_2) lengths(mz(res)) #> [1] 2 0 lengths(mz(res_rest)) #> [1] 2 0   ## Compare spectra: comparing spectra 2 and 3 against spectra 10:20 using ## the normalized dotproduct method. res <- compareSpectra(sciex_im[2:3], sciex_im[10:20]) ## first row contains comparisons of spectrum 2 with spectra 10 to 20 and ## the second row comparisons of spectrum 3 with spectra 10 to 20 res #>          10        11        12        13        14        15        16 #> 2 0.8583577 0.8603472 0.8588292 0.8434391 0.8581683 0.8515891 0.8568266 #> 3 0.8620081 0.8609868 0.8604669 0.8481934 0.8637094 0.8586378 0.8618227 #>          17        18        19        20 #> 2 0.8563933 0.8559511 0.8546560 0.8538058 #> 3 0.8559523 0.8652169 0.8585325 0.8639445  ## To use a simple Pearson correlation instead we can define a function ## that takes the two peak matrices and calculates the correlation for ## their second columns (containing the intensity values). correlateSpectra <- function(x, y, use = \"pairwise.complete.obs\", ...) {     cor(x[, 2], y[, 2], use = use) } res <- compareSpectra(sciex_im[2:3], sciex_im[10:20],     FUN = correlateSpectra) res #>          10        11        12        13        14        15        16 #> 2 0.9974395 0.9989580 0.9973735 0.9974334 0.9987225 0.9992307 0.9978621 #> 3 0.9986971 0.9976861 0.9964951 0.9965942 0.9982105 0.9984607 0.9982808 #>          17        18        19        20 #> 2 0.9950464 0.9987036 0.9988265 0.9970657 #> 3 0.9921029 0.9990331 0.9975400 0.9955439  ## Use compareSpectra to determine the number of common (matching) peaks ## with a ppm of 10: ## type = \"inner\" uses a *inner join* to match peaks, i.e. keeps only ## peaks that can be mapped betwen both spectra. The provided FUN returns ## simply the number of matching peaks. compareSpectra(sciex_im[2:3], sciex_im[10:20], ppm = 10, type = \"inner\",     FUN = function(x, y, ...) nrow(x)) #>    10  11  12  13  14  15  16  17  18  19  20 #> 2 530 501 484 576 592 515 549 578 539 542 550 #> 3 526 548 524 592 639 502 589 571 575 564 613  ## Apply an arbitrary function to each spectrum in a Spectra. ## In the example below we calculate the mean intensity for each spectrum ## in a subset of the sciex_im data. Note that we can access all variables ## of each individual spectrum either with the `$` operator or the ## corresponding method. res <- spectrapply(sciex_im[1:20], FUN = function(x) mean(x$intensity[[1]])) head(res) #> $`1` #> [1] 1553.953 #>  #> $`2` #> [1] 678.2289 #>  #> $`3` #> [1] 684.3569 #>  #> $`4` #> [1] 682.1004 #>  #> $`5` #> [1] 780.6867 #>  #> $`6` #> [1] 737.5087 #>   ## It is however important to note that dedicated methods to access the ## data (such as `intensity`) are much more efficient than using `lapply()`: res <- lapply(intensity(sciex_im[1:20]), mean) head(res) #> [[1]] #> [1] 1553.953 #>  #> [[2]] #> [1] 678.2289 #>  #> [[3]] #> [1] 684.3569 #>  #> [[4]] #> [1] 682.1004 #>  #> [[5]] #> [1] 780.6867 #>  #> [[6]] #> [1] 737.5087 #>   ## As an alternative, applying a function `FUN` to a `Spectra` can be ## performed *chunk-wise*. The advantage of this is, that only the data for ## one chunk at a time needs to be loaded into memory reducing the memory ## demand. This type of processing can be performed by specifying the size ## of the chunks (i.e. number of spectra per chunk) with the `chunkSize` ## parameter spectrapply(sciex_im[1:20], lengths, chunkSize = 5L) #>  [1]  578 1529 1600 1664 1417 1602 1468 1440 1496 1431 1489 1349 1650 1697 1413 #> [16] 1593 1560 1477 1536 1491  ## ---- DATA EXPORT ----  ## Some `MsBackend` classes provide an `export()` method to export the data ## to the file format supported by the backend. ## The `MsBackendMzR` for example allows to export MS data to mzML or ## mzXML file(s), the `MsBackendMgf` (defined in the MsBackendMgf R package) ## would allow to export the data in mgf file format. ## Below we export the MS data in `data`. We call the `export()` method on ## this object, specify the backend that should be used to export the data ## (and which also defines the output format) and provide a file name. fl <- tempfile() export(data, MsBackendMzR(), file = fl)  ## This exported our data in mzML format. Below we read the first 6 lines ## from that file. readLines(fl, n = 6) #> [1] \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"                                                                                                                                                                                             #> [2] \"<indexedmzML xmlns=\\\"http://psi.hupo.org/ms/mzml\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.2_idx.xsd\\\">\"                  #> [3] \"  <mzML xmlns=\\\"http://psi.hupo.org/ms/mzml\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.0.xsd\\\" id=\\\"\\\" version=\\\"1.1.0\\\">\" #> [4] \"    <cvList count=\\\"2\\\">\"                                                                                                                                                                                                               #> [5] \"      <cv id=\\\"MS\\\" fullName=\\\"Proteomics Standards Initiative Mass Spectrometry Ontology\\\" version=\\\"4.1.117\\\" URI=\\\"https://raw.githubusercontent.com/HUPO-PSI/psi-ms-CV/master/psi-ms.obo\\\"/>\"                                       #> [6] \"      <cv id=\\\"UO\\\" fullName=\\\"Unit Ontology\\\" version=\\\"09:04:2014\\\" URI=\\\"https://raw.githubusercontent.com/bio-ontology-research-group/unit-ontology/master/unit.obo\\\"/>\"                                                             ## If only a single file name is provided, all spectra are exported to that ## file. To export data with the `MsBackendMzR` backend to different files, a ## file name for each individual spectrum has to be provided. ## Below we export each spectrum to its own file. fls <- c(tempfile(), tempfile()) export(data, MsBackendMzR(), file = fls)  ## Reading the data from the first file res <- Spectra(backendInitialize(MsBackendMzR(), fls[1]))  mz(res) #> NumericList of length 1 #> [[1]] 100 103.2 104.3 106.5 mz(data) #> NumericList of length 2 #> [[1]] 100 103.2 104.3 106.5 #> [[2]] 45.6 120.4 190.2  ## ---- PEAKS VARIABLES AND DATA ----  ## Some `MsBackend` classes provide support for arbitrary peaks variables ## (in addition to the mandatory `\"mz\"` and `\"intensity\"` values. Below ## we create a simple data frame with an additional peak variable `\"pk_ann\"` ## and create a `Spectra` with a `MsBackendMemory` for that data. ## Importantly the number of values (per spectrum) need to be the same ## for all peak variables.  tmp <- data.frame(msLevel = c(2L, 2L), rtime = c(123.2, 123.5)) tmp$mz <- list(c(103.1, 110.4, 303.1), c(343.2, 453.1)) tmp$intensity <- list(c(130.1, 543.1, 40), c(0.9, 0.45)) tmp$pk_ann <- list(c(NA_character_, \"A\", \"P\"), c(\"B\", \"P\"))  ## Create the Spectra. With parameter `peaksVariables` we can define ## the columns in `tmp` that contain peaks variables. sps <- Spectra(tmp, source = MsBackendMemory(),     peaksVariables = c(\"mz\", \"intensity\", \"pk_ann\")) peaksVariables(sps) #> [1] \"mz\"        \"intensity\" \"pk_ann\"     ## Extract just the m/z and intensity values peaksData(sps)[[1L]] #>         mz intensity #> [1,] 103.1     130.1 #> [2,] 110.4     543.1 #> [3,] 303.1      40.0  ## Extract the full peaks data peaksData(sps, columns = peaksVariables(sps))[[1L]] #>      mz intensity pk_ann #> 1 103.1     130.1   <NA> #> 2 110.4     543.1      A #> 3 303.1      40.0      P  ## Access just the pk_ann variable sps$pk_ann #> [[1]] #> [1] NA  \"A\" \"P\" #>  #> [[2]] #> [1] \"B\" \"P\" #>   ## Convert a subset of the Spectra object to a long DataFrame. asDataFrame(sciex, i = 1:3, spectraVars = c(\"rtime\", \"msLevel\")) #> DataFrame with 3707 rows and 4 columns #>             mz intensity     rtime   msLevel #>      <numeric> <numeric> <numeric> <integer> #> 1      105.043         0      0.28         1 #> 2      105.045       412      0.28         1 #> 3      105.046         0      0.28         1 #> 4      107.055         0      0.28         1 #> 5      107.057       412      0.28         1 #> ...        ...       ...       ...       ... #> 3703   133.984         0     0.838         1 #> 3704   133.985       132     0.838         1 #> 3705   133.987         0     0.838         1 #> 3706   133.989       132     0.838         1 #> 3707   133.990         0     0.838         1"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function stepwise to chunks of data — chunkapply","title":"Apply a function stepwise to chunks of data — chunkapply","text":"chunkapply() splits x chunks applies function FUN stepwise chunks. Depending object called, function might reduce memory demand considerably, example full data single chunk needs loaded memory time (e.g., Spectra objects -disk similar backends).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function stepwise to chunks of data — chunkapply","text":"","code":"chunkapply(x, FUN, ..., chunkSize = 1000L, chunks = factor())"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function stepwise to chunks of data — chunkapply","text":"x object FUN applied. Can object supports split. FUN function apply x. ... additional parameters FUN. chunkSize integer(1) defining size chunk x splitted. chunks optional factor length equal length(x) defining chunks x splitted.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function stepwise to chunks of data — chunkapply","text":"Depending FUN, cases vector/result object length equal length(x).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply a function stepwise to chunks of data — chunkapply","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/chunkapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function stepwise to chunks of data — chunkapply","text":"","code":"## Apply a function (`sqrt`) to each element in `x`, processed in chunks of ## size 200. x <- rnorm(n = 1000, mean = 500) res <- chunkapply(x, sqrt, chunkSize = 200) length(res) #> [1] 1000 head(res) #> [1] 22.35950 22.37282 22.34023 22.37115 22.36879 22.33149  ## For such a calculation the vectorized `sqrt` would however be recommended system.time(sqrt(x)) #>    user  system elapsed  #>   0.000   0.000   0.001  system.time(chunkapply(x, sqrt, chunkSize = 200)) #>    user  system elapsed  #>   0.001   0.000   0.000   ## Simple example splitting a numeric vector into chunks of 200 and ## aggregating the values within the chunk using the `mean`. Due to the ## `unsplit` the result has the same length than the input with the mean ## value repeated. x <- 1:1000 res <- chunkapply(x, mean, chunkSize = 200) length(res) #> [1] 1000 head(res) #> [1] 100.5 100.5 100.5 100.5 100.5 100.5"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine peaks with similar m/z across spectra — combinePeaksData","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"combinePeaksData() aggregates provided peak matrices single peak matrix. Peaks grouped m/z values group() function MsCoreUtils package. brief, peaks provided spectra first ordered m/z consecutively grouped one group (pairwise) difference smaller specified parameter tolerance ppm (see group() grouping details examples). m/z intensity values resulting peak matrix calculated using mzFun intensityFun grouped m/z intensity values. Note grouped m/z intensity values used aggregation functions (mzFun intensityFun) number spectra. function supports also different strategies peak combinations can specified peaks parameter: peaks = \"union\" (default): report peaks input spectra. peaks = \"intersect\": keep peaks resulting peak matrix present >= minProp proportion input spectra. generate consensus representative spectra set e.g. fragment spectra measured precursor ion. special case possible report peaks resulting matrix peak groups contain peak one input spectra, can specified parameter main. Thus, e.g. main = 2 specified, (grouped) peaks peak second input matrix returned. Setting timeDomain TRUE causes grouping performed square root m/z values (assuming TOF instrument used create data).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"","code":"combinePeaksData(   x,   intensityFun = base::mean,   mzFun = base::mean,   weighted = FALSE,   tolerance = 0,   ppm = 0,   timeDomain = FALSE,   peaks = c(\"union\", \"intersect\"),   main = integer(),   minProp = 0.5,   ... )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"x list peak matrices. intensityFun function used combine intensity values matching peaks. default mean intensity value returned. mzFun function used combine m/z values matching peaks. default mean m/z value returned. weighted logical(1) defining whether m/z values matching peaks calculated intensity-weighted average individuak m/z values. overrides parameter mzFun. tolerance numeric(1) defining (absolute) maximal accepted difference mass peaks group final peak. ppm numeric(1) defining m/z-relative maximal accepted difference mass peaks (expressed parts-per-million) group final peak. timeDomain logical(1) whether grouping mass peaks performed m/z values (timeDomain = FALSE) sqrt(mz) (timeDomain = TRUE). peaks character(1) specifying peaks combined. Can either \"peaks = \"union\" (default) peaks = \"intersect\". See function description details. main optional integer(1) force resulting peak list contain peaks present specified input spectrum. See description details. minProp numeric(1) `peaks = \"intersect\": minimal required proportion input spectra (peak matrices) mass peak present included consensus peak matrix. ... additional parameters mzFun intensityFun functions.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"Peaks matrix m/z intensity values representing aggregated values across provided peak matrices.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"general merging spectra, tolerance /ppm manually specified based precision MS instrument. Peaks spectra difference m/z smaller tolerance smaller ppm m/z grouped final peak. details combination consecutive spectra LC-MS run: m/z values ion consecutive scans (spectra) LC-MS run identical. Assuming random variation much smaller resolution MS instrument (.e. difference m/z values within single spectrum), m/z value groups defined across spectra containing m/z values main spectrum retained. Intensities m/z values falling within m/z groups aggregated using intensityFun mzFun, respectively. highly likely QTOF profile data collected timing circuit collects data points regular intervals time later converted m/z values based relationship t = k * sqrt(m/z). m/z scale thus non-linear m/z scattering (fact caused small variations time circuit) thus different lower upper m/z scale. m/z-intensity pairs consecutive scans combined therefore defined default square root m/z values. timeDomain = FALSE, actual m/z values used.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/combinePeaksData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine peaks with similar m/z across spectra — combinePeaksData","text":"","code":"set.seed(123) mzs <- seq(1, 20, 0.1) ints1 <- abs(rnorm(length(mzs), 10)) ints1[11:20] <- c(15, 30, 90, 200, 500, 300, 100, 70, 40, 20) # add peak ints2 <- abs(rnorm(length(mzs), 10)) ints2[11:20] <- c(15, 30, 60, 120, 300, 200, 90, 60, 30, 23) ints3 <- abs(rnorm(length(mzs), 10)) ints3[11:20] <- c(13, 20, 50, 100, 200, 100, 80, 40, 30, 20)  ## Create the peaks matrices p1 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),     intensity = ints1) p2 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),     intensity = ints2) p3 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.009),     intensity = ints3)  ## Combine the spectra. With `tolerance = 0` and `ppm = 0` only peaks with ## **identical** m/z are combined. The result will be a single spectrum ## containing the *union* of mass peaks from the individual input spectra. p <- combinePeaksData(list(p1, p2, p3))  ## Plot the spectra before and after combining par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1)) plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = \"h\", col = \"red\") points(p2[, 1], p2[, 2], type = \"h\", col = \"green\") points(p3[, 1], p3[, 2], type = \"h\", col = \"blue\")  plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = \"h\",     col = \"black\")  ## The peaks were not merged, because their m/z differs too much.  ## Combine spectra with `tolerance = 0.05`. This will merge all triplets. p <- combinePeaksData(list(p1, p2, p3), tolerance = 0.05)  ## Plot the spectra before and after combining par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1)) plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = \"h\", col = \"red\") points(p2[, 1], p2[, 2], type = \"h\", col = \"green\") points(p3[, 1], p3[, 2], type = \"h\", col = \"blue\")  plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = \"h\",     col = \"black\")   ## With `intensityFun = max` the maximal intensity per peak is reported. p <- combinePeaksData(list(p1, p2, p3), tolerance = 0.05,     intensityFun = max)  ## Create *consensus*/representative spectrum from a set of spectra  p1 <- cbind(mz = c(12, 45, 64, 70), intensity = c(10, 20, 30, 40)) p2 <- cbind(mz = c(17, 45.1, 63.9, 70.2), intensity = c(11, 21, 31, 41)) p3 <- cbind(mz = c(12.1, 44.9, 63), intensity = c(12, 22, 32))  ## No mass peaks identical thus consensus peaks are empty combinePeaksData(list(p1, p2, p3), peaks = \"intersect\") #>      mz intensity  ## Reducing the minProp to 0.2. The consensus spectrum will contain all ## peaks combinePeaksData(list(p1, p2, p3), peaks = \"intersect\", minProp = 0.2) #>         mz intensity #>  [1,] 12.0        10 #>  [2,] 12.1        12 #>  [3,] 17.0        11 #>  [4,] 44.9        22 #>  [5,] 45.0        20 #>  [6,] 45.1        21 #>  [7,] 63.0        32 #>  [8,] 63.9        31 #>  [9,] 64.0        30 #> [10,] 70.0        40 #> [11,] 70.2        41  ## With a tolerance of 0.1 mass peaks can be matched across spectra combinePeaksData(list(p1, p2, p3), peaks = \"intersect\", tolerance = 0.1) #>         mz intensity #> [1,] 12.05      11.0 #> [2,] 45.00      21.0 #> [3,] 63.95      30.5  ## Report the minimal m/z and intensity combinePeaksData(list(p1, p2, p3), peaks = \"intersect\", tolerance = 0.1,     intensityFun = min, mzFun = min) #>        mz intensity #> [1,] 12.0        10 #> [2,] 44.9        20 #> [3,] 63.9        30"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of identifications per scan — countIdentifications","title":"Count the number of identifications per scan — countIdentifications","text":"function takes Spectra object containing identification results input. counts number identifications scan (descendants) lead - either 0 1 MS2 scans, , MS1 scans, number MS2 scans originating MS1 peak lead identification. function can used generate id-annotated total ion chromatograms, can illustrated .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of identifications per scan — countIdentifications","text":"","code":"countIdentifications(   object,   identification = \"sequence\",   f = dataStorage(object),   BPPARAM = bpparam() )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of identifications per scan — countIdentifications","text":"object instance class Spectra contains identification data, defined sequence argument. identification character(1) name spectra variable defines whether scan lead identification (typically containing idenfified peptides sequence proteomics). absence identification encode NA. Default \"sequence\". f factor defining split object parallelized processing. Default dataOrigin(x), .e. raw data files processed parallel. BPPARAM Parallel setup configuration. See BiocParallel::bpparam() details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of identifications per scan — countIdentifications","text":"updated Spectra() object now contains integer spectra variable countIdentifications number identification scan.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count the number of identifications per scan — countIdentifications","text":"computed number identifications stored new spectra variables named \"countIdentifications\". already exists, function throws message returns object unchanged. force recomputation \"countIdentifications\" variable, users either delete rename .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Count the number of identifications per scan — countIdentifications","text":"Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/countIdentifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of identifications per scan — countIdentifications","text":"","code":"spdf <- new(\"DFrame\", rownames = NULL, nrows = 86L,    listData = list(        msLevel = c(1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 1L, 2L,                    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L,                    2L, 2L),        acquisitionNum = 8975:9060,        precScanNum = c(NA, 8956L, 8956L, 8956L, 8956L, 8956L, 8956L,                        8956L, 8956L, 8956L, 8956L, 8956L, 8956L,                        8956L, 8956L, 8956L, 8956L, 8956L, 8956L, NA,                        8975L, 8975L, 8975L, 8975L, 8975L, 8975L,                        8975L, 8975L, 8975L, 8975L, 8975L, 8975L,                        8975L, 8975L, 8975L, 8975L, 8975L, NA, 8994L,                        8994L, 8994L, 8994L, 8994L, 8994L, 8994L,                        8994L, 8994L, 8994L, 8994L, 8994L, 8994L, NA,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L,                        9012L, 9012L, 9012L, 9012L, 9012L, 9012L, NA,                        9026L, 9026L, 9026L, 9026L, 9026L, 9026L,                        9026L, 9026L, 9026L, 9026L, 9026L, 9026L,                        9026L, 9026L, 9026L),        sequence = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     \"LSEHATAPTR\", NA, NA, NA, NA, NA, NA, NA,                     \"EGSDATGDGTK\", NA, NA, \"NEDEDSPNK\", NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,                     NA, NA, NA, NA, NA, NA, NA, NA, NA, \"GLTLAQGGVK\",                     NA, NA, NA, NA, \"STLPDADRER\", NA, NA, NA, NA, NA,                     NA, NA, NA)),    elementType = \"ANY\", elementMetadata = NULL, metadata = list())  sp <- Spectra(spdf)  ## We have in this data 5 MS1 and 81 MS2 scans table(msLevel(sp)) #>  #>  1  2  #>  5 81   ## The acquisition number of the MS1 scans acquisitionNum(filterMsLevel(sp, 1)) #> [1] 8975 8994 9012 9026 9045  ## And the number of MS2 scans with precursor ions selected ## from MS1 scans (those in the data and others) table(precScanNum(sp)) #>  #> 8956 8975 8994 9012 9026  #>   18   17   13   18   15   ## Count number of sequences/identifications per scan sp <- countIdentifications(sp)  ## MS2 scans either lead to an identification (5 instances) or none ## (76). Among the five MS1 scans in the experiment, 3 lead to MS2 ## scans being matched to no peptides and two MS1 scans produced two ## and three PSMs respectively. table(sp$countIdentifications, sp$msLevel) #>     #>      1  2 #>   0  3 76 #>   1  0  5 #>   2  1  0 #>   3  1  0"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorIntensity.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","title":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","text":"MS instrument manufacturers provide precursor intensities fragment spectra. can however estimated, given also MS1 spectra available. estimatePrecursorIntensity() funtion defines precursor intensities MS2 spectra using intensity matching MS1 peak closest MS1 spectrum (.e. last MS1 spectrum measured respective MS2 spectrum). method = \"interpolation\" also possible calculate precursor intensity based interpolation intensity values (retention times) matching MS1 peaks previous next MS1 spectrum. See example.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorIntensity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","text":"","code":"# S4 method for class 'Spectra' estimatePrecursorIntensity(   object,   ppm = 20,   tolerance = 0,   method = c(\"previous\", \"interpolation\"),   msLevel. = 2L,   f = dataOrigin(object),   BPPARAM = bpparam() )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorIntensity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","text":"object Spectra MS1 MS2 spectra. ppm numeric(1) maximal allowed relative difference m/z values precursor m/z spectrum m/z respective ion MS1 scan. tolerance numeric(1) maximal allowed difference m/z values precursor m/z spectrum m/z respective ion MS1 scan. method character(1) defining whether precursor intensity estimated previous MS1 spectrum (method = \"previous\", default) based interpolation previous next MS1 spectrum (method = \"interpolation\"). msLevel. integer(1) MS level precursor intensities estimated. Defaults 2L. f factor (vector coerced factor) defining spectra belong original data file (sample). Defaults f = dataOrigin(x). BPPARAM Parallel setup configuration. See bpparam() information. passed directly backendInitialize() method MsBackend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorIntensity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","text":"Johannes Rainer feedback suggestions Corey Broeckling","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorIntensity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Precursor Intensities — estimatePrecursorIntensity,Spectra-method","text":"","code":"#' ## Calculating the precursor intensity for MS2 spectra: ## ## Some MS instrument manufacturer don't report the precursor intensities ## for MS2 spectra. The `estimatePrecursorIntensity` function can be used ## in these cases to calculate the precursor intensity on MS1 data. Below ## we load an mzML file from a vendor providing precursor intensities and ## compare the estimated and reported precursor intensities. tmt <- Spectra(msdata::proteomics(full.names = TRUE)[5],     backend = MsBackendMzR()) pmi <- estimatePrecursorIntensity(tmt) plot(pmi, precursorIntensity(tmt))   ## We can also replace the original precursor intensity values with the ## newly calculated ones tmt$precursorIntensity <- pmi"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"MS data Waters instruments calibrated Lock Mass, , m/z values mass peaks spectrum calibrated method, reported precursor m/z might . precursor m/z converted mzML file m/z values quadrupole isolation windows instead accurate m/z values. See also GNPS documentation information. estimatePrecursorMz() function estimates/adjusts reported precursor m/z fragment spectrum using following approach: data dependent acquisition (DDA) mode, MS instrument select ions highest intensities one MS scan fragmentation. Thus, fragment spectrum, method identifies previous MS1 spectrum peak highest intensity m/z value similar fragment spectrum's reported precursor m/z (given parameters tolerance ppm). m/z value reported. Since fragment spectrum's potential MS1 mass peak selected based intensity, method used DDA data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"","code":"estimatePrecursorMz(object, tolerance = 0.3, ppm = 10, BPPARAM = SerialParam())"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"object Spectra() object DDA data. tolerance numeric(1) defining absolute acceptable difference m/z fragment spectra's reported precursor m/z MS1 peaks considered precursor peak. MS1 peaks previous MS1 scan m/z fragment spectrum's precursorMz +/- (tolerance + ppm(precursorMz, ppm)) considered. ppm numeric(1) defining m/z dependent acceptable difference m/z. See documentation parameter tolerance information. BPPARAM parallel processing setup. Defaults BPPARAM = SerialParam(). See SerialParam() information.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"numeric length equal number spectra object fragment spectra's estimated precursor m/z values. MS1 spectra NA_real_ values returned. original precursor m/z reported MS2 spectra matching MS1 peak found.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"approach applicable fragment spectra obtained data-dependent acquisition (DDA), assumes peak highest intensity within given isolation m/z window (previous MS1 spectrum) corresponds precursor ion. spectra object ordered retention time. Users function evaluate compare estimated precursor m/z values originally reported one consider adjusted values feel comfortable .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"Mar Garcia-Aloy, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/estimatePrecursorMz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating precursor m/z valus for DDA data — estimatePrecursorMz","text":"","code":"## Load a DDA test data set. For the present data set no large differences ## between the reported and the *actual* precursor m/z are expected. fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") s <- Spectra(fl)  pmz <- estimatePrecursorMz(s)  ## plot the reported and estimated precursor m/z values against each other plot(precursorMz(s), pmz) abline(0, 1)   ## They seem highly similar, but are they identical? identical(precursorMz(s), pmz) #> [1] FALSE all.equal(precursorMz(s), pmz) #> [1] \"Mean relative difference: 1.654551e-05\"  ## Plot also the difference of m/z values against the m/z value plot(precursorMz(s), precursorMz(s) - pmz, xlab = \"precursor m/z\",     ylab = \"difference reported - estimated precursor m/z\")   ## we could then replace the reported precursor m/z values s$precursorMz <- pmz"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"filterFourierTransformArtefacts() function removes (Orbitrap) fast fourier artefact peaks spectra. artefacts (also referred ripples) seem related ringing phenomenon frequently seen Orbitrap data small random mass peaks ~ 0.01 Da main peak large intensity. See also details information. data set fft_spectrum represents Spectra() object single Orbitrap spectrum artefacts (see examples ). See also Spectra() (section *Data subsetting, filtering merging) definition function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"current implementation iterates intensity ordered peaks spectrum removes peaks m/z within +/- halfWindowSize current peak intensity lower threshold times current peak's intensity. Additional parameters keepIsotopes, maxCharge isotopeTolerance allow avoid removing potential [13]C isotope peaks (maxCharge maximum charge considered isotopeTolerance absolute acceptable tolerance matching m/z).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"Jan Stanstrup, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterFourierTransformArtefacts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast fourier transform artefact filter — filterFourierTransformArtefacts","text":"","code":"library(Spectra) data(fft_spectrum)  plotSpectra(fft_spectrum)   ## Focus on an artefact plotSpectra(fft_spectrum, xlim = c(264.5, 265.5))  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   fft_spectrum <- filterFourierTransformArtefacts(fft_spectrum) fft_spectrum #> MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1   367.665       195 #>  ... 33 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Switch backend from MsBackendMzR to MsBackendDataFrame [Mon Nov 22 14:14:45 2021] #>  Remove fast fourier artefacts. [Thu Aug  1 12:47:39 2024]  plotSpectra(fft_spectrum, xlim = c(264.5, 265.5), ylim = c(0, 5e6))   ## R code to download/extract the data.  if (FALSE) { # \\dontrun{ library(Spectra) # get orbitrap data download.file(\"https://ftp.ebi.ac.uk/pub/databases/metabolights/studies/public/MTBLS469/AV_01_v2_male_arm1_juice.mzXML\", \"AV_01_v2_male_arm1_juice.mzXML\") data <- Spectra(\"AV_01_v2_male_arm1_juice.mzXML\") extracted_spectrum <- data[195] } # }"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"filterPeaksRanges() function allows filter peaks matrices Spectra object using set range-based filters numeric spectra variables peaks variables. ranges can passed function using ... <variable name> = <range> pairs. <variable name> available spectra peaks variable. <range> can numeric length 2 defining lower upper boundary, numeric two-column matrix (multi-row matrices also supported, see ). filterPeaksRanges(s, mz = c(200, 300)) example reduce peaks matrices Spectra object s mass peaks m/z value 200 300. filterPeaksRanges() returns original Spectra object filter operation added processing queue. Thus, filter gets applied peaks data gets extracted mz(), intensity() peaksData(). ranges spectra peaks variables defined, function evaluates first whether spectra variable value spectrum within provided range , , applies also peaks variable-based filter (otherwise empty peaks matrix returned). one spectra variable /peaks variable defined, filter results combined logical : peak matrix returned spectrum values spectra variables within provided (respective) ranges spectra variables, matrix filtered contain peaks values within provided peaks variable ranges. Filtering multiple ranges per spectra peaks variables also supported: ranges can also provided multi-row numeric (two-column) matrices. case, described procedure applied row separately results combined logical , .e. peaks matrices returned match conditions/filters row. number rows provided ranges (spectra peaks variables) match. Missing value handling: comparison involves missing value (spectra variable value, peaks variable value value one provided ranges) treated logical FALSE. example, retention time spectrum NA data filtered using retention time range, empty peaks matrix returned (keep = TRUE, keep = FALSE full peaks matrix returned).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"","code":"filterPeaksRanges(object, ..., keep = TRUE)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"object Spectra object. ... ranges spectra /peaks variables. provided <name> = <range> pairs <name> name spectra peaks variable (numeric data type) <range> either numeric length 2 numeric two column matrix (see function desription details), keep logical(1) whether keep (default) remove peaks match provided range(s).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"contrast filter functions, function provide msLevel parameter allows define MS level spectra filter applied. filter(s) always applied spectra (irrespectively MS level). combination multiple filter ranges however possible apply MS level-dependent filters (see examples details). filter applied immediately data executed mass peak data accessed (peaksData(), mz() intensity()) calling applyProcessing().","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/filterPeaksRanges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter peaks based on spectra and peaks variable ranges — filterPeaksRanges","text":"","code":"## Define a test Spectra d <- data.frame(rtime = c(123.2, 134.2), msLevel = c(1L, 2L)) d$mz <- list(c(100.1, 100.2, 100.3, 200.1, 200.2, 300.3),     c(100.3, 100.4, 200.2, 400.3, 400.4)) ## Use the index of the mass peak within the spectrum as index for ## better illustration of filtering results d$intensity <- list(c(1:6), 1:5) s <- Spectra(d) s #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1     123.2        NA #> 2         2     134.2        NA #>  ... 16 more variables/columns.  ## Filter peaks removing all mass peaks with an m/z between 200 and 300 res <- filterPeaksRanges(s, mz = c(200, 300), keep = FALSE) res #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1     123.2        NA #> 2         2     134.2        NA #>  ... 16 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Filter: remove peaks based on user-provided ranges for 1 variables [Thu Aug  1 12:47:40 2024]   ## The Spectra object has still the same length and spectra variables length(res) #> [1] 2 res$rtime #> [1] 123.2 134.2  ## The filter gets applied when mass peak data gets extracted, using either ## `mz()`, `intensity()` or `peaksData()`. The filtered peaks data does ## not contain any mass peaks with m/z values between 200 and 300: peaksData(res)[[1L]] #>         mz intensity #> [1,] 100.1         1 #> [2,] 100.2         2 #> [3,] 100.3         3 #> [4,] 300.3         6 peaksData(res)[[2L]] #>         mz intensity #> [1,] 100.3         1 #> [2,] 100.4         2 #> [3,] 400.3         4 #> [4,] 400.4         5  ## We next combine spectra and filter variables. We want to keep only mass ## peaks of MS2 spectra that have an m/z between 100 and 110. res <- filterPeaksRanges(s, mz = c(100, 110), msLevel = c(2, 2)) res #> MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: #>     msLevel     rtime scanIndex #>   <integer> <numeric> <integer> #> 1         1     123.2        NA #> 2         2     134.2        NA #>  ... 16 more variables/columns. #> Lazy evaluation queue: 1 processing step(s) #> Processing: #>  Filter: select peaks based on user-provided ranges for 2 variables [Thu Aug  1 12:47:40 2024]  length(res) #> [1] 2  ## Only data for peaks are returned for which the spectra's MS level is ## between 2 and 2 and with an m/z between 100 and 110. The peaks data for ## the first spectrum, that has MS level 1, is thus empty: peaksData(res)[[1L]] #>      mz intensity  ## While the peaks matrix for the second spectrum (with MS level 2) contains ## the mass peaks with m/z between 100 and 110. peaksData(res)[[2L]] #>         mz intensity #> [1,] 100.3         1 #> [2,] 100.4         2  ## To keep also the peaks data for the first spectrum, we need to define ## an additional set of ranges, which we define using a second row in each ## ranges matrix. We use the same filter as above, i.e. keeping only mass ## peaks with an m/z between 100 and 110 for spectra with MS level 2, but ## add an additional row for MS level 1 spectra keeping mass peaks with an ## m/z between 0 and 2000. Filter results of different rows are combined ## using a logical OR, i.e. peaks matrices with mass peaks are returned ## matching either the first, or the second row. res <- filterPeaksRanges(s, mz = rbind(c(100, 110), c(0, 1000)),     msLevel = rbind(c(2, 2), c(1, 1)))  ## The results for the MS level 2 spectrum are the same as before, but with ## the additional row we keep the full peaks matrix of the MS1 spectrum: peaksData(res)[[1L]] #>         mz intensity #> [1,] 100.1         1 #> [2,] 100.2         2 #> [3,] 100.3         3 #> [4,] 200.1         4 #> [5,] 200.2         5 #> [6,] 300.3         6 peaksData(res)[[2L]] #>         mz intensity #> [1,] 100.3         1 #> [2,] 100.4         2  ## As a last example we define a filter that keeps all mass peaks with an ## m/z either between 100 and 200, or between 300 and 400. res <- filterPeaksRanges(s, mz = rbind(c(100, 200), c(300, 400))) peaksData(res)[[1L]] #>         mz intensity #> [1,] 100.1         1 #> [2,] 100.2         2 #> [3,] 100.3         3 #> [4,] 300.3         6 peaksData(res)[[2L]] #>         mz intensity #> [1,] 100.3         1 #> [2,] 100.4         2  ## Such filters could thus be defined to restrict/filter the MS data to ## specific e.g. retention time and m/z ranges."},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal page for hidden aliases — hidden_aliases","title":"Internal page for hidden aliases — hidden_aliases","text":"S4 methods require documentation entry clutter index.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal page for hidden aliases — hidden_aliases","text":"","code":"# S4 method for class 'numeric' bin(   x,   y,   size = 1,   breaks = seq(floor(min(y)), ceiling(max(y)), by = size),   FUN = max,   returnMids = TRUE,   .check = TRUE )  containsMz(object, ...)  containsNeutralLoss(object, ...)  dropNaSpectraVariables(object, ...)  entropy(object, ...)  export(object, ...)  pickPeaks(object, ...)  replaceIntensitiesBelow(object, threshold = min, ...)  reset(object, ...)  selectSpectraVariables(object, ...)  # S4 method for class 'MsBackendDataFrame' show(object)  # S4 method for class 'MsBackendDataFrame' backendMerge(object, ...)  # S4 method for class 'MsBackendDataFrame' acquisitionNum(object)  # S4 method for class 'MsBackendDataFrame' peaksData(object, columns = c(\"mz\", \"intensity\"))  # S4 method for class 'MsBackendDataFrame' centroided(object)  # S4 method for class 'MsBackendDataFrame' centroided(object) <- value  # S4 method for class 'MsBackendDataFrame' collisionEnergy(object)  # S4 method for class 'MsBackendDataFrame' collisionEnergy(object) <- value  # S4 method for class 'MsBackendDataFrame' dataOrigin(object)  # S4 method for class 'MsBackendDataFrame' dataOrigin(object) <- value  # S4 method for class 'MsBackendDataFrame' dataStorage(object)  # S4 method for class 'MsBackendDataFrame' dataStorage(object) <- value  # S4 method for class 'MsBackendDataFrame' intensity(object)  # S4 method for class 'MsBackendDataFrame' intensity(object) <- value  # S4 method for class 'MsBackendDataFrame' isEmpty(x)  # S4 method for class 'MsBackendDataFrame' isolationWindowLowerMz(object)  # S4 method for class 'MsBackendDataFrame' isolationWindowLowerMz(object) <- value  # S4 method for class 'MsBackendDataFrame' isolationWindowTargetMz(object)  # S4 method for class 'MsBackendDataFrame' isolationWindowTargetMz(object) <- value  # S4 method for class 'MsBackendDataFrame' isolationWindowUpperMz(object)  # S4 method for class 'MsBackendDataFrame' isolationWindowUpperMz(object) <- value  # S4 method for class 'MsBackendDataFrame' length(x)  # S4 method for class 'MsBackendDataFrame' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackendDataFrame' msLevel(object, ...)  # S4 method for class 'MsBackendDataFrame' msLevel(object) <- value  # S4 method for class 'MsBackendDataFrame' mz(object)  # S4 method for class 'MsBackendDataFrame' mz(object) <- value  # S4 method for class 'MsBackendDataFrame' polarity(object)  # S4 method for class 'MsBackendDataFrame' polarity(object) <- value  # S4 method for class 'MsBackendDataFrame' precScanNum(object)  # S4 method for class 'MsBackendDataFrame' precursorCharge(object)  # S4 method for class 'MsBackendDataFrame' precursorIntensity(object)  # S4 method for class 'MsBackendDataFrame' precursorMz(object)  # S4 method for class 'MsBackendDataFrame' peaksData(object) <- value  # S4 method for class 'MsBackendDataFrame' peaksVariables(object)  # S4 method for class 'MsBackendDataFrame' rtime(object)  # S4 method for class 'MsBackendDataFrame' rtime(object) <- value  # S4 method for class 'MsBackendDataFrame' scanIndex(object)  # S4 method for class 'MsBackendDataFrame' selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for class 'MsBackendDataFrame' smoothed(object)  # S4 method for class 'MsBackendDataFrame' smoothed(object) <- value  # S4 method for class 'MsBackendDataFrame' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackendDataFrame' spectraData(object) <- value  # S4 method for class 'MsBackendDataFrame' spectraNames(object)  # S4 method for class 'MsBackendDataFrame' spectraNames(object) <- value  # S4 method for class 'MsBackendDataFrame' spectraVariables(object)  # S4 method for class 'MsBackendDataFrame' tic(object, initial = TRUE)  # S4 method for class 'MsBackendDataFrame' x$name  # S4 method for class 'MsBackendDataFrame' x$name <- value  # S4 method for class 'MsBackendDataFrame' x[i, j, ..., drop = FALSE]  # S4 method for class 'MsBackendDataFrame,ANY' split(x, f, drop = FALSE, ...)  # S4 method for class 'MsBackendDataFrame' filterAcquisitionNum(   object,   n = integer(),   dataStorage = character(),   dataOrigin = character() )  # S4 method for class 'MsBackendHdf5Peaks' backendInitialize(   object,   files = character(),   data = DataFrame(),   hdf5path = character(),   ...,   BPPARAM = bpparam() )  # S4 method for class 'MsBackendHdf5Peaks' show(object)  # S4 method for class 'MsBackendHdf5Peaks' peaksData(object, columns = peaksVariables(object))  # S4 method for class 'MsBackendHdf5Peaks' intensity(object)  # S4 method for class 'MsBackendHdf5Peaks' intensity(object) <- value  # S4 method for class 'MsBackendHdf5Peaks' ionCount(object)  # S4 method for class 'MsBackendHdf5Peaks' isCentroided(object, ...)  # S4 method for class 'MsBackendHdf5Peaks' isEmpty(x)  # S4 method for class 'MsBackendHdf5Peaks' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackendHdf5Peaks' mz(object)  # S4 method for class 'MsBackendHdf5Peaks' mz(object) <- value  # S4 method for class 'MsBackendHdf5Peaks' peaksData(object) <- value  # S4 method for class 'MsBackendHdf5Peaks' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackendHdf5Peaks' spectraData(object) <- value  # S4 method for class 'MsBackendHdf5Peaks' x$name <- value  # S4 method for class 'MsBackendHdf5Peaks' x[i, j, ..., drop = FALSE]  # S4 method for class 'MsBackendHdf5Peaks' backendMerge(object, ...)  # S4 method for class 'MsBackendMemory' show(object)  # S4 method for class 'MsBackendMemory' backendMerge(object, ...)  # S4 method for class 'MsBackendMemory' acquisitionNum(object)  # S4 method for class 'MsBackendMemory' centroided(object)  # S4 method for class 'MsBackendMemory' centroided(object) <- value  # S4 method for class 'MsBackendMemory' collisionEnergy(object)  # S4 method for class 'MsBackendMemory' collisionEnergy(object) <- value  # S4 method for class 'MsBackendMemory' dataOrigin(object)  # S4 method for class 'MsBackendMemory' dataOrigin(object) <- value  # S4 method for class 'MsBackendMemory' dataStorage(object)  # S4 method for class 'MsBackendMemory' dataStorage(object) <- value  # S4 method for class 'MsBackendMemory' intensity(object)  # S4 method for class 'MsBackendMemory' intensity(object) <- value  # S4 method for class 'MsBackendMemory' ionCount(object)  # S4 method for class 'MsBackendMemory' isEmpty(x)  # S4 method for class 'MsBackendMemory' isolationWindowLowerMz(object)  # S4 method for class 'MsBackendMemory' isolationWindowLowerMz(object) <- value  # S4 method for class 'MsBackendMemory' isolationWindowTargetMz(object)  # S4 method for class 'MsBackendMemory' isolationWindowTargetMz(object) <- value  # S4 method for class 'MsBackendMemory' isolationWindowUpperMz(object)  # S4 method for class 'MsBackendMemory' isolationWindowUpperMz(object) <- value  # S4 method for class 'MsBackendMemory' length(x)  # S4 method for class 'MsBackendMemory' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackendMemory' msLevel(object, ...)  # S4 method for class 'MsBackendMemory' msLevel(object) <- value  # S4 method for class 'MsBackendMemory' mz(object)  # S4 method for class 'MsBackendMemory' mz(object) <- value  # S4 method for class 'MsBackendMemory' peaksData(object, columns = c(\"mz\", \"intensity\"))  # S4 method for class 'MsBackendMemory' peaksData(object) <- value  # S4 method for class 'MsBackendMemory' polarity(object)  # S4 method for class 'MsBackendMemory' polarity(object) <- value  # S4 method for class 'MsBackendMemory' precScanNum(object)  # S4 method for class 'MsBackendMemory' precursorCharge(object)  # S4 method for class 'MsBackendMemory' precursorIntensity(object)  # S4 method for class 'MsBackendMemory' precursorMz(object)  # S4 method for class 'MsBackendMemory' rtime(object)  # S4 method for class 'MsBackendMemory' rtime(object) <- value  # S4 method for class 'MsBackendMemory' scanIndex(object)  # S4 method for class 'MsBackendMemory' selectSpectraVariables(object, spectraVariables = spectraVariables(object))  # S4 method for class 'MsBackendMemory' smoothed(object)  # S4 method for class 'MsBackendMemory' smoothed(object) <- value  # S4 method for class 'MsBackendMemory' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackendMemory' spectraData(object) <- value  # S4 method for class 'MsBackendMemory' spectraNames(object)  # S4 method for class 'MsBackendMemory' spectraNames(object) <- value  # S4 method for class 'MsBackendMemory' spectraVariables(object)  # S4 method for class 'MsBackendMemory' peaksVariables(object)  # S4 method for class 'MsBackendMemory' tic(object, initial = TRUE)  # S4 method for class 'MsBackendMemory' x$name  # S4 method for class 'MsBackendMemory' x$name <- value  # S4 method for class 'MsBackendMemory' x[i, j, ..., drop = FALSE]  # S4 method for class 'MsBackendMemory,ANY' split(x, f, drop = FALSE, ...)  # S4 method for class 'MsBackendMemory' filterAcquisitionNum(   object,   n = integer(),   dataStorage = character(),   dataOrigin = character() )  # S4 method for class 'MsBackendMzR' backendInitialize(object, files, ..., BPPARAM = bpparam())  # S4 method for class 'MsBackendMzR' show(object)  # S4 method for class 'MsBackendMzR' peaksData(object, columns = peaksVariables(object))  # S4 method for class 'MsBackendMzR' intensity(object)  # S4 method for class 'MsBackendMzR' intensity(object) <- value  # S4 method for class 'MsBackendMzR' ionCount(object)  # S4 method for class 'MsBackendMzR' isCentroided(object, ...)  # S4 method for class 'MsBackendMzR' isEmpty(x)  # S4 method for class 'MsBackendMzR' lengths(x, use.names = FALSE)  # S4 method for class 'MsBackendMzR' mz(object)  # S4 method for class 'MsBackendMzR' mz(object) <- value  # S4 method for class 'MsBackendMzR' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MsBackendMzR' spectraData(object) <- value  # S4 method for class 'MsBackendMzR' spectraNames(object)  # S4 method for class 'MsBackendMzR' spectraNames(object) <- value  # S4 method for class 'MsBackendMzR' spectraVariables(object)  # S4 method for class 'MsBackendMzR' x$name <- value  # S4 method for class 'MsBackendMzR' export(   object,   x,   file = tempfile(),   format = c(\"mzML\", \"mzXML\"),   copy = FALSE,   BPPARAM = bpparam() )  # S4 method for class 'Spectra' show(object)  # S4 method for class 'list' combinePeaks(object, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal page for hidden aliases — hidden_aliases","text":"applicable","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/hidden_aliases.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Internal page for hidden aliases — hidden_aliases","text":": replaces data backend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Join (map) peaks of two spectra — joinPeaks","title":"Join (map) peaks of two spectra — joinPeaks","text":"functions map peaks two spectra difference m/z values smaller defined parameters tolerance ppm. functions take two matrices joinPeaks(): maps peaks two spectra allowing specify type join performed: type = \"outer\" peak x matched peak y, peaks match peak spectra NA intensity returned. type = \"left\" peaks left spectrum (x) matched peaks y. Peaks y match peak x omitted. type = \"right\" type = \"left\" y. peaks can matched x y returned type = \"inner\", .e. peaks present spectra reported. joinPeaksGnps(): matches/maps peaks spectra approach used GNPS: peaks considered matching ) difference m/z values smaller defined tolerance ppm (joinPeaks) b) difference m/z adjusted difference spectras' precursor smaller defined tolerance ppm. Based definition, peaks x can match two peaks y hence peaks returned matrices might reported multiple times. Note one xPrecursorMz yPrecursorMz NA , results joinPeaks(). calculate GNPS similarity scores, gnps() called aligned peak matrices (.e. compareSpectra called MAPFUN = joinPeaksGnps FUN = MsCoreUtils::gnps). joinPeaksNone(): perform peak matching simply returns peak matrices list. function used MAPFUN parameter compareSpectra() spectra similarity function used (parameter FUN compareSpectra()) performs peak matching hence expect matched peak matrices input.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join (map) peaks of two spectra — joinPeaks","text":"","code":"joinPeaks(x, y, type = \"outer\", tolerance = 0, ppm = 10, ...)  joinPeaksGnps(   x,   y,   xPrecursorMz = NA_real_,   yPrecursorMz = NA_real_,   tolerance = 0,   ppm = 0,   type = \"outer\",   ... )  joinPeaksNone(x, y, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join (map) peaks of two spectra — joinPeaks","text":"x matrix two columns \"mz\" \"intensity\" containing m/z intensity values mass peaks spectrum. y matrix two columns \"mz\" \"intensity\" containing m/z intensity values mass peaks spectrum. type joinPeaks() joinPeaksGnps(): character(1) specifying type join performed. See function description details. tolerance numeric(1) defining constant maximal accepted difference m/z values peaks two spectra matched/mapped. ppm numeric(1) defining relative, m/z-dependent, maximal accepted difference m/z values peaks two spectra matched/mapped. ... optional parameters passed MsCoreUtils::join() function. xPrecursorMz joinPeaksGnps(): numeric(1) precursor m/z spectrum x. yPrecursorMz joinPeaksGnps(): numeric(1) precursor m/z spectrum y.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join (map) peaks of two spectra — joinPeaks","text":"functions return list elements \"x\" \"y\" two column matrix m/z (first column) intensity values (second column). two matrices contain matched peaks input matrices x y hence number rows. Peaks present x y input matrix m/z intensity values NA result matrix y (vice versa).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"implementation-notes","dir":"Reference","previous_headings":"","what":"Implementation notes","title":"Join (map) peaks of two spectra — joinPeaks","text":"mapping function must take two numeric matrices x y input must return list two elements named \"x\" \"y\" represent aligned input matrices. function also ... definition. Parameters ppm tolerance suggested required.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Join (map) peaks of two spectra — joinPeaks","text":"Johannes Rainer, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/joinPeaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join (map) peaks of two spectra — joinPeaks","text":"","code":"x <- cbind(c(31.34, 50.14, 60.3, 120.9, 230, 514.13, 874.1),     1:7) y <- cbind(c(12, 31.35, 70.3, 120.9 + ppm(120.9, 5),     230 + ppm(230, 10), 315, 514.14, 901, 1202),     1:9)  ## No peaks with identical m/z joinPeaks(x, y, ppm = 0, type = \"inner\") #> $x #>      [,1] [,2] #>  #> $y #>      [,1] [,2] #>   ## With ppm 10 two peaks are overlapping joinPeaks(x, y, ppm = 10, type = \"inner\") #> $x #>       [,1] [,2] #> [1,] 120.9    4 #> [2,] 230.0    5 #>  #> $y #>          [,1] [,2] #> [1,] 120.9006    4 #> [2,] 230.0023    5 #>   ## Outer join: contain all peaks from x and y joinPeaks(x, y, ppm = 10, type = \"outer\") #> $x #>         [,1] [,2] #>  [1,]     NA   NA #>  [2,]  31.34    1 #>  [3,]     NA   NA #>  [4,]  50.14    2 #>  [5,]  60.30    3 #>  [6,]     NA   NA #>  [7,] 120.90    4 #>  [8,] 230.00    5 #>  [9,]     NA   NA #> [10,] 514.13    6 #> [11,]     NA   NA #> [12,] 874.10    7 #> [13,]     NA   NA #> [14,]     NA   NA #>  #> $y #>            [,1] [,2] #>  [1,]   12.0000    1 #>  [2,]        NA   NA #>  [3,]   31.3500    2 #>  [4,]        NA   NA #>  [5,]        NA   NA #>  [6,]   70.3000    3 #>  [7,]  120.9006    4 #>  [8,]  230.0023    5 #>  [9,]  315.0000    6 #> [10,]        NA   NA #> [11,]  514.1400    7 #> [12,]        NA   NA #> [13,]  901.0000    8 #> [14,] 1202.0000    9 #>   ## Left join: keep all peaks from x and those from y that match joinPeaks(x, y, ppm = 10, type = \"left\") #> $x #>        [,1] [,2] #> [1,]  31.34    1 #> [2,]  50.14    2 #> [3,]  60.30    3 #> [4,] 120.90    4 #> [5,] 230.00    5 #> [6,] 514.13    6 #> [7,] 874.10    7 #>  #> $y #>          [,1] [,2] #> [1,]       NA   NA #> [2,]       NA   NA #> [3,]       NA   NA #> [4,] 120.9006    4 #> [5,] 230.0023    5 #> [6,]       NA   NA #> [7,]       NA   NA #>   ## Right join: keep all peaks from y and those from x that match. Using ## a constant tolerance of 0.01 joinPeaks(x, y, tolerance = 0.01, type = \"right\") #> $x #>         [,1] [,2] #>  [1,]     NA   NA #>  [2,]  31.34    1 #>  [3,]     NA   NA #>  [4,] 120.90    4 #>  [5,] 230.00    5 #>  [6,]     NA   NA #>  [7,] 514.13    6 #>  [8,]     NA   NA #>  [9,]     NA   NA #>  #> $y #>            [,1] [,2] #>  [1,]   12.0000    1 #>  [2,]   31.3500    2 #>  [3,]   70.3000    3 #>  [4,]  120.9006    4 #>  [5,]  230.0023    5 #>  [6,]  315.0000    6 #>  [7,]  514.1400    7 #>  [8,]  901.0000    8 #>  [9,] 1202.0000    9 #>   ## GNPS-like peak matching  ## Define spectra x <- cbind(mz = c(10, 36, 63, 91, 93), intensity = c(14, 15, 999, 650, 1)) y <- cbind(mz = c(10, 12, 50, 63, 105), intensity = c(35, 5, 16, 999, 450)) ## The precursor m/z pmz_x <- 91 pmz_y <- 105  ## Plain joinPeaks identifies only 2 matching peaks: 1 and 5 joinPeaks(x, y) #> $x #>      mz intensity #> [1,] 10        14 #> [2,] NA        NA #> [3,] 36        15 #> [4,] NA        NA #> [5,] 63       999 #> [6,] 91       650 #> [7,] 93         1 #> [8,] NA        NA #>  #> $y #>       mz intensity #> [1,]  10        35 #> [2,]  12         5 #> [3,]  NA        NA #> [4,]  50        16 #> [5,]  63       999 #> [6,]  NA        NA #> [7,]  NA        NA #> [8,] 105       450 #>   ## joinPeaksGnps finds 4 matches joinPeaksGnps(x, y, pmz_x, pmz_y) #> $x #>       mz intensity #>  [1,] 10        14 #>  [2,] 36        15 #>  [3,] 36        15 #>  [4,] 63       999 #>  [5,] 91       650 #>  [6,] 91       650 #>  [7,] 93         1 #>  [8,] NA        NA #>  [9,] NA        NA #> [10,] NA        NA #>  #> $y #>        mz intensity #>  [1,]  10        35 #>  [2,]  NA        NA #>  [3,]  50        16 #>  [4,]  63       999 #>  [5,]  NA        NA #>  [6,] 105       450 #>  [7,]  NA        NA #>  [8,]  12         5 #>  [9,]  50        16 #> [10,] 105       450 #>   ## with one of the two precursor m/z being NA, the result are the same as ## with joinPeaks (with type = \"left\"). joinPeaksGnps(x, y, pmz_x, yPrecursorMz = NA) #> $x #>      mz intensity #> [1,] 10        14 #> [2,] NA        NA #> [3,] 36        15 #> [4,] NA        NA #> [5,] 63       999 #> [6,] 91       650 #> [7,] 93         1 #> [8,] NA        NA #>  #> $y #>       mz intensity #> [1,]  10        35 #> [2,]  12         5 #> [3,]  NA        NA #> [4,]  50        16 #> [5,]  63       999 #> [6,]  NA        NA #> [7,]  NA        NA #> [8,] 105       450 #>"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Neutral Loss Spectra — neutralLoss","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"help page lists functions convert MS/MS spectra neutral loss spectra. main function neutralLoss specific algorithm used defined (configured) dedicated parameter objects (paramer param neutralLoss() function). parameter objects different algorithms : PrecursorMzParam(): calculates neutral loss spectra Aisporna et al. 2022 subtracting (fragment's) peak m/z value precursor m/z value spectrum (precursor m/z - fragment m/z). Parameter msLevel allows restrict calculation neutral loss spectra specified MS level(s). Spectra MS level(s) returned -. Parameter filterPeaks allows remove certain peaks neutral loss spectra. default (filterPeaks = \"none\") filtering takes place. filterPeaks = \"removePrecursor\" fragment peaks m/z value matching precursor m/z (considering also ppm tolerance removed. filterPeaks = \"abovePrecursor\", fragment peaks m/z larger precursor m/z (m/z > precursor m/z - tolerance - ppm precursor m/z) removed (thus removing also cases fragment peaks representing precursor). Finally, filterPeaks = \"belowPrecursor\" fragment peaks m/z smaller precursor m/z (m/z < precursor m/z + tolerance + ppm precursor m/z) removed. Also case precursor fragment peak (depending values ppm tolerance) removed.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"","code":"neutralLoss(object, param, ...)  PrecursorMzParam(   filterPeaks = c(\"none\", \"abovePrecursor\", \"belowPrecursor\", \"removePrecursor\"),   msLevel = c(2L, NA_integer_),   ppm = 10,   tolerance = 0 )  # S4 method for class 'Spectra,PrecursorMzParam' neutralLoss(object, param, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"object Spectra() object fragment spectra neutral loss spectra calculated. param One parameter objects discussed . ... Currently ignored. filterPeaks PrecursorMzParam(): character(1) function defining fragment peaks filtered calculation. Pre-defined options : \"none\" (keep peaks), \"abovePrecursor\" (removes fragment peaks m/z >= precursor m/z), \"belowPrecursor\" (removes fragment peaks m/z <= precursor m/z). addition, possible pass custom function parameter arguments x (two column peak matrix) precursorMz (precursor m/z) returns sub-setted two column peak matrix. msLevel integer defining MS level(s) neutral loss spectra calculated. Defaults msLevel = c(2L, NA) thus, neutral loss spectra calculated spectra MS level equal 2 missing/undefined MS level. spectra MS level different msLevel returned unchanged. ppm numeric(1) m/z-relative acceptable difference m/z values filter peaks. Defaults ppm = 10. See function description details. tolerance numeric(1) absolute acceptable difference m/z values filter peaks. Defaults tolerance = 0. See function description details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Spectra() object calculated neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"definition, mass peaks Spectra object need ordered m/z value (increasing order). Thus, order peaks calculated neutral loss spectra might original Spectra object. Note also spectra missing precursor m/z empty spectra returned (.e. spectra without peaks) since possible calcualte neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Aisporna , Benton PH, Chen , Derks RJE, Galano JM, Giera M Siuzdak G (2022). Neutral Loss Mass Spectral Data Enhances Molecular Similarity Analysis METLIN. Journal American Society Mass Spectrometry. doi:10.1021/jasms.1c00343","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/neutralLoss.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Neutral Loss Spectra — neutralLoss","text":"","code":"## Create a simple example Spectra object with some MS1, MS2 and MS3 spectra. DF <- DataFrame(msLevel = c(1L, 2L, 3L, 1L, 2L, 3L),                 precursorMz = c(NA, 40, 20, NA, 300, 200)) DF$mz <- IRanges::NumericList(                       c(3, 12, 14, 15, 16, 200),                       c(13, 23, 39, 86),                       c(5, 7, 20, 34, 50),                       c(5, 7, 9, 20, 100),                       c(15, 53, 299, 300),                       c(34, 56, 100, 200, 204, 309)                   , compress = FALSE) DF$intensity <- IRanges::NumericList(1:6, 1:4, 1:5, 1:5, 1:4, 1:6,                                      compress = FALSE) sps <- Spectra(DF, backend = MsBackendDataFrame())  ## Calculate neutral loss spectra for all MS2 spectra, keeping MS1 and MS3 ## spectra unchanged. sps_nl <- neutralLoss(sps, PrecursorMzParam(msLevel = 2L)) mz(sps) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] 13 23 39 86 #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] 15 53 299 300 #> [[6]] 34 56 100 200 204 309 mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] -46 1 17 27 #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] 0 1 247 285 #> [[6]] 34 56 100 200 204 309  ## Calculate neutral loss spectra for MS2 and MS3 spectra, removing peaks ## with an m/z >= precursorMz sps_nl <- neutralLoss(sps, PrecursorMzParam(     filterPeaks = \"abovePrecursor\", msLevel = 2:3)) mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] 1 17 27 #> [[3]] 13 15 #> [[4]] 5 7 9 20 100 #> [[5]] 1 247 285 #> [[6]] 100 144 166 ## This removed also the peak with m/z 39 from the second spectrum  ## Removing all fragment peaks matching the precursor m/z with a tolerance ## of 1 and ppm 10 sps_nl <- neutralLoss(sps, PrecursorMzParam(     filterPeaks = \"removePrecursor\", tolerance = 1, ppm = 10, msLevel = 2:3)) mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] -46 17 27 #> [[3]] -30 -14 13 15 #> [[4]] 5 7 9 20 100 #> [[5]] 247 285 #> [[6]] -109 -4 100 144 166  ## Empty spectra are returned for MS 2 spectra with undefined precursor m/z. sps$precursorMz <- NA_real_ sps_nl <- neutralLoss(sps, PrecursorMzParam()) mz(sps_nl) #> NumericList of length 6 #> [[1]] 3 12 14 15 16 200 #> [[2]] numeric(0) #> [[3]] 5 7 20 34 50 #> [[4]] 5 7 9 20 100 #> [[5]] numeric(0) #> [[6]] 34 56 100 200 204 309"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":null,"dir":"Reference","previous_headings":"","what":"MZ delta Quality Control — plotMzDelta","title":"MZ delta Quality Control — plotMzDelta","text":"M/Z delta plot illustrates suitability MS2 spectra identification plotting M/Z differences intense peaks. resulting histogram optimally show modes amino acid residu masses. plots described Foster et al. 2011. certain percentage intense MS2 peaks taken account use significant signal. Default value 20% (see percentage argument). difference peaks computed individual spectra distribution plotted histogram. Delta M/Z 40 200 plotted default, encompass residue masses amino acids several common contaminants, although can changes mzRange argument. addition processing described , isobaric reporter tag peaks precursor peak can also removed MS2 spectrum, avoid interence fragment peaks. Note figures Foster et al. 2011 produced optimised centroided data. running function profile mode likely fine, recommended use centroided data. ggplot2 based function called ggMzDeltaPlot() visualise M/Z delta distributions available https://gist.github.com/lgatto/c72b1ff5a4116118dbb34d9d2bc3470a.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MZ delta Quality Control — plotMzDelta","text":"","code":"computeMzDeltas(   object,   percentage = 0.2,   mzRange = c(40, 200),   BPPARAM = BiocParallel::bpparam() )  plotMzDelta(x, aaLabels = TRUE)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MZ delta Quality Control — plotMzDelta","text":"object instance class Spectra(). percentage numeric(1) 0 1 indicating percentage intense peaks MS2 spectrum include calculation. Default 0.2. mzRange numeric(2) upper lower M/Z used MZ deltas. Default c(40, 200). BPPARAM optional BiocParallelParam instance determining parallel back-end used evaluation. Default use BiocParallel::bpparam(). See ?BiocParallel::bpparam details. x list M/Z delta values, returned computeMzDeltas(). aaLabels logical(1) defining whether amino acids labelled histogram. Default TRUE.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MZ delta Quality Control — plotMzDelta","text":"computeMzDeltas() returns list numeric vectors. plotMzDelta() used visualise M/Z delta distributions.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"MZ delta Quality Control — plotMzDelta","text":"Foster JM, Degroeve S, Gatto L, Visser M, Wang R, Griss J, et al. posteriori quality control curation reuse public proteomics data. Proteomics. 2011;11: 2182-2194. http://dx.doi.org/10.1002/pmic.201000602","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MZ delta Quality Control — plotMzDelta","text":"Laurent Gatto contributions (MSnbase) Guangchuang Yu.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/plotMzDelta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MZ delta Quality Control — plotMzDelta","text":"","code":"library(msdata) f <- proteomics(pattern = \"TMT.+20141210.mzML.gz\", full.names = TRUE) sp <- Spectra(f)  d <- computeMzDeltas(sp[1:1000]) plotMzDelta(d)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel and chunk-wise processing of Spectra — processingChunkSize","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"Many operations Spectra objects, specifically working actual MS data (peaks data), allow chunk-wise processing Spectra splitted smaller parts (chunks) iteratively processed. enables parallel processing data (data chunk) also reduces memory demand  since MS data currently processed subset loaded memory processed. chunk-wise processing, default disabled, can enabled setting processing chunk size Spectra processingChunkSize() function value smaller length Spectra object. Setting processingChunkSize(sps) <- 1000 cause data manipulation operation sps, filterIntensity() bin(), performed eventually parallel sets 1000 spectra iteration. chunk-wise processing specifically useful Spectra objects using -disk backend large experiments. small data sets Spectra using -memory backend, direct processing might however efficient. Setting chunk size Inf disable chunk-wise processing. backends certain type splitting chunk-wise processing might preferable. MsBackendMzR backend example needs load MS data original (mzML) files, hence chunk-wise processing per-file basis ideal. backendParallelFactor() function MsBackend allows backends suggest preferred splitting data returning factor defining respective data chunks. MsBackendMzR returns example factor based dataStorage spectra variable. factor length 0 returned particular preferred splitting performed. suggested chunk definition used finite processingChunkSize() defined. Setting processingChunkSize overrides backendParallelFactor. See Large-scale data handling processing Spectra information examples. Functions configure parallel chunk-wise processing: processingChunkSize(): allows get set size chunks parallel processing chunk-wise processing Spectra general. value Inf (default) chunk-wise processing performed. processingChunkFactor(): returns factor defining chunks Spectra split chunk-wise (parallel) processing. factor length 0 indicates chunk-wise processing performed.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"","code":"processingChunkSize(x)  processingChunkSize(x) <- value  processingChunkFactor(x)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"x Spectra. value integer(1) defining chunk size.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"processingChunkSize() returns currently defined processing chunk size (Inf defined). processingChunkFactor() returns factor defining chunks x split (parallel) chunk-wise processing factor length 0 splitting defined.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"backends might support parallel processing . , backendBpparam() function always return SerialParam() independently parallel processing defined.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/processingChunkSize.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallel and chunk-wise processing of Spectra — processingChunkSize","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting Spectra — spectra-plotting","title":"Plotting Spectra — spectra-plotting","text":"Spectra() can plotted one following functions plotSpectra(): plots spectrum separate plot splitting plot area many panels spectra. plotSpectraOverlay(): plots spectra x plot (overlay). plotSpectraMirror(): plots pair spectra mirror plot. Parameters x y Spectra length 1. Matching peaks (considering ppm tolerance) highlighted. See common() details peak matching. Parameters matchCol, matchLty, matchLwd matchPch allow customize matching peaks indicated.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting Spectra — spectra-plotting","text":"","code":"plotSpectra(   x,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = character(),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   asp = 1,   ... )  plotSpectraOverlay(   x,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = paste(length(x), \"spectra\"),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   axes = TRUE,   frame.plot = axes,   ... )  # S4 method for class 'Spectra' plotSpectraMirror(   x,   y,   xlab = \"m/z\",   ylab = \"intensity\",   type = \"h\",   xlim = numeric(),   ylim = numeric(),   main = character(),   col = \"#00000080\",   labels = character(),   labelCex = 1,   labelSrt = 0,   labelAdj = NULL,   labelPos = NULL,   labelOffset = 0.5,   labelCol = \"#00000080\",   axes = TRUE,   frame.plot = axes,   ppm = 20,   tolerance = 0,   matchCol = \"#80B1D3\",   matchLwd = 1,   matchLty = 1,   matchPch = 16,   ... )"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting Spectra — spectra-plotting","text":"x Spectra() object. plotSpectraMirror() object length 2. xlab character(1) label x-axis (default xlab = \"m/z\"). ylab character(1) label y-axis (default ylab = \"intensity\"). type character(1) specifying type plot. See plot.default() details. Defaults type = \"h\" draws peak line. xlim numeric(2) defining x-axis limits. range m/z values used default. ylim numeric(2) defining y-axis limits. range intensity values used default. main character(1) title plot. default spectrum's MS level retention time (seconds) used. col color used draw peaks. either length 1, equal number spectra (plot spectrum different color) list colors individual peak spectrum. labels allows specify label peak. Can character length equal number peaks, , ideally, function uses one Spectra's variables (see examples ). plotSpectraMirror() supports labels type function. labelCex numeric(1) giving amount text magnified relative default. See parameter cex par(). labelSrt numeric(1) defining rotation label. See parameter srt text(). labelAdj see parameter adj text(). labelPos see parameter pos text(). labelOffset see parameter offset text(). labelCol color label(s). asp plotSpectra(): target ratio (columns / rows) plotting mutliple spectra (e.g. 20 spectra use asp = 4/5 4 columns 5 rows asp = 5/4 5 columns 4 rows; see grDevices::n2mfrow() details). ... additional parameters passed plot.default() function. axes logical(1) whether (x y) axes drawn. frame.plot logical(1) whether box drawn around plotting area. y plotSpectraMirror(): Spectra object length 1 x plotted . ppm plotSpectraMirror(): m/z relative acceptable difference (ppm) peaks considered matching (see common() details). tolerance plotSpectraMirror(): absolute acceptable difference m/z values peaks considered matching (see common() details). matchCol plotSpectraMirror(): color matching peaks. matchLwd plotSpectraMirror(): line width (lwd) draw matching peaks. See par() details. matchLty plotSpectraMirror(): line type (lty) draw matching peaks. See par() details. matchPch plotSpectraMirror(): point character (pch) label matching peaks. Defaults matchPch = 16, set matchPch = NA disable. See par() details.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting Spectra — spectra-plotting","text":"functions create plot.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plotting Spectra — spectra-plotting","text":"Johannes Rainer, Sebastian Gibb, Laurent Gatto","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectra-plotting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting Spectra — spectra-plotting","text":"","code":"ints <- list(c(4.3412, 12, 8, 34, 23.4),     c(8, 25, 16, 32)) mzs <- list(c(13.453421, 43.433122, 46.6653553, 129.111212, 322.24432),     c(13.452, 43.5122, 129.112, 322.245))  df <- DataFrame(msLevel = c(1L, 1L), rtime = c(123.12, 124)) df$mz <- mzs df$intensity <- ints sp <- Spectra(df)  #### --------------------------------------------- #### ##                   plotSpectra                     ##  ## Plot one spectrum. plotSpectra(sp[1])  ## Plot both spectra. plotSpectra(sp)   ## Define a color for each peak in each spectrum. plotSpectra(sp, col = list(c(1, 2, 3, 4, 5), 1:4))   ## Color peaks from each spectrum in different colors. plotSpectra(sp, col = c(\"green\", \"blue\"))   ## Label each peak with its m/z. plotSpectra(sp, labels = function(z) format(unlist(mz(z)), digits = 4))   ## Rotate the labels. plotSpectra(sp, labels = function(z) format(unlist(mz(z)), digits = 4),     labelPos = 2, labelOffset = 0.1, labelSrt = -30)   ## Add a custom annotation for each peak. sp$label <- list(c(\"\", \"A\", \"B\", \"C\", \"D\"),     c(\"Frodo\", \"Bilbo\", \"Peregrin\", \"Samwise\")) ## Plot each peak in a different color plotSpectra(sp, labels = function(z) unlist(z$label),     col = list(1:5, 1:4))   ## Plot a single spectrum specifying the label. plotSpectra(sp[2], labels = c(\"A\", \"B\", \"C\", \"D\"))   #### --------------------------------------------- #### ##                plotSpectraOverlay                 ##  ## Plot both spectra overlaying. plotSpectraOverlay(sp)   ## Use a different color for each spectrum. plotSpectraOverlay(sp, col = c(\"#ff000080\", \"#0000ff80\"))  ## Label also the peaks with their m/z if their intensity is above 15. plotSpectraOverlay(sp, col = c(\"#ff000080\", \"#0000ff80\"),     labels = function(z) {         lbls <- format(mz(z)[[1L]], digits = 4)         lbls[intensity(z)[[1L]] <= 15] <- \"\"         lbls     }) abline(h = 15, lty = 2)   ## Use different asp values plotSpectra(sp, asp = 1/2) plotSpectra(sp, asp = 2/1)   #### --------------------------------------------- #### ##                plotSpectraMirror                  ##  ## Plot two spectra against each other. plotSpectraMirror(sp[1], sp[2])  ## Label the peaks with their m/z plotSpectraMirror(sp[1], sp[2],     labels = function(z) format(mz(z)[[1L]], digits = 3),     labelSrt = -30, labelPos = 2, labelOffset = 0.2) grid()   ## The same plot with a tolerance of 0.1 and using a different color to ## highlight matching peaks plotSpectraMirror(sp[1], sp[2],     labels = function(z) format(mz(z)[[1L]], digits = 3),     labelSrt = -30, labelPos = 2, labelOffset = 0.2, tolerance = 0.1,     matchCol = \"#ff000080\", matchLwd = 2) grid()"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapping between spectra variables and data file fields — spectraVariableMapping","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"spectraVariableMapping function provides mapping spectra variables Spectra() object data fields data file. name mapping expected enable easier import data files specific dialects, e.g. files MGF format use different naming convention core spectra variables. MsBackend() implementations expected implement function (needed) enable import data file formats non-standardized data fields.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"","code":"spectraVariableMapping(object, ...)"},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"object instance object extending MsBackend(). ... Optional parameters.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"named character names spectra variable names (use spectraVariables() list supported names) values data field names.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/reference/spectraVariableMapping.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mapping between spectra variables and data file fields — spectraVariableMapping","text":"Johannes Rainer","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.7","title":"Spectra 1.15","text":"Change estimatePrecursorIntensity() method avoid overrides/clashes -named implementation xcms.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.6","title":"Spectra 1.15","text":"Fix selectSpectraVariables() MsBackendMzR: ensure peaks variables \"mz\" \"intensity\" default removed.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.5","title":"Spectra 1.15","text":"Add new filterPeaksRanges() function filter mass peaks ranges numeric spectra peak variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.3","title":"Spectra 1.15","text":"evaluation Spectra’s processing queue: call functions MetaboCoreUtils directly namespace (MsCoreUtils::) avoid errors performed parallel Windows machines called re-loaded object. New asDataFrame() function convert (small) Spectra object long DataFrame.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.2","title":"Spectra 1.15","text":"Add dataStorageDataPath() dataStorageDataPath<- methods allow updating/adapting path data storage files backends supporting issue #321.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-15-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.15.1","title":"Spectra 1.15","text":"Improve documentation combineSpectra() combinePeaks() issue #320.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.8","title":"Spectra 1.13","text":"Add estimatePrecursorMz() function estimate precursor m/z DDA fragment spectra previous MS1 spectra issue #315.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.7","title":"Spectra 1.13","text":"Move generics backendBpparam(), backendParallelFactor() supportsSetBackend() ProtGenerics. Required ProtGenerics version 1.35.4 higher.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.6","title":"Spectra 1.13","text":"Add filterRanges() filterValues() functions allow filtering Spectra object based ranges similarities existing spectraData variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.5","title":"Spectra 1.13","text":"Move generics ProtGenerics. Requires ProtGenerics version 1.35.3.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.4","title":"Spectra 1.13","text":"Add entropy nentropy functions allow calculate (normalized) entropy spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.3","title":"Spectra 1.13","text":"Fix issue setBackend might cause chunk-wise processing run.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.2","title":"Spectra 1.13","text":"Add possibility enable perform chunk-wise (parallel) processing Spectra: add functions processingChunkSize, backendParallelFactor processingChunkFactor set get definition chunks parallel processing. functions working peaks data use mechanism implemented internal .peaksapply function. Spectra object gains new slot \"processingChunkSize\" used define size processing chunks Spectra. See also issue #304. ensures processing also large data sets.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-13-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.1","title":"Spectra 1.13","text":"Fix issue bin function (see issue #302). Addition zero.rm parameter prevent creation empty bins.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.11","title":"Spectra 1.11","text":"Fix issue filterFourierTransformArtefacts function (see issue #302). Thanks Adriano Rutz reporting.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.10","title":"Spectra 1.11","text":"peaksData,MsBackendMemory returns data.frame additional peak variables (addition \"mz\" \"intensity\") requested. columns = c(\"mz\", \"intensity\") (default) list matrix returned. peaksData,Spectra returns either matrix data.frame ensures peak data correctly subset based lazy evaluation processing queue. $,Spectra access peak variables ensures lazy evaluation queue applied prior extracting values. applyProcessing correctly subsets processes peak variables depending processing queue. spectraData<-,Spectra throws error processing queue empty values peaks variables replaced. $<-,Spectra throws error processing queue empty peaks variable going replaced. Add full support additional peaks variables MsBackendDataFrame.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.9","title":"Spectra 1.11","text":"Add filterPrecursorPeaks allow filtering peaks within spectrum m/z values relative precursor m/z spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.8","title":"Spectra 1.11","text":"Add example vignette describing spectral similarity scores msentropy package can used compareSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.7","title":"Spectra 1.11","text":"Fix compareSpectra also pass parameters ppm tolerance peak similarity calculation functions FUN: allows use custom similarity function integrated mapping peaks. Add joinPeaksNone skip peak matching compareSpectra similarity scoring function performs peak matching. use parallel processing setBackend,Spectra backends support .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.6","title":"Spectra 1.11","text":"Add filterPrecursorMaxIntensity function. Add filterPrecursorIsotopes function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.5","title":"Spectra 1.11","text":"Add scalePeaks function (see issue #291).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.4","title":"Spectra 1.11","text":"Import uniqueMsLevels ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.3","title":"Spectra 1.11","text":"Rename combinePeaks lists peak matrices combinePeaksData. Add combinePeaks generics. Add combinePeaks,Spectra combine peaks within spectrum Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.2","title":"Spectra 1.11","text":"Add deisotopeSpectra reduceSpectra functions.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-11-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.1","title":"Spectra 1.11","text":"Add example filtering precursor m/z peaks fragment spectra vignette.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.15","title":"Spectra 1.9","text":"Fix issue MsBackendMemory failed return intensity m/z values peaks data empty. Fix bug filterPrecursorScan() (see #194 PR #277).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.14","title":"Spectra 1.9","text":"Fix issue filterMzValues keep (remove) first matching peak instead matching peaks (given ppm tolerance). Issue #274. Add parameter keep filterMzRange support keeping removing matching peaks.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.13","title":"Spectra 1.9","text":"Add backendBpparam method allows evaluate whether MsBackend supports provided (default) BiocParallel-based parallel processing setup. Minor tweaks internal .peaksapply function avoid splitting/merging data needed (e.g. parallel processing performed). Minor tweaks spectra comparison functions avoid repeated calling functions loops.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.12","title":"Spectra 1.9","text":"Extend list available MsBackend backends provided packages (README package vignette).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.11","title":"Spectra 1.9","text":"Fix headers MsBackend vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.10","title":"Spectra 1.9","text":"Add supportsSetBackend method MsBackend specify whether backend supports setBackend,Spectra. setBackend checks using supportsSetBackend whether backend supports setBackend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.9","title":"Spectra 1.9","text":"Refactor setBackend split merge backends necessary change dataOrigin original backend. Support setBackend MsBackendMemory empty Spectra object (issue #268). Disable automatic detection peak variables MsBackendMemory (issue #269). Fix issue Spectra empty character (issue #267).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.8","title":"Spectra 1.9","text":"Address comments Michele Stravs regarding MsBackend vignette. Add additional tests checking MsBackend compliance.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.7","title":"Spectra 1.9","text":"Add vignette describing build MsBackend scratch (issue #262). Extend unit test suite evaluate validity MsBackend implementations.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.6","title":"Spectra 1.9","text":"Replace <= calls.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.5","title":"Spectra 1.9","text":"Fix bug containsMz() mz isn’t ordered (see #258).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.4","title":"Spectra 1.9","text":"Fix error extracting spectra variables MsBackendMzR length 0.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-12","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.3","title":"Spectra 1.9","text":"Add chunkapply function split Spectra chunks stepwise apply function FUN .","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.2","title":"Spectra 1.9","text":"combineSpectra Spectra read-backends change backend MsBackendMemory instead MsBackendDataFrame.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-14","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.1","title":"Spectra 1.9","text":"Expand documentation compareSpectra GNPS-like similarity scoring.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-9-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.0","title":"Spectra 1.9","text":"Bioconductor 3.17 developmental version.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.5","title":"Spectra 1.7","text":"Force serial processing unit tests avoid potential failures Bioconductor build check servers (circumstances).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-7-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.4","title":"Spectra 1.7","text":"Add MsBackendMemory backend class providing efficient -memory data representation MsBackendDataFrame.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-7-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.3","title":"Spectra 1.7","text":"Import spectrapply ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-7-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.2","title":"Spectra 1.7","text":"Fix setBackend provided Spectra empty. backendInitialize,Spectra,MsBackendDataFrame returns Spectra object full provided spectra data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-7-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.1","title":"Spectra 1.7","text":"Add uniqueMsLevels function allow efficient, backend-specific, implementations retrieving unique MS levels data set.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.20","title":"Spectra 1.5","text":"Add parameters ppm tolerance PrecursorMzParam (neutral loss calculation) add option filterPeaks =   \"removePrecursor\".","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.19","title":"Spectra 1.5","text":"Improved bin method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.18","title":"Spectra 1.5","text":"Set default parameter columns peaksData,Spectra peaksData,MsBackend c(\"mz\", \"intensity\").","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.17","title":"Spectra 1.5","text":"Add peaksVariables method add parameter columns (...) peaksData. Add columns parameter peaksData method MsBackendDataFrame, MsBackendMzR MsBackendHdf5peaks.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.16","title":"Spectra 1.5","text":"Fix issue neutralLoss prevent calculation neutral loss spectra ","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.15","title":"Spectra 1.5","text":"Fix typo MZ delta plot title.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.14","title":"Spectra 1.5","text":"Add coreSpectraVariables function export core spectra variables expected data types.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.13","title":"Spectra 1.5","text":"Fix figure sizes vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.12","title":"Spectra 1.5","text":"Add neutralLoss method first algorithm calculate neutral loss spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.11","title":"Spectra 1.5","text":"Fix neutral loss example vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.10","title":"Spectra 1.5","text":"Add citation.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.9","title":"Spectra 1.5","text":"Add examples combineSpectra vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-12","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.8","title":"Spectra 1.5","text":"Add spectraVariableMapping generic.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.7","title":"Spectra 1.5","text":"Add missing export filterPrecursorMz method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-14","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.6","title":"Spectra 1.5","text":"Add filterPrecursorMzValue method allows filter using multiple precursor m/z values (issue #230). Fix unit test suite.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.5","title":"Spectra 1.5","text":"Add testing framework allowing run standardized unit tests new MsBackend implementations (issue #186).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-16","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.4","title":"Spectra 1.5","text":"Add MsBackendCached backend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-17","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.3","title":"Spectra 1.5","text":"calculate number peaks per spectra processing queue Spectra empty. Otherwise call backend’s implementation (issue MsBackendSql #31).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-18","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.2","title":"Spectra 1.5","text":"Small documentation update (related MsCoreUtils issue #87). New countIdentifications() function. Add filterFourierTransformArtefacts function remove fast fourier artefact peaks seen e.g. Orbitrap instruments (issue #223).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-5-19","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.1","title":"Spectra 1.5","text":"Don’t read header information importing peaks matrix macOS.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.11","title":"Spectra 1.3","text":"Fix error message setBackend (issue #217).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.10","title":"Spectra 1.3","text":"Fix bug plotSpectra plotSpectraMirror cause error number peaks spectrum 1 labels provided.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.9","title":"Spectra 1.3","text":"New features: joinSpectraData() now check duplicated keys x (throws error) y (thows warning).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.8","title":"Spectra 1.3","text":"New features: plotMzDelta() function M/Z delta QC (ported MSnbase).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.7","title":"Spectra 1.3","text":"Add fix MSnbase (issue #170) Spectra: macOS require reading also spectrum header reading peaks data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.6","title":"Spectra 1.3","text":"Documentation updates combineSpectra combinePeaks.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.5","title":"Spectra 1.3","text":"filterMzValues supports also removing peaks matching specified m/z values (issue #209).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.4","title":"Spectra 1.3","text":"Add list additional R packages repositories providing MsBackend backends vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.3","title":"Spectra 1.3","text":"Move generics bin compareSpectra ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.2","title":"Spectra 1.3","text":"Add parameter f filterPrecursorScan fix issue #194.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-3-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.1","title":"Spectra 1.3","text":"Add estimatePrecursorIntensity function (issue #202).","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.20","title":"Spectra 1.1","text":"Fix concatenating empty spectra (issue #200).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.19","title":"Spectra 1.1","text":"New filterPrecursorCharge() method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.18","title":"Spectra 1.1","text":"Define plotSpectraMirror method.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.17","title":"Spectra 1.1","text":"Fix issue #187. Add function concatenateSpectra allow concatenating Spectra objects list Spectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.16","title":"Spectra 1.1","text":"Support arbitrary spectra variables passed functions provided/added addProcessing; issue #182.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.15","title":"Spectra 1.1","text":"Pass spectras’ precursor m/z MAPFUN compareSpectra; issue #171. Add joinPeaksGnps perform peak matching spectra similar one performed GNPS (issue #171).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.14","title":"Spectra 1.1","text":"Support plotting empty spectra (issue 175).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.13","title":"Spectra 1.1","text":"Move ProcessingStep ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.12","title":"Spectra 1.1","text":"Fix show method Spectra list 3 recent processing steps (issue 173). Add processingLog function display log messages processing steps Spectra object.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.11","title":"Spectra 1.1","text":"Add support ... pickPeaks smooth (issue 168).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-10","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.10","title":"Spectra 1.1","text":"Import filterIntensity ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.9","title":"Spectra 1.1","text":"Fix label plotSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-12","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.8","title":"Spectra 1.1","text":"filterIntensity supports passing additional parameters used filter function (issue 164).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.7","title":"Spectra 1.1","text":"Fix bug show,ProcessingStep (issue 162).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-14","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.6","title":"Spectra 1.1","text":"New joinSpectraData() function.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-15","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.5","title":"Spectra 1.1","text":"Add [[,Msbackend [[<-,MsBackend methods (issue 149). Add [[,Spectra [[<-,Spectra methods.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-16","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.4","title":"Spectra 1.1","text":"Fix issue labelCol plotSpectra (issue #157).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-17","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.3","title":"Spectra 1.1","text":"Implement generic Spectra,constructor replacing Spectra,DataFrame Spectra,character.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-18","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.2","title":"Spectra 1.1","text":"Fix problem export mzML files failed empty spectra (issue #145)","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-19","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"Spectra 1.1","text":"Round retention time figure titles. Document differences spectrumId (spectrumID), acquisitionNum scanIndex.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-1-1-20","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.0","title":"Spectra 1.1","text":"New Bioc devel version","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.11","title":"Spectra 0.99","text":"Re-add mz intensity core spectra variables.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.10","title":"Spectra 0.99","text":"Fix spectraData<-,Spectra avoid removing m/z intensity values (issue #146). Add default implementations filter functions MsBackend.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.9","title":"Spectra 0.99","text":"Fix Spectra,character constructor ensure backend changed even source inherits backend (issue #143).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.8","title":"Spectra 0.99","text":"combineSpectra applies data processing steps processing queue prior combination (issue #140).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.7","title":"Spectra 0.99","text":"Fix problem dropNaSpectraVariables also drop m/z intensity values backends (issue #138.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.6","title":"Spectra 0.99","text":"Support intensity filterIntensity method function enable peak intensity-based filtering spectra (issue #126).","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.5","title":"Spectra 0.99","text":"Add filterMzRange filterMzValues filter spectra based m/z range list target m/z values, respectively.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.4","title":"Spectra 0.99","text":"Add export,MsBackendMzR export spectra data mzML mzXML file(s). Add export,MsBackend method allow backends take care data export. Refactor export,Spectra use MsBackend class export data. Change parameter source Spectra,character MsBackendMzR set parameter backend = source. Thus default, import backend also used store data.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.3","title":"Spectra 0.99","text":"Replace lapply,Spectra spectrapply,Spectra.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.2","title":"Spectra 0.99","text":"Replace asDataFrame,MsBackend spectraData,MsBackend. Replace asDataFrame<-,MsBackend spectraData<-,MsBackend. Replace .list,MsBackend peaksData,MsBackend. Replace replaceList<-,MsBackend peaksData<-,MsBackend. Replace .list,Spectra peaksData,Spectra add methods coerce Spectra list SimpleList.","code":""},{"path":"https://rformassspectrometry.github.io/Spectra/news/index.html","id":"changes-in-0-99-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.0","title":"Spectra 0.99","text":"Add reset method. Add processing chunk compareSpectra.","code":""}]
