<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Note that the classes described here are not meant to be used
directly by the end-users and the material in this man page is
aimed at package developers.
MsBackend is a virtual class that defines what each different
backend needs to provide. MsBackend objects provide access to
mass spectrometry data. Such backends can be classified into
in-memory or on-disk backends, depending on where the data, i.e
spectra (m/z and intensities) and spectra annotation (MS level,
charge, polarity, ...) are stored.
Typically, in-memory backends keep all data in memory ensuring fast
data access, while on-disk backends store (parts of) their data on
disk and retrieve it on demand.
The Backend functions and implementation notes for new backend
classes section documents the API that a backend must implement.
Currently available backends are:
MsBackendDataFrame: stores all data in memory using a DataFrame.
MsBackendMzR: stores the m/z and intensities on-disk in raw
data files (typically mzML or mzXML) and the spectra
annotation information (header) in memory in a DataFrame. This
backend requires the mzR package.
MsBackendHdf5Peaks: stores the m/z and intensities on-disk in custom hdf5
data files and the remaining spectra variables in memory (in a
DataFrame). This backend requires the rhdf5 package.


See below for more details about individual backends."><title>Mass spectrometry data backends — MsBackend • Spectra</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Mass spectrometry data backends — MsBackend"><meta property="og:description" content="Note that the classes described here are not meant to be used
directly by the end-users and the material in this man page is
aimed at package developers.
MsBackend is a virtual class that defines what each different
backend needs to provide. MsBackend objects provide access to
mass spectrometry data. Such backends can be classified into
in-memory or on-disk backends, depending on where the data, i.e
spectra (m/z and intensities) and spectra annotation (MS level,
charge, polarity, ...) are stored.
Typically, in-memory backends keep all data in memory ensuring fast
data access, while on-disk backends store (parts of) their data on
disk and retrieve it on demand.
The Backend functions and implementation notes for new backend
classes section documents the API that a backend must implement.
Currently available backends are:
MsBackendDataFrame: stores all data in memory using a DataFrame.
MsBackendMzR: stores the m/z and intensities on-disk in raw
data files (typically mzML or mzXML) and the spectra
annotation information (header) in memory in a DataFrame. This
backend requires the mzR package.
MsBackendHdf5Peaks: stores the m/z and intensities on-disk in custom hdf5
data files and the remaining spectra variables in memory (in a
DataFrame). This backend requires the rhdf5 package.


See below for more details about individual backends."><meta property="og:image" content="https://rformassspectrometry.github.io/Spectra/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">Spectra</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.7.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item">
  <a class="nav-link" href="../articles/Spectra.html">Get started</a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/RforMassSpectrometry/Spectra/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Mass spectrometry data backends</h1>
      <small class="dont-index">Source: <a href="https://github.com/RforMassSpectrometry/Spectra/blob/HEAD/R/MsBackend.R" class="external-link"><code>R/MsBackend.R</code></a>, <a href="https://github.com/RforMassSpectrometry/Spectra/blob/HEAD/R/MsBackendDataFrame-functions.R" class="external-link"><code>R/MsBackendDataFrame-functions.R</code></a>, <a href="https://github.com/RforMassSpectrometry/Spectra/blob/HEAD/R/MsBackendDataFrame.R" class="external-link"><code>R/MsBackendDataFrame.R</code></a>, and 2 more</small>
      <div class="d-none name"><code>MsBackend.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Note that the classes described here are not meant to be used
directly by the end-users and the material in this man page is
aimed at package developers.</p>
<p><code>MsBackend</code> is a virtual class that defines what each different
backend needs to provide. <code>MsBackend</code> objects provide access to
mass spectrometry data. Such backends can be classified into
<em>in-memory</em> or <em>on-disk</em> backends, depending on where the data, i.e
spectra (m/z and intensities) and spectra annotation (MS level,
charge, polarity, ...) are stored.</p>
<p>Typically, in-memory backends keep all data in memory ensuring fast
data access, while on-disk backends store (parts of) their data on
disk and retrieve it on demand.</p>
<p>The <em>Backend functions and implementation notes for new backend
classes</em> section documents the API that a backend must implement.</p>
<p>Currently available backends are:</p><ul><li><p><code>MsBackendDataFrame</code>: stores all data in memory using a <code>DataFrame</code>.</p></li>
<li><p><code>MsBackendMzR</code>: stores the m/z and intensities on-disk in raw
data files (typically <code>mzML</code> or <code>mzXML</code>) and the spectra
annotation information (header) in memory in a <code>DataFrame</code>. This
backend requires the <code>mzR</code> package.</p></li>
<li><p><code>MsBackendHdf5Peaks</code>: stores the m/z and intensities on-disk in custom hdf5
data files and the remaining spectra variables in memory (in a
<code>DataFrame</code>). This backend requires the <code>rhdf5</code> package.</p></li>
</ul><p>See below for more details about individual backends.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre><code># S4 method for MsBackend
backendInitialize(object, ...)

# S4 method for list
backendMerge(object, ...)

# S4 method for MsBackend
backendMerge(object, ...)

# S4 method for MsBackend
export(object, ...)

# S4 method for MsBackend
acquisitionNum(object)

# S4 method for MsBackend
peaksData(object, columns = c("mz", "intensity"))

# S4 method for MsBackend
peaksVariables(object)

# S4 method for MsBackend
centroided(object)

# S4 method for MsBackend
centroided(object) &lt;- value

# S4 method for MsBackend
collisionEnergy(object)

# S4 method for MsBackend
collisionEnergy(object) &lt;- value

# S4 method for MsBackend
dataOrigin(object)

# S4 method for MsBackend
dataOrigin(object) &lt;- value

# S4 method for MsBackend
dataStorage(object)

# S4 method for MsBackend
dataStorage(object) &lt;- value

# S4 method for MsBackend
dropNaSpectraVariables(object)

# S4 method for MsBackend
filterAcquisitionNum(object, n, file, ...)

# S4 method for MsBackend
filterDataOrigin(object, dataOrigin = character())

# S4 method for MsBackend
filterDataStorage(object, dataStorage = character())

# S4 method for MsBackend
filterEmptySpectra(object, ...)

# S4 method for MsBackend
filterIsolationWindow(object, mz = numeric(), ...)

# S4 method for MsBackend
filterMsLevel(object, msLevel = integer())

# S4 method for MsBackend
filterPolarity(object, polarity = integer())

# S4 method for MsBackend
filterPrecursorMzRange(object, mz = numeric())

# S4 method for MsBackend
filterPrecursorMz(object, mz = numeric())

# S4 method for MsBackend
filterPrecursorMzValues(object, mz = numeric(), ppm = 20, tolerance = 0)

# S4 method for MsBackend
filterPrecursorCharge(object, z = integer())

# S4 method for MsBackend
filterPrecursorScan(object, acquisitionNum = integer(), f = dataOrigin(object))

# S4 method for MsBackend
filterRt(object, rt = numeric(), msLevel. = unique(msLevel(object)))

# S4 method for MsBackend
intensity(object)

# S4 method for MsBackend
intensity(object) &lt;- value

# S4 method for MsBackend
ionCount(object)

# S4 method for MsBackend
isCentroided(object, ...)

# S4 method for MsBackend
isEmpty(x)

# S4 method for MsBackend
isolationWindowLowerMz(object)

# S4 method for MsBackend
isolationWindowLowerMz(object) &lt;- value

# S4 method for MsBackend
isolationWindowTargetMz(object)

# S4 method for MsBackend
isolationWindowTargetMz(object) &lt;- value

# S4 method for MsBackend
isolationWindowUpperMz(object)

# S4 method for MsBackend
isolationWindowUpperMz(object) &lt;- value

# S4 method for MsBackend
isReadOnly(object)

# S4 method for MsBackend
length(x)

# S4 method for MsBackend
msLevel(object)

# S4 method for MsBackend
mz(object)

# S4 method for MsBackend
mz(object) &lt;- value

# S4 method for MsBackend
lengths(x, use.names = FALSE)

# S4 method for MsBackend
polarity(object)

# S4 method for MsBackend
polarity(object) &lt;- value

# S4 method for MsBackend
precScanNum(object)

# S4 method for MsBackend
precursorCharge(object)

# S4 method for MsBackend
precursorIntensity(object)

# S4 method for MsBackend
precursorMz(object)

# S4 method for MsBackend
peaksData(object) &lt;- value

# S4 method for MsBackend
reset(object)

# S4 method for MsBackend
rtime(object)

# S4 method for MsBackend
rtime(object) &lt;- value

# S4 method for MsBackend
scanIndex(object)

# S4 method for MsBackend
selectSpectraVariables(object, spectraVariables = spectraVariables(object))

# S4 method for MsBackend
smoothed(object)

# S4 method for MsBackend
smoothed(object) &lt;- value

# S4 method for MsBackend
spectraData(object, columns = spectraVariables(object))

# S4 method for MsBackend
spectraData(object) &lt;- value

# S4 method for MsBackend
spectraNames(object)

# S4 method for MsBackend
spectraNames(object) &lt;- value

# S4 method for MsBackend
spectraVariables(object)

# S4 method for MsBackend,ANY
split(x, f, drop = FALSE, ...)

# S4 method for MsBackend
tic(object, initial = TRUE)

# S4 method for MsBackend
[(x, i, j, ..., drop = FALSE)

# S4 method for MsBackend
$(x, name)

# S4 method for MsBackend
$(x, name) &lt;- value

# S4 method for MsBackend
[[(x, i, j, ...)

# S4 method for MsBackend
[[(x, i, j, ...) &lt;- value

MsBackendDataFrame()

# S4 method for MsBackendDataFrame
backendInitialize(object, data, ...)

MsBackendHdf5Peaks()

MsBackendMzR()</code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>object</dt>
<dd><p>Object extending <code>MsBackend</code>.</p></dd>
<dt>...</dt>
<dd><p>Additional arguments.</p></dd>
<dt>columns</dt>
<dd><p>For <code>spectraData</code> accessor: optional <code>character</code> with column
names (spectra variables) that should be included in the
returned <code>DataFrame</code>. By default, all columns are returned.
For <code>peaksData</code> accessor: optional <code>character</code> with requested columns in
the individual <code>matrix</code> of the returned <code>list</code>. Defaults to
<code>peaksVariables(object)</code> and depends on what <em>peaks variables</em> the
backend provides.</p></dd>
<dt>value</dt>
<dd><p>replacement value for <code>&lt;-</code> methods. See individual
method description or expected data type.</p></dd>
<dt>n</dt>
<dd><p>for <code>filterAcquisitionNum</code>: <code>integer</code> with the acquisition numbers
to filter for.</p></dd>
<dt>file</dt>
<dd><p>For <code>filterFile</code>: index or name of the file(s) to which the data
should be subsetted. For <code>export</code>: <code>character</code> of length 1 or equal to
the number of spectra.</p></dd>
<dt>dataOrigin</dt>
<dd><p>For <code>filterDataOrigin</code>: <code>character</code> to define which
spectra to keep.
For <code>filterAcquisitionNum</code>: optionally specify if filtering should occurr
only for spectra of selected <code>dataOrigin</code>.</p></dd>
<dt>dataStorage</dt>
<dd><p>For <code>filterDataStorage</code>: <code>character</code> to define which
spectra to keep.
For <code>filterAcquisitionNum</code>: optionally specify if filtering should occur
only for spectra of selected <code>dataStorage</code>.</p></dd>
<dt>mz</dt>
<dd><p>For <code>filterIsolationWindow</code>: <code>numeric(1)</code> with the m/z value to
filter the object. For <code>filterPrecursorMzRange</code>: <code>numeric(2)</code> with the
lower and upper m/z boundary. For <code>filterPrecursorMzValues</code>: <code>numeric</code>
with the m/z value(s) to filter the object.</p></dd>
<dt>msLevel</dt>
<dd><p><code>integer</code> defining the MS level of the spectra to which the
function should be applied. For <code>filterMsLevel</code>: the MS level to which
<code>object</code> should be subsetted.</p></dd>
<dt>polarity</dt>
<dd><p>For <code>filterPolarity</code>: <code>integer</code> specifying the polarity to
to subset <code>object</code>.</p></dd>
<dt>ppm</dt>
<dd><p>For <code>filterPrecursorMzValues</code>: <code>numeric(1)</code> with the m/z-relative
maximal acceptable difference for a m/z to be considered matching. See
<code>closest()</code> for details.</p></dd>
<dt>tolerance</dt>
<dd><p>For <code>filterPrecursorMzValues</code>: <code>numeric(1)</code> with the
maximal absolute acceptable difference for a m/z value to be considered
matching. See <code>closest()</code> for details.</p></dd>
<dt>z</dt>
<dd><p>For <code>filterPrecursorCharge</code>: <code><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer()</a></code> with the precursor charges
to be used as filter.</p></dd>
<dt>acquisitionNum</dt>
<dd><p>for <code>filterPrecursorScan</code>: <code>integer</code> with the
acquisition number of the spectra to which the object should be
subsetted.</p></dd>
<dt>f</dt>
<dd><p><code>factor</code> defining the grouping to split <code>x</code>. See <code><a href="https://rdrr.io/r/base/split.html" class="external-link">split()</a></code>. For
<code>filterPrecursorScan</code>: factor defining from which original data files
the spectra derive to avoid selecting spectra from different
samples/files. Defaults to <code>f = dataOrigin(object)</code>.</p></dd>
<dt>rt</dt>
<dd><p>for <code>filterRt</code>: <code>numeric(2)</code> defining the retention time range to
be used to subset/filter <code>object</code>.</p></dd>
<dt>msLevel.</dt>
<dd><p>same as <code>msLevel</code> above.</p></dd>
<dt>x</dt>
<dd><p>Object extending <code>MsBackend</code>.</p></dd>
<dt>use.names</dt>
<dd><p>For <code>lengths</code>: whether spectrum names should be used.</p></dd>
<dt>spectraVariables</dt>
<dd><p>For <code>selectSpectraVariables</code>: <code>character</code> with the
names of the spectra variables to which the backend should be subsetted.</p></dd>
<dt>drop</dt>
<dd><p>For <code>[</code>: not considered.</p></dd>
<dt>initial</dt>
<dd><p>For <code>tic</code>: <code>logical(1)</code> whether the initially
reported total ion current should be reported, or whether the
total ion current should be (re)calculated on the actual data
(<code>initial = FALSE</code>).</p></dd>
<dt>i</dt>
<dd><p>For <code>[</code>: <code>integer</code>, <code>logical</code> or <code>character</code> to subset the object.</p></dd>
<dt>j</dt>
<dd><p>For <code>[</code>: not supported.</p></dd>
<dt>name</dt>
<dd><p>For <code>$</code> and <code>$&lt;-</code>: the name of the spectra variable to return
or set.</p></dd>
<dt>data</dt>
<dd><p>For <code>backendInitialize</code>: <code>DataFrame</code> with spectrum
metadata/data. This parameter can be empty for <code>MsBackendMzR</code> backends
but needs to be provided for <code>MsBackendDataFrame</code> backends.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>See documentation of respective function.</p>
    </div>
    <div class="section level2">
    <h2 id="implementation-notes">Implementation notes<a class="anchor" aria-label="anchor" href="#implementation-notes"></a></h2>
    


<p>Backends extending <code>MsBackend</code> <strong>must</strong> implement all of its methods (listed
above). Developers of new <code>MsBackend</code>s should follow the
<code>MsBackendDataFrame</code> implementation. To ensure a new implementation being
conform with the <code>MsBackend</code> definition, developers should included test
suites provided by this package in their unit test setup. For that a variable
<code>be</code> should be created in the package's <code>"testthat.R"</code> file that represents
a (initialized) instance of the developed backend. Then the path to the
test suites should be defined with
<code>test_suite &lt;- system.file("test_backends", "test_MsBackend", package = "Spectra")</code> followed by <code>test_dir(test_suite)</code> to run all test
files in that directory. Individual unit test files could be run with
<code>test_file(file.path(test_suite, "test_spectra_variables.R"), stop_on_failure = TRUE)</code> (note that without <code>stop_on_failure = TRUE</code> tests
would fail silently) . Adding this code to the packages <code>"testthat.R"</code> file
ensures that all tests checking the validity of an <code>MsBackend</code> instance
defined in the <code>Spectra</code> package are also run on the newly develped backend
class.</p>
<p>The <code>MsBackend</code> defines the following slots:</p><ul><li><p><code>@readonly</code>: <code>logical(1)</code> whether the backend supports writing/replacing
of m/z or intensity values.</p></li>
</ul><p>Backends extending <code>MsBackend</code> <strong>must</strong> implement all of its methods (listed
above). Developers of new <code>MsBackend</code>s should follow the
<code>MsBackendDataFrame</code> implementation.</p>
<p>The <code><a href="MsBackendCached.html">MsBackendCached()</a></code> backend provides a caching mechanism to allow
<em>read only</em> backends to add or change spectra variables. This
backend shouldn't be used on its own, but is meant to be extended. See
<code><a href="MsBackendCached.html">MsBackendCached()</a></code> for details.</p>
<p>The <code>MsBackend</code> defines the following slots:</p><ul><li><p><code>@readonly</code>: <code>logical(1)</code> whether the backend supports writing/replacing
of m/z or intensity values.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="backend-functions">Backend functions<a class="anchor" aria-label="anchor" href="#backend-functions"></a></h2>
    


<p>New backend classes <strong>must</strong> extend the base <code>MsBackend</code> class and
<strong>have</strong> to implement the following methods:</p><ul><li><p><code>[</code>: subset the backend. Only subsetting by element (<em>row</em>/<code>i</code>) is
allowed</p></li>
<li><p><code>$</code>, <code>$&lt;-</code>: access or set/add a single spectrum variable (column) in the
backend.</p></li>
<li><p><code>[[</code>, <code>[[&lt;-</code>: access or set/add a single spectrum variable (column) in the
backend. The default implementation uses <code>$</code>, thus these methods don't have
to be implemented for new classes extending <code>MsBackend</code>.</p></li>
<li><p><code>acquisitionNum</code>: returns the acquisition number of each
spectrum. Returns an <code>integer</code> of length equal to the number of
spectra (with <code>NA_integer_</code> if not available).</p></li>
<li><p><code>backendInitialize</code>: initialises the backend. This method is
supposed to be called rights after creating an instance of the
backend class and should prepare the backend (e.g. set the data
for the memory backend or read the spectra header data for the
<code>MsBackendMzR</code> backend). This method has to ensure to set the
spectra variable <code>dataStorage</code> correctly.</p></li>
<li><p><code>backendMerge</code>: merges (combines) <code>MsBackend</code> objects into a single
instance. All objects to be merged have to be of the same type (e.g.
<code>MsBackendDataFrame()</code>).</p></li>
<li><p><code>dataOrigin</code>: gets a <code>character</code> of length equal to the number of spectra
in <code>object</code> with the <em>data origin</em> of each spectrum. This could e.g. be
the mzML file from which the data was read.</p></li>
<li><p><code>dataStorage</code>: gets a <code>character</code> of length equal to the number of spectra
in <code>object</code> with the data storage of each spectrum. Note that a
<code>dataStorage</code> of <code>NA_character_</code> is not supported.</p></li>
<li><p><code>dropNaSpectraVariables</code>: removes spectra variables (i.e. columns in the
object's <code>spectraData</code> that contain only missing values (<code>NA</code>). Note that
while columns with only <code>NA</code>s are removed, a <code>spectraData</code> call after
<code>dropNaSpectraVariables</code> might still show columns containing <code>NA</code> values
for <em>core</em> spectra variables.</p></li>
<li><p><code>centroided</code>, <code>centroided&lt;-</code>: gets or sets the centroiding
information of the spectra. <code>centroided</code> returns a <code>logical</code>
vector of length equal to the number of spectra with <code>TRUE</code> if a
spectrum is centroided, <code>FALSE</code> if it is in profile mode and <code>NA</code>
if it is undefined. See also <code>isCentroided</code> for estimating from
the spectrum data whether the spectrum is centroided.  <code>value</code>
for <code>centroided&lt;-</code> is either a single <code>logical</code> or a <code>logical</code> of
length equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>collisionEnergy</code>, <code>collisionEnergy&lt;-</code>: gets or sets the
collision energy for all spectra in <code>object</code>. <code>collisionEnergy</code>
returns a <code>numeric</code> with length equal to the number of spectra
(<code>NA_real_</code> if not present/defined), <code>collisionEnergy&lt;-</code> takes a
<code>numeric</code> of length equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>export</code>: exports data from a <code>Spectra</code> class to a file. This method is
called by the <code>export,Spectra</code> method that passes itself as a second
argument to the function. The <code>export,MsBackend</code> implementation is thus
expected to take a <code>Spectra</code> class as second argument from which all data
is exported. Taking data from a <code>Spectra</code> class ensures that also all
eventual data manipulations (cached in the <code>Spectra</code>'s lazy evaluation
queue) are applied prior to export - this would not be possible with only a
MsBackend class. An example implementation is the <code>export</code> method
for the <code>MsBackendMzR</code> backend that supports export of the data in
<em>mzML</em> or <em>mzXML</em> format. See the documentation for the <code>MsBackendMzR</code>
class below for more information.</p></li>
<li><p><code>filterAcquisitionNum</code>: filters the object keeping only spectra matching
the provided acquisition numbers (argument <code>n</code>). If <code>dataOrigin</code> or
<code>dataStorage</code> is also provided, <code>object</code> is subsetted to the spectra with
an acquisition number equal to <code>n</code> <strong>in spectra with matching dataOrigin
or dataStorage values</strong> retaining all other spectra.</p></li>
<li><p><code>filterDataOrigin</code>: filters the object retaining spectra matching the
provided <code>dataOrigin</code>. Parameter <code>dataOrigin</code> has to be of type
<code>character</code> and needs to match exactly the data origin value of the
spectra to subset.
<code>filterDataOrigin</code> should return the data ordered by the provided
<code>dataOrigin</code> parameter, i.e. if <code>dataOrigin = c("2", "1")</code> was provided,
the spectra in the resulting object should be ordered accordingly (first
spectra from data origin <code>"2"</code> and then from <code>"1"</code>).
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterDataStorage</code>: filters the object retaining spectra matching the
provided <code>dataStorage</code>. Parameter <code>dataStorage</code> has to be of type
<code>character</code> and needs to match exactly the data storage value of the
spectra to subset.
<code>filterDataStorage</code> should return the data ordered by the provided
<code>dataStorage</code> parameter, i.e. if <code>dataStorage = c("2", "1")</code> was provided,
the spectra in the resulting object should be ordered accordingly (first
spectra from data storage <code>"2"</code> and then from <code>"1"</code>).
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterEmptySpectra</code>: removes empty spectra (i.e. spectra without peaks).
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterFile</code>: retains data of files matching the file index or file name
provided with parameter <code>file</code>.</p></li>
<li><p><code>filterIsolationWindow</code>: retains spectra that contain <code>mz</code> in their
isolation window m/z range (i.e. with an <code>isolationWindowLowerMz</code> <code>&lt;=</code> <code>mz</code>
and <code>isolationWindowUpperMz</code> <code>&gt;=</code> <code>mz</code>.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterMsLevel</code>: retains spectra of MS level <code>msLevel</code>.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterPolarity</code>: retains spectra of polarity <code>polarity</code>.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterPrecursorMzRange</code> (previously <code>filterPrecursorMz</code>): retains spectra
with a precursor m/z within the provided m/z range.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterPrecursorMzValues</code>: retains spectra with a precursor m/z matching
any of the provided m/z values (given <code>ppm</code> and <code>tolerance</code>).
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterPrecursorCharge</code>: retains spectra with the defined precursor
charge(s).
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterPrecursorScan</code>: retains parent (e.g. MS1) and children scans (e.g.
MS2) of acquisition number <code>acquisitionNum</code>. Parameter <code>f</code> is supposed to
define the origin of the spectra (i.e. the original data file) to ensure
related spectra from the same file/sample are selected and retained.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>filterRt</code>: retains spectra of MS level <code>msLevel</code> with retention times
within (<code>&gt;=</code>) <code>rt[1]</code> and (<code>&lt;=</code>) <code>rt[2]</code>.
Implementation of this method is optional since a default implementation
for <code>MsBackend</code> is available.</p></li>
<li><p><code>intensity</code>: gets the intensity values from the spectra. Returns
a <code>NumericList()</code> of <code>numeric</code> vectors (intensity values for each
spectrum). The length of the <code>list</code> is equal to the number of
<code>spectra</code> in <code>object</code>.</p></li>
<li><p><code>intensity&lt;-</code>: replaces the intensity values. <code>value</code> has to be a <code>list</code>
(or <code>NumericList()</code>) of length equal to the number of spectra and the
number of values within each list element identical to the number of
peaks in each spectrum (i.e. the <code>lengths(x)</code>). Note that just
writeable backends support this method.</p></li>
<li><p><code>ionCount</code>: returns a <code>numeric</code> with the sum of intensities for
each spectrum. If the spectrum is empty (see <code>isEmpty</code>),
<code>NA_real_</code> is returned.</p></li>
<li><p><code>isCentroided</code>: a heuristic approach assessing if the spectra in
<code>object</code> are in profile or centroided mode. The function takes
the <code>qtl</code> th quantile top peaks, then calculates the difference
between adjacent m/z value and returns <code>TRUE</code> if the first
quartile is greater than <code>k</code>. (See <code>Spectra:::.peaks_is_centroided</code> for
the code.)</p></li>
<li><p><code>isEmpty</code>: checks whether a spectrum in <code>object</code> is empty
(i.e. does not contain any peaks). Returns a <code>logical</code> vector of
length equal number of spectra.</p></li>
<li><p><code>isolationWindowLowerMz</code>, <code>isolationWindowLowerMz&lt;-</code>: gets or sets the
lower m/z boundary of the isolation window.</p></li>
<li><p><code>isolationWindowTargetMz</code>, <code>isolationWindowTargetMz&lt;-</code>: gets or sets the
target m/z of the isolation window.</p></li>
<li><p><code>isolationWindowUpperMz</code>, <code>isolationWindowUpperMz&lt;-</code>: gets or sets the
upper m/z boundary of the isolation window.</p></li>
<li><p><code>isReadOnly</code>: returns a <code>logical(1)</code> whether the backend is <em>read
only</em> or does allow also to write/update data.</p></li>
<li><p><code>length</code>: returns the number of spectra in the object.</p></li>
<li><p><code>lengths</code>: gets the number of peaks (m/z-intensity values) per
spectrum.  Returns an <code>integer</code> vector (length equal to the
number of spectra). For empty spectra, <code>0</code> is returned.</p></li>
<li><p><code>msLevel</code>: gets the spectra's MS level. Returns an <code>integer</code>
vector (of length equal to the number of spectra) with the MS
level for each spectrum (or <code>NA_integer_</code> if not available).</p></li>
<li><p><code>mz</code>: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a <code>NumericList()</code> or length equal to the number of
spectra, each element a <code>numeric</code> vector with the m/z values of
one spectrum.</p></li>
<li><p><code>mz&lt;-</code>: replaces the m/z values. <code>value</code> has to be a <code>list</code> of length equal
to the number of spectra and the number of values within each list element
identical to the number of peaks in each spectrum (i.e. the
<code>lengths(x)</code>). Note that just writeable backends support this method.</p></li>
<li><p><code>polarity</code>, <code>polarity&lt;-</code>: gets or sets the polarity for each
spectrum.  <code>polarity</code> returns an <code>integer</code> vector (length equal
to the number of spectra), with <code>0</code> and <code>1</code> representing negative
and positive polarities, respectively. <code>polarity&lt;-</code> expects an
integer vector of length 1 or equal to the number of spectra.</p></li>
<li><p><code>precursorCharge</code>, <code>precursorIntensity</code>, <code>precursorMz</code>,
<code>precScanNum</code>, <code>precAcquisitionNum</code>: get the charge (<code>integer</code>),
intensity (<code>numeric</code>), m/z (<code>numeric</code>), scan index (<code>integer</code>)
and acquisition number (<code>interger</code>) of the precursor for MS level
2 and above spectra from the object. Returns a vector of length equal to
the number of spectra in <code>object</code>. <code>NA</code> are reported for MS1
spectra of if no precursor information is available.</p></li>
<li><p><code>peaksData</code> returns a <code>list</code> with the spectras' peak data, i.e. numeric
<code>matrix</code> with peak values. The length of the list is equal to the number
of spectra in <code>object</code>. Each element of the list is a <code>numeric</code> <code>matrix</code>
with columns depending on the provided <code>columns</code> parameter (by default
<code>"mz"</code> and <code>"intensity"</code>, but depends on the backend's available
<code>peaksVariables</code>). For an empty spectrum, a <code>matrix</code> with 0 rows and
columns according to <code>columns</code> is returned. The optional parameter
<code>columns</code>, if supported by the backend, allows to define which peak
variables should be returned in the <code>numeric</code> peak <code>matrix</code>. As a default
<code>c("mz", "intensity")</code> should be used.</p></li>
<li><p><code>peaksData&lt;-</code> replaces the peak data (m/z and intensity values) of the
backend. This method expects a <code>list</code> of <code>matrix</code> objects with columns
<code>"mz"</code> and <code>"intensity"</code> that has the same length as the number of
spectra in the backend. Note that just writeable backends support this
method.</p></li>
<li><p><code>peaksVariables</code>: lists the available variables for mass peaks. Default
peak variables are <code>"mz"</code> and <code>"intensity"</code> (which all backends need to
support and provide), but some backends might provide additional variables.
These variables correspond to the column names of the <code>numeric</code> <code>matrix</code>
representing the peak data (returned by <code>peaksData</code>).</p></li>
<li><p><code>reset</code> a backend (if supported). This method will be called on the backend
by the <code>reset,Spectra</code> method that is supposed to restore the data to its
original state (see <code>reset,Spectra</code> for more details). The function
returns the <em>reset</em> backend. The default implementation for <code>MsBackend</code>
returns the backend as-is.</p></li>
<li><p><code>rtime</code>, <code>rtime&lt;-</code>: gets or sets the retention times for each
spectrum (in seconds). <code>rtime</code> returns a <code>numeric</code> vector (length equal to
the number of spectra) with the retention time for each spectrum.
<code>rtime&lt;-</code> expects a numeric vector with length equal to the
number of spectra.</p></li>
<li><p><code>scanIndex</code>: returns an <code>integer</code> vector with the <em>scan index</em>
for each spectrum. This represents the relative index of the
spectrum within each file. Note that this can be different to the
<code>acquisitionNum</code> of the spectrum which is the index of the
spectrum as reported in the mzML file.</p></li>
<li><p><code>selectSpectraVariables</code>: reduces the information within the backend to
the selected spectra variables.</p></li>
<li><p><code>smoothed</code>,<code>smoothed&lt;-</code>: gets or sets whether a spectrum is
<em>smoothed</em>. <code>smoothed</code> returns a <code>logical</code> vector of length equal
to the number of spectra. <code>smoothed&lt;-</code> takes a <code>logical</code> vector
of length 1 or equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>spectraData</code>, <code>spectraData&lt;-</code>: gets or sets general spectrum
metadata (annotation, also called header).  <code>spectraData</code> returns
a <code>DataFrame</code>, <code>spectraData&lt;-</code> expects a <code>DataFrame</code> with the same number
of rows as there are spectra in <code>object</code>. Note that <code>spectraData</code> has to
return the full data, i.e. also the m/z and intensity values (as a <code>list</code>
or <code>SimpleList</code> in columns <code>"mz"</code> and <code>"intensity"</code>.</p></li>
<li><p><code>spectraNames</code>: returns a <code>character</code> vector with the names of
the spectra in <code>object</code> or <code>NULL</code> if not set. <code>spectraNames&lt;-</code> allows to
set spectra names (if the object is not read-only).</p></li>
<li><p><code>spectraVariables</code>: returns a <code>character</code> vector with the
available spectra variables (columns, fields or attributes)
available in <code>object</code>. This should return <strong>all</strong> spectra variables which
are present in <code>object</code>, also <code>"mz"</code> and <code>"intensity"</code> (which are by
default not returned by the <code>spectraVariables,Spectra</code> method).</p></li>
<li><p><code>split</code>: splits the backend into a <code>list</code> of backends (depending on
parameter <code>f</code>). The default method for <code>MsBackend</code> uses <code><a href="https://rdrr.io/r/base/split.html" class="external-link">split.default()</a></code>,
thus backends extending <code>MsBackend</code> don't necessarily need to implement
this method.</p></li>
<li><p><code>tic</code>: gets the total ion current/count (sum of signal of a
spectrum) for all spectra in <code>object</code>. By default, the value
reported in the original raw data file is returned. For an empty
spectrum, <code>NA_real_</code> is returned.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="subsetting-and-merging-backend-classes">Subsetting and merging backend classes<a class="anchor" aria-label="anchor" href="#subsetting-and-merging-backend-classes"></a></h2>
    


<p>Backend classes must support (implement) the <code>[</code> method to subset the object.
This method should only support subsetting by spectra (rows, <code>i</code>) and has
to return a <code>MsBackend</code> class.</p>
<p>Backends extending <code>MsBackend</code> should also implement the <code>backendMerge</code>
method to support combining backend instances (only backend classes of the
same type should be merged). Merging should follow the following rules:</p><ul><li><p>The whole spectrum data of the various objects should be merged. The
resulting merged object should contain the union of the individual objects'
spectra variables (columns/fields), with eventually missing variables in
one object being filled with <code>NA</code>.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="msbackenddataframe-in-memory-ms-data-backend"><code>MsBackendDataFrame</code>, in-memory MS data backend<a class="anchor" aria-label="anchor" href="#msbackenddataframe-in-memory-ms-data-backend"></a></h2>
    


<p>The <code>MsBackendDataFrame</code> objects keep all MS data in memory.</p>
<p>New objects can be created with the <code>MsBackendDataFrame()</code>
function. The backend can be subsequently initialized with the
<code>backendInitialize</code> method, taking a <code>DataFrame</code> with the MS data
as parameter. Suggested columns of this <code>DataFrame</code> are:</p><ul><li><p><code>"msLevel"</code>: <code>integer</code> with MS levels of the spectra.</p></li>
<li><p><code>"rt"</code>: <code>numeric</code> with retention times of the spectra.</p></li>
<li><p><code>"acquisitionNum"</code>: <code>integer</code> with the acquisition number of the spectrum.</p></li>
<li><p><code>"scanIndex"</code>: <code>integer</code> with the index of the scan/spectrum within the
<em>mzML</em>/<em>mzXML</em>/<em>CDF</em> file.</p></li>
<li><p><code>"dataOrigin"</code>: <code>character</code> defining the <em>data origin</em>.</p></li>
<li><p><code>"dataStorage"</code>: <code>character</code> indicating grouping of spectra in different
e.g. input files. Note that missing values are not supported.</p></li>
<li><p><code>"centroided"</code>: <code>logical</code> whether the spectrum is centroided.</p></li>
<li><p><code>"smoothed"</code>: <code>logical</code> whether the spectrum was smoothed.</p></li>
<li><p><code>"polarity"</code>: <code>integer</code> with the polarity information of the spectra.</p></li>
<li><p><code>"precScanNum"</code>: <code>integer</code> specifying the index of the (MS1) spectrum
containing the precursor of a (MS2) spectrum.</p></li>
<li><p><code>"precursorMz"</code>: <code>numeric</code> with the m/z value of the precursor.</p></li>
<li><p><code>"precursorIntensity"</code>: <code>numeric</code> with the intensity value of the
precursor.</p></li>
<li><p><code>"precursorCharge"</code>: <code>integer</code> with the charge of the precursor.</p></li>
<li><p><code>"collisionEnergy"</code>: <code>numeric</code> with the collision energy.</p></li>
<li><p><code>"mz"</code>: <code>NumericList()</code> of <code>numeric</code> vectors representing the m/z values
for each spectrum.</p></li>
<li><p><code>"intensity"</code>: <code>NumericList()</code> of <code>numeric</code> vectors representing the
intensity values for each spectrum.</p></li>
</ul><p>Additional columns are allowed too.</p>
<p>The <code>MsBackendDataFrame</code> ignores parameter <code>columns</code> of the <code>peaksData</code>
function and returns <strong>always</strong> m/z and intensity values.</p>
    </div>
    <div class="section level2">
    <h2 id="msbackendmzr-on-disk-ms-data-backend"><code>MsBackendMzR</code>, on-disk MS data backend<a class="anchor" aria-label="anchor" href="#msbackendmzr-on-disk-ms-data-backend"></a></h2>
    


<p>The <code>MsBackendMzR</code> keeps only a limited amount of data in memory,
while the spectra data (m/z and intensity values) are fetched from
the raw files on-demand. This backend uses the <code>mzR</code> package for
data import and retrieval and hence requires that package to be
installed. Also, it can only be used to import and represent data
stored in <em>mzML</em>, <em>mzXML</em> and <em>CDF</em> files.</p>
<p>The <code>MsBackendMzR</code> backend extends the <code>MsBackendDataFrame</code> backend using
its <code>DataFrame</code> to keep spectra variables (except m/z and intensity) in
memory.</p>
<p>New objects can be created with the <code>MsBackendMzR()</code> function which
can be subsequently filled with data by calling <code>backendInitialize</code>
passing the file names of the input data files with argument <code>files</code>.</p>
<p>This backend provides an <code>export</code> method to export data from a <code>Spectra</code> in
<em>mzML</em> or <em>mzXML</em> format. The definition of the function is:</p>
<p><code>export(object, x, file = tempfile(), format = c("mzML", "mzXML"), copy = FALSE)</code></p>
<p>The parameters are:</p><ul><li><p><code>object</code>: an instance of the <code>MsBackendMzR</code> class.</p></li>
<li><p><code>x</code>: the <a href="Spectra.html">Spectra</a> object to be exported.</p></li>
<li><p><code>file</code>: <code>character</code> with the (full) output file name(s). Should be
of length 1 or equal <code>length(x)</code>. If a single file is specified, all
spectra are exported to that file. Alternatively it is possible to specify
for each spectrum in <code>x</code> the name of the file to which it should be
exported (and hence <code>file</code> has to be of length equal <code>length(x)</code>).</p></li>
<li><p><code>format</code>: <code>character(1)</code>, either <code>"mzML"</code> or <code>"mzXML"</code> defining the output
file format.</p></li>
<li><p><code>copy</code>: <code>logical(1)</code> whether general file information should be copied from
the original MS data files. This only works if <code>x</code> uses a <code>MsBackendMzR</code>
backend and if <code>dataOrigin(x)</code> contains the original MS data file names.</p></li>
<li><p><code>BPPARAM</code>: parallel processing settings.</p></li>
</ul><p>See examples in <a href="Spectra.html">Spectra</a> or the vignette for more details and
examples.</p>
<p>The <code>MsBackendMzR</code> ignores parameter <code>columns</code> of the <code>peaksData</code>
function and returns <strong>always</strong> m/z and intensity values.</p>
    </div>
    <div class="section level2">
    <h2 id="msbackendhdf-peaks-on-disk-ms-data-backend"><code>MsBackendHdf5Peaks</code>, on-disk MS data backend<a class="anchor" aria-label="anchor" href="#msbackendhdf-peaks-on-disk-ms-data-backend"></a></h2>
    


<p>The <code>MsBackendHdf5Peaks</code> keeps, similar to the <code>MsBackendMzR</code>, peak data
(i.e. m/z and intensity values) in custom data files (in HDF5 format) on
disk while the remaining spectra variables are kept in memory. This backend
supports updating and writing of manipulated peak data to the data files.</p>
<p>New objects can be created with the <code>MsBackendHdf5Peaks()</code> function which
can be subsequently filled with data by calling the object's
<code>backendInitialize</code> method passing the desired file names of the HDF5 data
files along with the spectra variables in form of a <code>DataFrame</code> (see
<code>MsBackendDataFrame</code> for the expected format). An optional parameter
<code>hdf5path</code> allows to specify the folder where the HDF5 data files should be
stored to. If provided, this is added as the path to the submitted file
names (parameter <code>files</code>).</p>
<p>By default <code>backendInitialize</code> will store all peak data into a single HDF5
file which name has to be provided with the parameter <code>files</code>. To store peak
data across several HDF5 files <code>data</code> has to contain a column
<code>"dataStorage"</code> that defines the grouping of spectra/peaks into files: peaks
for spectra with the same value in <code>"dataStorage"</code> are saved into the same
HDF5 file. If parameter <code>files</code> is omitted, the value in <code>dataStorage</code> is
used as file name (replacing any file ending with <code>".h5"</code>. To specify the
file names, <code>files</code>' length has to match the number of unique elements in
<code>"dataStorage"</code>.</p>
<p>For details see examples on the <code><a href="Spectra.html">Spectra()</a></code> help page.</p>
<p>The <code>MsBackendHdf5Peaks</code> ignores parameter <code>columns</code> of the <code>peaksData</code>
function and returns <strong>always</strong> m/z and intensity values.</p>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>Johannes Rainer, Sebastian Gibb, Laurent Gatto</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"></span>
<span class="r-in"><span class="co">## The MsBackend class is a virtual class and can not be instantiated</span></span>
<span class="r-in"><span class="co">## directly. Below we define a new backend class extending this virtual</span></span>
<span class="r-in"><span class="co">## class</span></span>
<span class="r-in"><span class="va">MsBackendDummy</span> <span class="op">&lt;-</span> <span class="kw">setClass</span><span class="op">(</span><span class="st">"MsBackendDummy"</span>, contains <span class="op">=</span> <span class="st">"MsBackend"</span><span class="op">)</span></span>
<span class="r-in"><span class="fu">MsBackendDummy</span><span class="op">(</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> An object of class "MsBackendDummy"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Slot "readonly":</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] FALSE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Slot "version":</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "0.1"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## This class inherits now all methods from `MsBackend`, all of which</span></span>
<span class="r-in"><span class="co">## however throw an error. These methods would have to be implemented</span></span>
<span class="r-in"><span class="co">## for the new backend class.</span></span>
<span class="r-in"><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu">mz</span><span class="op">(</span><span class="fu">MsBackendDummy</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Error in .local(object, ...) : Not implemented for MsBackendDummy.</span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## See `MsBackendDataFrame` as a reference implementation for a backend</span></span>
<span class="r-in"><span class="co">## class (in the *R/MsBackendDataFrame.R* file).</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## MsBackendDataFrame</span></span>
<span class="r-in"><span class="co">##</span></span>
<span class="r-in"><span class="co">## The `MsBackendDataFrame` uses a `S4Vectors::DataFrame` to store all MS</span></span>
<span class="r-in"><span class="co">## data. Below we create such a backend by passing a `DataFrame` with all</span></span>
<span class="r-in"><span class="co">## data to it.</span></span>
<span class="r-in"><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">DataFrame</span><span class="op">(</span>msLevel <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1L</span>, <span class="fl">2L</span>, <span class="fl">1L</span><span class="op">)</span>, scanIndex <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span class="r-in"><span class="va">data</span><span class="op">$</span><span class="va">mz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.1</span>, <span class="fl">1.2</span>, <span class="fl">1.3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.4</span>, <span class="fl">54.2</span>, <span class="fl">56.4</span>, <span class="fl">122.1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">15.3</span>, <span class="fl">23.2</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-in"><span class="va">data</span><span class="op">$</span><span class="va">intensity</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">45</span>, <span class="fl">100</span>, <span class="fl">12.2</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">123</span>, <span class="fl">12324.2</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## Backends are supposed to be created with their specific constructor</span></span>
<span class="r-in"><span class="co">## function</span></span>
<span class="r-in"><span class="va">be</span> <span class="op">&lt;-</span> <span class="fu">MsBackendDataFrame</span><span class="op">(</span><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="va">be</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MsBackendDataFrame with 0 spectra</span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## The `backendInitialize` method initializes the backend filling it with</span></span>
<span class="r-in"><span class="co">## data. This method can take any parameters needed for the backend to</span></span>
<span class="r-in"><span class="co">## get loaded with the data (e.g. a file name from which to load the data,</span></span>
<span class="r-in"><span class="co">## a database connection or, in this case, a data frame containing the data).</span></span>
<span class="r-in"><span class="va">be</span> <span class="op">&lt;-</span> <span class="fu"><a href="hidden_aliases.html">backendInitialize</a></span><span class="op">(</span><span class="va">be</span>, <span class="va">data</span><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="va">be</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MsBackendDataFrame with 3 spectra</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     msLevel     rtime scanIndex</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1         1        NA         1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2         2        NA         2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3         1        NA         3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ... 16 more variables/columns.</span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## Data can be accessed with the accessor methods</span></span>
<span class="r-in"><span class="fu">msLevel</span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] 1 2 1</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">mz</span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NumericList of length 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]] 1.1 1.2 1.3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]] 1.4 54.2 56.4 122.1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[3]] 15.3 23.2</span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## Even if no data was provided for all spectra variables, its accessor</span></span>
<span class="r-in"><span class="co">## methods are supposed to return a value.</span></span>
<span class="r-in"><span class="fu">precursorMz</span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] NA NA NA</span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## The `peaksData` method is supposed to return the peaks of the spectra as</span></span>
<span class="r-in"><span class="co">## a `list`.</span></span>
<span class="r-in"><span class="fu"><a href="hidden_aliases.html">peaksData</a></span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## List available peaks variables</span></span>
<span class="r-in"><span class="fu"><a href="hidden_aliases.html">peaksVariables</a></span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "mz"        "intensity"</span>
<span class="r-in"></span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## Use columns to extract specific peaks variables. Below we extract m/z and</span></span>
<span class="r-in"><span class="co">## intensity values, but in reversed order to the default.</span></span>
<span class="r-in"><span class="fu"><a href="hidden_aliases.html">peaksData</a></span><span class="op">(</span><span class="va">be</span>, columns <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"intensity"</span>, <span class="st">"mz"</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## List available spectra variables (i.e. spectrum metadata)</span></span>
<span class="r-in"><span class="fu">spectraVariables</span><span class="op">(</span><span class="va">be</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [1] "msLevel"                 "rtime"                  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [3] "acquisitionNum"          "scanIndex"              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [5] "mz"                      "intensity"              </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [7] "dataStorage"             "dataOrigin"             </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  [9] "centroided"              "smoothed"               </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [11] "polarity"                "precScanNum"            </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [13] "precursorMz"             "precursorIntensity"     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [15] "precursorCharge"         "collisionEnergy"        </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [17] "isolationWindowLowerMz"  "isolationWindowTargetMz"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [19] "isolationWindowUpperMz" </span>
<span class="r-in"></span>
<span class="r-in"><span class="co">## Extract precursor m/z, rtime, MS level spectra variables</span></span>
<span class="r-in"><span class="fu">spectraData</span><span class="op">(</span><span class="va">be</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"precursorMz"</span>, <span class="st">"rtime"</span>, <span class="st">"msLevel"</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> DataFrame with 3 rows and 3 columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   precursorMz     rtime   msLevel</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1          NA        NA         1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2          NA        NA         2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3          NA        NA         1</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by RforMassSpectrometry Package Maintainer, Laurent Gatto, Johannes Rainer, Sebastian Gibb.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.3.9000.</p>
</div>

    </footer></div>

  

  

  </body></html>

