<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The Spectra class to manage and access MS data — addProcessing • Spectra</title>

<!-- favicons -->
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png" />
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png" />

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="The Spectra class to manage and access MS data — addProcessing" />
<meta property="og:description" content="The Spectra class encapsules spectral mass spectrometry data and
related metadata.
It supports multiple data backends, e.g. in-memory (MsBackendDataFrame()),
on-disk as mzML (MsBackendMzR()) or HDF5 (MsBackendHdf5Peaks())." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">Spectra</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.1.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../articles/Spectra.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/RforMassSpectrometry/Spectra/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>The Spectra class to manage and access MS data</h1>
    <small class="dont-index">Source: <a href='https://github.com/RforMassSpectrometry/Spectra/blob/master/R/Spectra-functions.R'><code>R/Spectra-functions.R</code></a>, <a href='https://github.com/RforMassSpectrometry/Spectra/blob/master/R/Spectra.R'><code>R/Spectra.R</code></a></small>
    <div class="hidden name"><code>Spectra.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>The <code>Spectra</code> class encapsules spectral mass spectrometry data and
related metadata.</p>
<p>It supports multiple data backends, e.g. in-memory (<code><a href='MsBackend.html'>MsBackendDataFrame()</a></code>),
on-disk as mzML (<code><a href='MsBackend.html'>MsBackendMzR()</a></code>) or HDF5 (<code><a href='MsBackend.html'>MsBackendHdf5Peaks()</a></code>).</p>
    </div>

    <pre class="usage">addProcessing(object, FUN, ...)

applyProcessing(object, f = dataStorage(object), BPPARAM = bpparam(), ...)

combineSpectra(
  x,
  f = x$dataStorage,
  p = x$dataStorage,
  FUN = combinePeaks,
  ...,
  BPPARAM = bpparam()
)

# S4 method for DataFrame
Spectra(
  object,
  processingQueue = list(),
  metadata = list(),
  ...,
  backend = MsBackendDataFrame(),
  BPPARAM = bpparam()
)

# S4 method for missing
Spectra(
  object,
  processingQueue = list(),
  metadata = list(),
  ...,
  backend = MsBackendDataFrame(),
  BPPARAM = bpparam()
)

# S4 method for MsBackend
Spectra(
  object,
  processingQueue = list(),
  metadata = list(),
  ...,
  BPPARAM = bpparam()
)

# S4 method for character
Spectra(
  object,
  processingQueue = list(),
  metadata = list(),
  source = MsBackendMzR(),
  backend = source,
  ...,
  BPPARAM = bpparam()
)

# S4 method for Spectra,MsBackend
setBackend(object, backend, f = dataStorage(object), ..., BPPARAM = bpparam())

# S4 method for Spectra
c(x, ...)

# S4 method for Spectra,ANY
split(x, f, drop = FALSE, ...)

# S4 method for Spectra
export(object, backend, ...)

# S4 method for Spectra
acquisitionNum(object)

# S4 method for Spectra
peaksData(object, ...)

# S4 method for Spectra
centroided(object)

# S4 method for Spectra
centroided(object) &lt;- value

# S4 method for Spectra
collisionEnergy(object)

# S4 method for Spectra
collisionEnergy(object) &lt;- value

# S4 method for Spectra
dataOrigin(object)

# S4 method for Spectra
dataOrigin(object) &lt;- value

# S4 method for Spectra
dataStorage(object)

# S4 method for Spectra
dropNaSpectraVariables(object)

# S4 method for Spectra
intensity(object, ...)

# S4 method for Spectra
ionCount(object)

# S4 method for Spectra
isCentroided(object, ...)

# S4 method for Spectra
isEmpty(x)

# S4 method for Spectra
isolationWindowLowerMz(object)

# S4 method for Spectra
isolationWindowLowerMz(object) &lt;- value

# S4 method for Spectra
isolationWindowTargetMz(object)

# S4 method for Spectra
isolationWindowTargetMz(object) &lt;- value

# S4 method for Spectra
isolationWindowUpperMz(object)

# S4 method for Spectra
isolationWindowUpperMz(object) &lt;- value

# S4 method for Spectra
containsMz(
  object,
  mz = numeric(),
  tolerance = 0,
  ppm = 20,
  which = c("any", "all"),
  BPPARAM = bpparam()
)

# S4 method for Spectra
containsNeutralLoss(
  object,
  neutralLoss = 0,
  tolerance = 0,
  ppm = 20,
  BPPARAM = bpparam()
)

# S4 method for Spectra
spectrapply(
  object,
  FUN,
  f = as.factor(seq_along(object)),
  ...,
  BPPARAM = SerialParam()
)

# S4 method for Spectra
length(x)

# S4 method for Spectra
msLevel(object)

# S4 method for Spectra
mz(object, ...)

# S4 method for Spectra
lengths(x, use.names = FALSE)

# S4 method for Spectra
polarity(object)

# S4 method for Spectra
polarity(object) &lt;- value

# S4 method for Spectra
precScanNum(object)

# S4 method for Spectra
precursorCharge(object)

# S4 method for Spectra
precursorIntensity(object)

# S4 method for Spectra
precursorMz(object)

# S4 method for Spectra
rtime(object)

# S4 method for Spectra
rtime(object) &lt;- value

# S4 method for Spectra
scanIndex(object)

# S4 method for Spectra
selectSpectraVariables(object, spectraVariables = spectraVariables(object))

# S4 method for Spectra
smoothed(object)

# S4 method for Spectra
smoothed(object) &lt;- value

# S4 method for Spectra
spectraData(object, columns = spectraVariables(object))

# S4 method for Spectra
spectraData(object) &lt;- value

# S4 method for Spectra
spectraNames(object)

# S4 method for Spectra
spectraNames(object) &lt;- value

# S4 method for Spectra
spectraVariables(object)

# S4 method for Spectra
tic(object, initial = TRUE)

# S4 method for Spectra
$(x, name)

# S4 method for Spectra
$(x, name) &lt;- value

# S4 method for Spectra
[(x, i, j, ..., drop = FALSE)

# S4 method for Spectra
filterAcquisitionNum(
  object,
  n = integer(),
  dataStorage = character(),
  dataOrigin = character()
)

# S4 method for Spectra
filterEmptySpectra(object)

# S4 method for Spectra
filterDataOrigin(object, dataOrigin = character())

# S4 method for Spectra
filterDataStorage(object, dataStorage = character())

# S4 method for Spectra
filterIntensity(
  object,
  intensity = c(0, Inf),
  msLevel. = unique(msLevel(object))
)

# S4 method for Spectra
filterIsolationWindow(object, mz = numeric())

# S4 method for Spectra
filterMsLevel(object, msLevel. = integer())

# S4 method for Spectra
filterMzRange(object, mz = numeric(), msLevel. = unique(msLevel(object)))

# S4 method for Spectra
filterMzValues(
  object,
  mz = numeric(),
  tolerance = 0,
  ppm = 20,
  msLevel. = unique(msLevel(object))
)

# S4 method for Spectra
filterPolarity(object, polarity = integer())

# S4 method for Spectra
filterPrecursorMz(object, mz = numeric())

# S4 method for Spectra
filterPrecursorScan(object, acquisitionNum = integer())

# S4 method for Spectra
filterRt(object, rt = numeric(), msLevel. = unique(msLevel(object)))

# S4 method for Spectra
reset(object, ...)

# S4 method for Spectra
bin(x, binSize = 1L, breaks = NULL, msLevel. = unique(msLevel(x)))

# S4 method for Spectra,Spectra
compareSpectra(
  x,
  y,
  MAPFUN = joinPeaks,
  tolerance = 0,
  ppm = 20,
  FUN = ndotproduct,
  ...,
  SIMPLIFY = TRUE
)

# S4 method for Spectra,missing
compareSpectra(
  x,
  y = NULL,
  MAPFUN = joinPeaks,
  tolerance = 0,
  ppm = 20,
  FUN = ndotproduct,
  ...,
  SIMPLIFY = TRUE
)

# S4 method for Spectra
pickPeaks(
  object,
  halfWindowSize = 2L,
  method = c("MAD", "SuperSmoother"),
  snr = 0,
  k = 0L,
  descending = FALSE,
  threshold = 0,
  msLevel. = unique(msLevel(object))
)

# S4 method for Spectra
replaceIntensitiesBelow(
  object,
  threshold = min,
  value = 0,
  msLevel. = unique(msLevel(object))
)

# S4 method for Spectra
smooth(
  x,
  halfWindowSize = 2L,
  method = c("MovingAverage", "WeightedMovingAverage", "SavitzkyGolay"),
  ...,
  msLevel. = unique(msLevel(x))
)</pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>object</th>
      <td><p>For <code>Spectra</code>: either a <code>DataFrame</code> or <code>missing</code>. See section
on creation of <code>Spectra</code> objects for details. For all other methods a
<code>Spectra</code> object.</p></td>
    </tr>
    <tr>
      <th>FUN</th>
      <td><p>For <code>addProcessing</code>: function to be applied to the peak matrix
of each spectrum in <code>object</code>. For <code>compareSpectra</code>: function to compare
intensities of peaks between two spectra with each other.
For <code>combineSpectra</code>: function to combine the (peak matrices) of the
spectra. See section <em>Data manipulations</em> and examples below for more
details.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Additional arguments.</p></td>
    </tr>
    <tr>
      <th>f</th>
      <td><p>For <code>split</code>: factor defining how to split <code>x</code>. See <code><a href='https://rdrr.io/r/base/split.html'>base::split()</a></code>
for details. For <code>setBackend</code>: factor defining how to split the data for
parallelized copying of the spectra data to the new backend. For some
backends changing this parameter can lead to errors.
For <code>combineSpectra</code>: <code>factor</code> defining the grouping of the spectra that
should be combined. For <code>spectrapply</code>: <code>factor</code> how <code>object</code> should be
splitted.</p></td>
    </tr>
    <tr>
      <th>BPPARAM</th>
      <td><p>Parallel setup configuration. See <code>bpparam()</code> for more
information. This is passed directly to the <code><a href='hidden_aliases.html'>backendInitialize()</a></code> method
of the <a href='MsBackend.html'>MsBackend</a>.</p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>A <code>Spectra</code> object.</p></td>
    </tr>
    <tr>
      <th>p</th>
      <td><p>For <code>combineSpectra</code>: <code>factor</code> defining how to split the input
<code>Spectra</code> for parallel processing. Defaults to <code>x$dataStorage</code>, i.e.,
depending on the used backend, per-file parallel processing will be
performed.</p></td>
    </tr>
    <tr>
      <th>processingQueue</th>
      <td><p>For <code>Spectra</code>: optional <code>list</code> of
<a href='hidden_aliases.html'>ProcessingStep</a> objects.</p></td>
    </tr>
    <tr>
      <th>metadata</th>
      <td><p>For <code>Spectra</code>: optional <code>list</code> with metadata information.</p></td>
    </tr>
    <tr>
      <th>backend</th>
      <td><p>For <code>Spectra</code>: <a href='MsBackend.html'>MsBackend</a> to be used as backend. See
section on creation of <code>Spectra</code> objects for details. For <code>setBackend</code>:
instance of <a href='MsBackend.html'>MsBackend</a>. See section on creation of <code>Spectra</code>
objects for details. For <code>export</code>: <a href='MsBackend.html'>MsBackend</a> to be used to export
the data.</p></td>
    </tr>
    <tr>
      <th>source</th>
      <td><p>For <code>Spectra</code>: instance of <a href='MsBackend.html'>MsBackend</a> that can be used
to import spectrum data from the provided files. See section <em>Creation
of objects, conversion and changing the backend</em> for more details.</p></td>
    </tr>
    <tr>
      <th>drop</th>
      <td><p>For <code><a href='https://rdrr.io/r/base/Extract.html'>[</a></code>, <code>split</code>: not considered.</p></td>
    </tr>
    <tr>
      <th>value</th>
      <td><p>replacement value for <code>&lt;-</code> methods. See individual
method description or expected data type.</p></td>
    </tr>
    <tr>
      <th>mz</th>
      <td><p>For <code>filterIsolationWindow</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code> with the m/z value to
filter the object. For <code>filterPrecursorMz</code> and <code>filterMzRange</code>:
<code><a href='https://rdrr.io/r/base/numeric.html'>numeric(2)</a></code> defining the lower and upper m/z boundary.
For <code>filterMzValues</code>: <code>numeric</code> with the m/z values to match peaks
against.</p></td>
    </tr>
    <tr>
      <th>tolerance</th>
      <td><p>For <code>compareSpectra</code>, <code>containsMz</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code> allowing to
define a constant maximal accepted difference between m/z values for
peaks to be matched. For <code>containsMz</code> and <code>filterMzValues</code> it can also
be of length equal <code>mz</code> to specify a different tolerance for each m/z
value.</p></td>
    </tr>
    <tr>
      <th>ppm</th>
      <td><p>For <code>compareSpectra</code>, <code>containsMz</code>, <code>filterMzValues</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code>
defining a relative, m/z-dependent, maximal accepted difference between
m/z values for peaks to be matched.</p></td>
    </tr>
    <tr>
      <th>which</th>
      <td><p>for <code>containsMz</code>: either <code>"any"</code> or <code>"all"</code> defining whether any
(the default) or all provided <code>mz</code> have to be present in the spectrum.</p></td>
    </tr>
    <tr>
      <th>neutralLoss</th>
      <td><p>for <code>containsNeutralLoss</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code> defining the value
which should be subtracted from the spectrum's precursor m/z.</p></td>
    </tr>
    <tr>
      <th>use.names</th>
      <td><p>For <code>lengths</code>: ignored.</p></td>
    </tr>
    <tr>
      <th>spectraVariables</th>
      <td><p>For <code>selectSpectraVariables</code>: <code>character</code> with the
names of the spectra variables to which the backend should be subsetted.</p></td>
    </tr>
    <tr>
      <th>columns</th>
      <td><p>For <code>spectraData</code> accessor: optional <code>character</code> with column
names (spectra variables) that should be included in the
returned <code>DataFrame</code>. By default, all columns are returned.</p></td>
    </tr>
    <tr>
      <th>initial</th>
      <td><p>For <code>tic</code>: <code><a href='https://rdrr.io/r/base/logical.html'>logical(1)</a></code> whether the initially
reported total ion current should be reported, or whether the
total ion current should be (re)calculated on the actual data
(<code>initial = FALSE</code>, same as <code>ionCount</code>).</p></td>
    </tr>
    <tr>
      <th>name</th>
      <td><p>For <code><a href='https://rdrr.io/r/base/Extract.html'>$</a></code> and <code>$&lt;-</code>: the name of the spectra variable to return
or set.</p></td>
    </tr>
    <tr>
      <th>i</th>
      <td><p>For <code><a href='https://rdrr.io/r/base/Extract.html'>[</a></code>: <code>integer</code>, <code>logical</code> or <code>character</code> to subset the object.</p></td>
    </tr>
    <tr>
      <th>j</th>
      <td><p>For <code><a href='https://rdrr.io/r/base/Extract.html'>[</a></code>: not supported.</p></td>
    </tr>
    <tr>
      <th>n</th>
      <td><p>for <code>filterAcquisitionNum</code>: <code>integer</code> with the acquisition numbers
to filter for.</p></td>
    </tr>
    <tr>
      <th>dataStorage</th>
      <td><p>For <code>filterDataStorage</code>: <code>character</code> to define which
spectra to keep.
For <code>filterAcquisitionNum</code>: optionally specify if filtering should occur
only for spectra of selected <code>dataStorage</code>.</p></td>
    </tr>
    <tr>
      <th>dataOrigin</th>
      <td><p>For <code>filterDataOrigin</code>: <code>character</code> to define which
spectra to keep.
For <code>filterAcquisitionNum</code>: optionally specify if filtering should occurr
only for spectra of selected <code>dataOrigin</code>.</p></td>
    </tr>
    <tr>
      <th>intensity</th>
      <td><p>For <code>filterIntensity</code>: <code>numeric</code> of length 1 or 2 defining
either the lower or the lower and upper intensity limit for the
filtering, or a <code>function</code> that takes the intensities as input and
returns a <code>logical</code> (same length then peaks in the spectrum) whether the
peak should be retained or not. Defaults to <code>intensity = c(0, Inf)</code> thus
only peaks with <code>NA</code> intensity are removed.</p></td>
    </tr>
    <tr>
      <th>msLevel.</th>
      <td><p><code>integer</code> defining the MS level(s) of the spectra to which
the function should be applied (defaults to all MS levels of <code>object</code>.
For <code>filterMsLevel</code>: the MS level to which <code>object</code> should be subsetted.</p></td>
    </tr>
    <tr>
      <th>polarity</th>
      <td><p>for <code>filterPolarity</code>: <code>integer</code> specifying the polarity to
to subset <code>object</code>.</p></td>
    </tr>
    <tr>
      <th>acquisitionNum</th>
      <td><p>for <code>filterPrecursorScan</code>: <code>integer</code> with the
acquisition number of the spectra to which the object should be
subsetted.</p></td>
    </tr>
    <tr>
      <th>rt</th>
      <td><p>for <code>filterRt</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(2)</a></code> defining the retention time range to
be used to subset/filter <code>object</code>.</p></td>
    </tr>
    <tr>
      <th>binSize</th>
      <td><p>For <code>bin</code>: <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code> defining the size for the m/z bins.
Defaults to <code>binSize = 1</code>.</p></td>
    </tr>
    <tr>
      <th>breaks</th>
      <td><p>For <code>bin</code>: <code>numeric</code> defining the m/z breakpoints between bins.</p></td>
    </tr>
    <tr>
      <th>y</th>
      <td><p>A <code>Spectra</code> object.</p></td>
    </tr>
    <tr>
      <th>MAPFUN</th>
      <td><p>For <code>compareSpectra</code>: function to map/match peaks between the
two compared spectra. See <code><a href='joinPeaks.html'>joinPeaks()</a></code> for more information and possible
functions.</p></td>
    </tr>
    <tr>
      <th>SIMPLIFY</th>
      <td><p>For <code>compareSpectra</code> whether the result matrix should be
<em>simplified</em> to a <code>numeric</code> if possible (i.e. if either <code>x</code> or <code>y</code> is
of length 1).</p></td>
    </tr>
    <tr>
      <th>halfWindowSize</th>
      <td><ul>
<li><p>For <code>pickPeaks</code>: <code><a href='https://rdrr.io/r/base/integer.html'>integer(1)</a></code>, used in the
identification of the mass peaks: a local maximum has to be the maximum
in the window from <code>(i - halfWindowSize):(i + halfWindowSize)</code>.</p></li>
<li><p>For <code>smooth</code>: <code><a href='https://rdrr.io/r/base/integer.html'>integer(1)</a></code>, used in the smoothing algorithm, the window
reaches from <code>(i - halfWindowSize):(i + halfWindowSize)</code>.</p></li>
</ul></td>
    </tr>
    <tr>
      <th>method</th>
      <td><ul>
<li><p>For <code>pickPeaks</code>: <code><a href='https://rdrr.io/r/base/character.html'>character(1)</a></code>, the noise estimators that
should be used, currently the the <em>M</em>edian <em>A</em>bsolute <em>D</em>eviation
(<code>method = "MAD"</code>) and Friedman's Super Smoother
(<code>method = "SuperSmoother"</code>) are supported.</p></li>
<li><p>For <code>smooth</code>: <code><a href='https://rdrr.io/r/base/character.html'>character(1)</a></code>, the smoothing function that should be used,
currently, the Moving-Average- (<code>method = "MovingAverage"</code>),
Weighted-Moving-Average- (<code>method = "WeightedMovingAverage")</code>,
Savitzky-Golay-Smoothing (<code>method = "SavitzkyGolay"</code>) are supported.</p></li>
</ul></td>
    </tr>
    <tr>
      <th>snr</th>
      <td><p>For <code>pickPeaks</code>: <code><a href='https://rdrr.io/r/base/double.html'>double(1)</a></code> defining the
<em>S</em>ignal-to-<em>N</em>oise-<em>R</em>atio. The intensity of a local maximum has to be
higher than <code>snr * noise</code> to be considered as peak.</p></td>
    </tr>
    <tr>
      <th>k</th>
      <td><p>For <code>pickPeaks</code>: <code><a href='https://rdrr.io/r/base/integer.html'>integer(1)</a></code>, number of values left and right of
the peak that should be considered in the weighted mean calculation.</p></td>
    </tr>
    <tr>
      <th>descending</th>
      <td><p>For <code>pickPeaks</code>: <code>logical</code>, if <code>TRUE</code> just values between
the nearest valleys around the peak centroids are used.</p></td>
    </tr>
    <tr>
      <th>threshold</th>
      <td><ul>
<li><p>For <code>pickPeaks</code>: a <code><a href='https://rdrr.io/r/base/double.html'>double(1)</a></code> defining the proportion of the maximal peak
intensity. Just values above are used for the weighted mean calculation.</p></li>
<li><p>For <code>replaceIntensitiesBelow</code>: a <code><a href='https://rdrr.io/r/base/numeric.html'>numeric(1)</a></code> defining the threshold or
a <code>function</code> to calculate the threshold for each spectrum on its intensity
values. Defaults to <code>threshold = min</code>.</p></li>
</ul></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>See individual method description for the return value.</p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The <code>Spectra</code> class uses by default a lazy data manipulation strategy,
i.e. data manipulations such as performed with <code>replaceIntensitiesBelow</code> are
not applied immediately to the data, but applied on-the-fly to the spectrum
data once it is retrieved. For some backends that allow to write data back
to the data storage (such as the <code><a href='MsBackend.html'>MsBackendDataFrame()</a></code> and
<code><a href='MsBackend.html'>MsBackendHdf5Peaks()</a></code>) it is possible to apply to queue with the
<code>applyProcessing</code> function. See the <em>Data manipulation and analysis
methods</em> section below for more details.</p>
<p>For details on plotting spectra, see <code><a href='spectra-plotting.html'>plotSpectra()</a></code>.</p>
<p>Clarifications regarding scan/acquisition numbers and indices:</p><ul>
<li><p>A <code>spectrumId</code> (or <code>spectrumID</code>) is a vendor specific field in
the mzML file that contains some information about the
run/spectrum, e.g.: <code>controllerType=0 controllerNumber=1 scan=5281 file=2</code></p></li>
<li><p><code>acquisitionNum</code> is a more a less sanitize spectrum id generated
from the <code>spectrumId</code> field by <code>mzR</code> (see
<a href='https://github.com/sneumann/mzR/blob/master/src/pwiz/data/msdata/MSData.cpp#L552-L580'>here</a>).</p></li>
<li><p><code>scanIndex</code> is the <code>mzR</code> generated sequence number of the
spectrum in the raw file (which doesn't have to be the same as
the <code>acquisitionNum</code>)</p></li>
</ul>

<p>See also <a href='https://github.com/lgatto/MSnbase/issues/525'>this issue</a>.</p>
    <h2 class="hasAnchor" id="creation-of-objects-conversion-changing-the-backend-and-export"><a class="anchor" href="#creation-of-objects-conversion-changing-the-backend-and-export"></a>Creation of objects, conversion, changing the backend and export</h2>

    


<p><code>Spectra</code> classes can be created with the <code>Spectra</code> constructor function
which supports the following formats:</p><ul>
<li><p>parameter <code>object</code> is a <code>DataFrame</code> containing the spectrum data. The
provided <code>backend</code> (by default a <a href='MsBackend.html'>MsBackendDataFrame</a>) will be
initialized with that data.</p></li>
<li><p>parameter <code>object</code> is a <a href='MsBackend.html'>MsBackend</a> (assumed to be already
initialized).</p></li>
<li><p>parameter <code>object</code> is missing, in which case it is supposed that the data
is provided by the <a href='MsBackend.html'>MsBackend</a> class passed along with the <code>backend</code>
argument.</p></li>
<li><p>parameter <code>object</code> is of type <code>character</code> and is expected to be the file
names(s) from which spectra should be imported. Parameter <code>source</code> allows
to define a <a href='MsBackend.html'>MsBackend</a> that is able to import the data from the
provided source files. The default value for <code>source</code> is <code><a href='MsBackend.html'>MsBackendMzR()</a></code>
which allows to import spectra data from mzML, mzXML or CDF files.</p></li>
</ul>

<p>With <code>...</code> additional arguments can be passed to the backend's
<code><a href='hidden_aliases.html'>backendInitialize()</a></code> method. Parameter <code>backend</code> allows to specify which
<a href='MsBackend.html'>MsBackend</a> should be used for data storage.</p>
<p>The backend of a <code>Spectra</code> object can be changed with the <code>setBackend</code>
method that takes an instance of the new backend as second parameter
<code>backend</code>. A call to <code><a href='hidden_aliases.html'>setBackend(sps, backend = MsBackendDataFrame())</a></code> would
for example change the backend or <code>sps</code> to the <em>in-memory</em>
<code>MsBackendDataFrame</code>. Note that it is not possible to change the backend
to a <em>read-only</em> backend (such as the <code><a href='MsBackend.html'>MsBackendMzR()</a></code> backend). <code>setBackend</code>
changes the <code>"dataOrigin"</code> variable of the resulting <code>Spectra</code> object to the
<code>"dataStorage"</code> variable of the backend before the switch.</p>
<p>The definition of the function is:
<code><a href='hidden_aliases.html'>setBackend(object, backend, ..., f = dataStorage(object), BPPARAM = bpparam())</a></code> and its parameters are:</p><ul>
<li><p>parameter <code>object</code>: the <code>Spectra</code> object.</p></li>
<li><p>parameter <code>backend</code>: an instance of the new backend, e.g.
<code><a href='MsBackend.html'>MsBackendDataFrame()</a></code>.</p></li>
<li><p>parameter <code>f</code>: factor allowing to parallelize the change of the backends.
By default the process of copying the spectra data from the original to the
new backend is performed separately (and in parallel) for each file. Users
are advised to use the default setting.</p></li>
<li><p>parameter <code>...</code>: optional additional arguments passed to the
<code><a href='hidden_aliases.html'>backendInitialize()</a></code> method of the new <code>backend</code>.</p></li>
<li><p>parameter <code>BPPARAM</code>: setup for the parallel processing. See <code>bpparam()</code> for
details.</p></li>
</ul>

<p>Data from a <code>Spectra</code> object can be <strong>exported</strong> to a file with the <code>export</code>
function. The actual export of the data has to be performed by the <code>export</code>
method of the <a href='MsBackend.html'>MsBackend</a> class defined with the mandatory parameter
<code>backend</code>. Note however that not all backend classes support export of data.
From the <code>MsBackend</code> classes in the <code>Spectra</code> package currently only the
<code>MsBackendMzR</code> backend supports data export (to mzML/mzXML file(s));
see the help page of the <a href='MsBackend.html'>MsBackend</a> for information on its arguments
or the examples below or the vignette for examples.</p>
<p>The definition of the function is
<code><a href='hidden_aliases.html'>export(object, backend,  ...)</a></code> and its
parameters are:</p><ul>
<li><p><code>object</code>: the <code>Spectra</code> object to be exported.</p></li>
<li><p><code>backend</code>: instance of a class extending <a href='MsBackend.html'>MsBackend</a> which supports export
of the data (i.e. which has a defined <code>export</code> method).</p></li>
<li><p><code>...</code>: additional parameters specific for the <code>MsBackend</code> passed with
parameter <code>backend</code>.</p></li>
</ul>

    <h2 class="hasAnchor" id="accessing-spectra-data"><a class="anchor" href="#accessing-spectra-data"></a>Accessing spectra data</h2>

    

<ul>
<li><p><code><a href='https://rdrr.io/r/base/Extract.html'>$</a></code>, <code>$&lt;-</code>: gets (or sets) a spectra variable for all spectra in <code>object</code>.
See examples for details.</p></li>
<li><p><code>acquisitionNum</code>: returns the acquisition number of each
spectrum. Returns an <code>integer</code> of length equal to the number of
spectra (with <code>NA_integer_</code> if not available).</p></li>
<li><p><code>peaksData</code>: gets the <em>peaks</em> matrices for all spectra in <code>object</code>. The
function returns a <code>SimpleList()</code> of matrices, each <code>matrix</code> with columns
<code>"mz"</code> and <code>"intensity"</code> with the m/z and intensity values for all peaks of
a spectrum. Note that it is also possible to extract the peaks matrices
with <code>as(x, "list")</code> and <code>as(x, "SimpleList")</code> as a <code>list</code> and
<code>SimpleList</code>, respectively.</p></li>
<li><p><code>centroided</code>, <code>centroided&lt;-</code>: gets or sets the centroiding
information of the spectra. <code>centroided</code> returns a <code>logical</code>
vector of length equal to the number of spectra with <code>TRUE</code> if a
spectrum is centroided, <code>FALSE</code> if it is in profile mode and <code>NA</code>
if it is undefined. See also <code>isCentroided</code> for estimating from
the spectrum data whether the spectrum is centroided.  <code>value</code>
for <code>centroided&lt;-</code> is either a single <code>logical</code> or a <code>logical</code> of
length equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>collisionEnergy</code>, <code>collisionEnergy&lt;-</code>: gets or sets the
collision energy for all spectra in <code>object</code>. <code>collisionEnergy</code>
returns a <code>numeric</code> with length equal to the number of spectra
(<code>NA_real_</code> if not present/defined), <code>collisionEnergy&lt;-</code> takes a
<code>numeric</code> of length equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>dataOrigin</code>, <code>dataOrigin&lt;-</code>: gets or sets the <em>data origin</em> for each
spectrum. <code>dataOrigin</code> returns a <code>character</code> vector (same length than
<code>object</code>) with the origin of the spectra. <code>dataOrigin&lt;-</code> expects a
<code>character</code> vector (same length than <code>object</code>) with the replacement
values for the data origin of each spectrum.</p></li>
<li><p><code>dataStorage</code>: returns a <code>character</code> vector (same length than <code>object</code>)
with the data storage location of each spectrum.</p></li>
<li><p><code>intensity</code>: gets the intensity values from the spectra. Returns
a <code>NumericList()</code> of <code>numeric</code> vectors (intensity values for each
spectrum). The length of the list is equal to the number of
<code>spectra</code> in <code>object</code>.</p></li>
<li><p><code>ionCount</code>: returns a <code>numeric</code> with the sum of intensities for
each spectrum. If the spectrum is empty (see <code>isEmpty</code>),
<code>NA_real_</code> is returned.</p></li>
<li><p><code>isCentroided</code>: a heuristic approach assessing if the spectra in
<code>object</code> are in profile or centroided mode. The function takes
the <code>qtl</code>th quantile top peaks, then calculates the difference
between adjacent m/z value and returns <code>TRUE</code> if the first
quartile is greater than <code>k</code>. (See <code>Spectra:::.isCentroided</code> for
the code.)</p></li>
<li><p><code>isEmpty</code>: checks whether a spectrum in <code>object</code> is empty
(i.e. does not contain any peaks). Returns a <code>logical</code> vector of
length equal number of spectra.</p></li>
<li><p><code>isolationWindowLowerMz</code>, <code>isolationWindowLowerMz&lt;-</code>: gets or sets the
lower m/z boundary of the isolation window.</p></li>
<li><p><code>isolationWindowTargetMz</code>, <code>isolationWindowTargetMz&lt;-</code>: gets or sets the
target m/z of the isolation window.</p></li>
<li><p><code>isolationWindowUpperMz</code>, <code>isolationWindowUpperMz&lt;-</code>: gets or sets the
upper m/z boundary of the isolation window.</p></li>
<li><p><code>containsMz</code>: checks for each of the spectra whether they contain mass
peaks with an m/z equal to <code>mz</code> (given acceptable difference as defined by
parameters <code>tolerance</code> and <code>ppm</code> - see <code>common()</code> for details). Parameter
<code>which</code> allows to define whether any (<code>which = "any"</code>, the default) or
all (<code>which = "all"</code>) of the <code>mz</code> have to match. The function returns
<code>NA</code> if <code>mz</code> is of length 0 or is <code>NA</code>.</p></li>
<li><p><code>containsNeutralLoss</code>: checks for each spectrum in <code>object</code> if it has a
peak with an m/z value equal to its precursor m/z - <code>neutralLoss</code> (given
acceptable difference as defined by parameters <code>tolerance</code> and <code>ppm</code>).
Returns <code>NA</code> for MS1 spectra (or spectra without a precursor m/z).</p></li>
<li><p><code>length</code>: gets the number of spectra in the object.</p></li>
<li><p><code>lengths</code>: gets the number of peaks (m/z-intensity values) per
spectrum. Returns an <code>integer</code> vector (length equal to the
number of spectra). For empty spectra, <code>0</code> is returned.</p></li>
<li><p><code>msLevel</code>: gets the spectra's MS level. Returns an integer vector (names
being spectrum names, length equal to the number of spectra) with the MS
level for each spectrum.</p></li>
<li><p><code>mz</code>: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a <code>NumericList()</code> or length equal to the number of
spectra, each element a <code>numeric</code> vector with the m/z values of
one spectrum.</p></li>
<li><p><code>polarity</code>, <code>polarity&lt;-</code>: gets or sets the polarity for each
spectrum.  <code>polarity</code> returns an <code>integer</code> vector (length equal
to the number of spectra), with <code>0</code> and <code>1</code> representing negative
and positive polarities, respectively. <code>polarity&lt;-</code> expects an
<code>integer</code> vector of length 1 or equal to the number of spectra.</p></li>
<li><p><code>precursorCharge</code>, <code>precursorIntensity</code>, <code>precursorMz</code>,
<code>precScanNum</code>, <code>precAcquisitionNum</code>: gets the charge (<code>integer</code>),
intensity (<code>numeric</code>), m/z (<code>numeric</code>), scan index (<code>integer</code>)
and acquisition number (<code>interger</code>) of the precursor for MS level &gt;
2 spectra from the object. Returns a vector of length equal to
the number of spectra in <code>object</code>. <code>NA</code> are reported for MS1
spectra of if no precursor information is available.</p></li>
<li><p><code>rtime</code>, <code>rtime&lt;-</code>: gets or sets the retention times (in seconds)
for each spectrum.  <code>rtime</code> returns a <code>numeric</code> vector (length
equal to the number of spectra) with the retention time for each
spectrum.  <code>rtime&lt;-</code> expects a numeric vector with length equal
to the number of spectra.</p></li>
<li><p><code>scanIndex</code>: returns an <code>integer</code> vector with the <em>scan index</em>
for each spectrum. This represents the relative index of the
spectrum within each file. Note that this can be different to the
<code>acquisitionNum</code> of the spectrum which represents the index of the
spectrum during acquisition/measurement (as reported in the mzML file).</p></li>
<li><p><code>smoothed</code>,<code>smoothed&lt;-</code>: gets or sets whether a spectrum is
<em>smoothed</em>. <code>smoothed</code> returns a <code>logical</code> vector of length equal
to the number of spectra. <code>smoothed&lt;-</code> takes a <code>logical</code> vector
of length 1 or equal to the number of spectra in <code>object</code>.</p></li>
<li><p><code>spectraData</code>: gets general spectrum metadata (annotation, also called
header). <code>spectraData</code> returns a <code>DataFrame</code>. Note that this
method does by default <strong>not</strong> return m/z or intensity values.</p></li>
<li><p><code>spectraData&lt;-</code>: <strong>replaces</strong> the full spectra data of the <code>Spectra</code>
object with the one provided with <code>value</code>. The use of this function is
disencouraged, as replacing spectra data with values that are in a
different can break the linkage with the associated m/z and intensity
values. If possible, spectra variables (i.e. <em>columns</em> of the <code>Spectra</code>)
should be replaced individually. The <code>spectraData&lt;-</code> function expects a
<code>DataFrame</code> to be passed as value.</p></li>
<li><p><code>spectraNames</code>, <code>spectraNames&lt;-</code>: gets or sets the spectra names.</p></li>
<li><p><code>spectraVariables</code>: returns a <code>character</code> vector with the
available spectra variables (columns, fields or attributes)
available in <code>object</code>.</p></li>
<li><p><code>tic</code>: gets the total ion current/count (sum of signal of a
spectrum) for all spectra in <code>object</code>. By default, the value
reported in the original raw data file is returned. For an empty
spectrum, <code>0</code> is returned.</p></li>
</ul>

    <h2 class="hasAnchor" id="data-subsetting-filtering-and-merging"><a class="anchor" href="#data-subsetting-filtering-and-merging"></a>Data subsetting, filtering and merging</h2>

    


<p>Subsetting and filtering of <code>Spectra</code> objects can be performed with the below
listed methods.</p><ul>
<li><p><code><a href='https://rdrr.io/r/base/Extract.html'>[</a></code>: subsets the spectra keeping only selected elements (<code>i</code>). The method
<strong>always</strong> returns a <code>Spectra</code> object.</p></li>
<li><p><code>dropNaSpectraVariables</code>: removes spectra variables (i.e. columns in the
object's <code>spectraData</code> that contain only missing values (<code>NA</code>). Note that
while columns with only <code>NA</code>s are removed, a <code>spectraData</code> call after
<code>dropNaSpectraVariables</code> might still show columns containing <code>NA</code> values
for <em>core</em> spectra variables.</p></li>
<li><p><code>filterAcquisitionNum</code>: filters the object keeping only spectra matching
the provided acquisition numbers (argument <code>n</code>). If <code>dataOrigin</code> or
<code>dataStorage</code> is also provided, <code>object</code> is subsetted to the spectra with
an acquisition number equal to <code>n</code> <strong>in spectra with matching dataOrigin
or dataStorage values</strong> retaining all other spectra.
Returns the filtered <code>Spectra</code>.</p></li>
<li><p><code>filterDataOrigin</code>: filters the object retaining spectra matching the
provided <code>dataOrigin</code>. Parameter <code>dataOrigin</code> has to be of type
<code>character</code> and needs to match exactly the data origin value of the
spectra to subset.
Returns the filtered <code>Spectra</code> object (with spectra ordered according to
the provided <code>dataOrigin</code> parameter).</p></li>
<li><p><code>filterDataStorage</code>: filters the object retaining spectra stored in the
specified <code>dataStorage</code>. Parameter <code>dataStorage</code> has to be of type
<code>character</code> and needs to match exactly the data storage value of the
spectra to subset.
Returns the filtered <code>Spectra</code> object (with spectra ordered according to
the provided <code>dataStorage</code> parameter).</p></li>
<li><p><code>filterEmptySpectra</code>: removes empty spectra (i.e. spectra without peaks).
Returns the filtered <code>Spectra</code> object (with spectra in their
original order).</p></li>
<li><p><code>filterIsolationWindow</code>: retains spectra that contain <code>mz</code> in their
isolation window m/z range (i.e. with an <code>isolationWindowLowerMz</code> &lt;= <code>mz</code>
and <code>isolationWindowUpperMz</code> &gt;= <code>mz</code>. Returns the filtered <code>Spectra</code>
object (with spectra in their original order).</p></li>
<li><p><code>filterMsLevel</code>: filters object by MS level keeping only spectra matching
the MS level specified with argument <code>msLevel</code>. Returns the filtered
<code>Spectra</code> (with spectra in their original order).</p></li>
<li><p><code>filterMzRange</code>: filters the object keeping only peaks in each spectrum
that are within the provided m/z range.</p></li>
<li><p><code>filterMzValues</code>: filters the object keeping only peaks in each spectrum
that match the provided m/z value(s) considering also the absolute
<code>tolerance</code> and m/z-relative <code>ppm</code> (<code>tolerance</code> and <code>ppm</code> can be either
of length 1 or equal to the length of <code>mz</code> to define a different tolerance
for each m/z).</p></li>
<li><p><code>filterPolarity</code>: filters the object keeping only spectra matching the
provided polarity. Returns the filtered <code>Spectra</code> (with spectra in their
original order).</p></li>
<li><p><code>filterPrecursorMz</code>: retains spectra with a precursor m/z within the
provided m/z range. See examples for details on selecting spectra with
a precursor m/z for a target m/z accepting a small difference in <em>ppm</em>.</p></li>
<li><p><code>filterPrecursorScan</code>: retains parent (e.g. MS1) and children scans (e.g.
MS2) of acquisition number <code>acquisitionNum</code>. Returns the filtered
<code>Spectra</code> (with spectra in their original order).</p></li>
<li><p><code>filterRt</code>: retains spectra of MS level <code>msLevel</code> with retention
times (in seconds) within (<code>&gt;=</code>) <code>rt[1]</code> and (<code>&lt;=</code>)
<code>rt[2]</code>. Returns the filtered <code>Spectra</code> (with spectra in their
original order).</p></li>
<li><p><code>reset</code>: restores the data to its original state (as much as possible):
removes any processing steps from the lazy processing queue and calls
<code>reset</code> on the backend which, depending on the backend, can also undo e.g.
data filtering operations. Note that a <code>reset</code> call after <code>applyProcessing</code>
will not have any effect. See examples below for more information.</p></li>
<li><p><code>selectSpectraVariables</code>: reduces the information within the object to
the selected spectra variables: all data for variables not specified will
be dropped. For mandatory columns (such as <em>msLevel</em>, <em>rtime</em> ...) only
the values will be dropped, while additional (user defined) spectra
variables will be completely removed. Returns the filtered <code>Spectra</code>.</p></li>
<li><p><code>split</code>: splits the <code>Spectra</code> object based on parameter <code>f</code> into a <code>list</code>
of <code>Spectra</code> objects.</p></li>
</ul>

<p>Several <code>Spectra</code> objects can be concatenated into a single object with the
<code>c</code> function. Concatenation will fail if the processing queue of any of the
<code>Spectra</code> objects is not empty or if different backends are used in the
<code>Spectra</code> objects. The spectra variables of the resulting <code>Spectra</code>
object is the union of the spectra variables of the individual <code>Spectra</code>
objects.</p>
    <h2 class="hasAnchor" id="data-manipulation-and-analysis-methods"><a class="anchor" href="#data-manipulation-and-analysis-methods"></a>Data manipulation and analysis methods</h2>

    


<p>Many data manipulation operations, such as those listed in this section, are
not applied immediately to the spectra, but added to a
<em>lazy processing/manipulation queue</em>. Operations stored in this queue are
applied on-the-fly to spectra data each time it is accessed. This lazy
execution guarantees the same functionality for <code>Spectra</code> objects with
any backend, i.e. backends supporting to save changes to spectrum data
(<code><a href='MsBackend.html'>MsBackendDataFrame()</a></code> or <code><a href='MsBackend.html'>MsBackendHdf5Peaks()</a></code>) as well as read-only
backends (such as the <code><a href='MsBackend.html'>MsBackendMzR()</a></code>). Note that for the former it is
possible to apply the processing queue and write the modified peak data back
to the data storage with the <code>applyProcessing</code> function.</p><ul>
<li><p><code>addProcessing</code>: adds an arbitrary function that should be applied to the
peaks matrix of every spectrum in <code>object</code>. The function (can be passed
with parameter <code>FUN</code>) is expected to take a peaks matrix as input and to
return a peaks matrix. A peaks matrix is a numeric matrix with two columns,
the first containing the m/z values of the peaks and the second the
corresponding intensities. The function has to have <code>...</code> in its
definition. Additional arguments can be passed with <code>...</code>. Examples are
provided in the package vignette.</p></li>
<li><p><code>applyProcessing</code>: for <code>Spectra</code> objects that use a <strong>writeable</strong> backend
only: apply all steps from the lazy processing queue to the peak data and
write it back to the data storage. Parameter <code>f</code> allows to specify how
<code>object</code> should be split for parallel processing. This should either be
equal to the <code>dataStorage</code>, or <code>f = rep(1, length(object))</code> to disable
parallel processing alltogether. Other partitionings might result in
errors (especially if a <code>MsBackendHdf5Peaks</code> backend is used).</p></li>
<li><p><code>bin</code>: aggregates individual spectra into discrete (m/z) bins. All
intensity values for peaks falling into the same bin are summed.</p></li>
<li><p><code>combineSpectra</code>: combine sets of spectra into a single spectrum per set.
For each spectrum group (set), spectra variables from the first spectrum
are used and the peak matrices are combined using the function specified
with <code>FUN</code>, which defaults to <code><a href='combinePeaks.html'>combinePeaks()</a></code>. The sets of spectra can be
specified with parameter <code>f</code>.
In addition it is possible to define, with parameter <code>p</code> if and how to
split the input data for parallel processing.
This defaults to <code>p = x$dataStorage</code> and hence a per-file parallel
processing is applied for <code>Spectra</code> with file-based backends (such as the
<code><a href='MsBackend.html'>MsBackendMzR()</a></code>).
Prior combination of the spectra all processings queued in the lazy
evaluation queue are applied. Be aware that calling <code>combineSpectra</code> on a
<code>Spectra</code> object with certain backends that allow modifications might
<strong>overwrite</strong> the original data. This does not happen with a
<code>MsBackendDataFrame</code> backend, but with a <code>MsBackendHdf5Peaks</code> backend the
m/z and intensity values in the original hdf5 file(s) will be overwritten.
The function returns a <code>Spectra</code> of length equal to the unique levels
of <code>f</code>.</p></li>
<li><p><code>compareSpectra</code>: compare each spectrum in <code>x</code> with each spectrum in <code>y</code>
using the function provided with <code>FUN</code> (defaults to <code>ndotproduct()</code>). If
<code>y</code> is missing, each spectrum in <code>x</code> is compared with each other spectrum
in <code>x</code>.
The matching/mapping of peaks between the compared spectra is done with the
<code>MAPFUN</code> function. The default <code><a href='joinPeaks.html'>joinPeaks()</a></code> matches peaks of both spectra
and allows to keep all peaks from the first spectrum (<code>type = "left"</code>),
from the second (<code>type = "right"</code>), from both (<code>type = "outer"</code>) and to
keep only matching peaks (<code>type = "inner"</code>); see <code><a href='joinPeaks.html'>joinPeaks()</a></code> for more
information and examples).
<code>FUN</code> is supposed to be a function to compare intensities of (matched)
peaks of the two spectra that are compared. The function needs to take two
matrices with columns <code>"mz"</code> and <code>"intensity"</code>  as input and is supposed
to return a single numeric as result. Additional parameters to functions
<code>FUN</code> and <code>MAPFUN</code> can be passed with <code>...</code>.
The function returns a <code>matrix</code> with the results of <code>FUN</code> for each
comparison, number of rows equal to <code><a href='https://rdrr.io/r/base/length.html'>length(x)</a></code> and number of columns
equal <code><a href='https://rdrr.io/r/base/length.html'>length(y)</a></code> (i.e. element in row 2 and column 3 is the result from
the comparison of <code>x[2]</code> with <code>y[3]</code>). If <code>SIMPLIFY = TRUE</code> the <code>matrix</code>
is <em>simplified</em> to a <code>numeric</code> if length of <code>x</code> or <code>y</code> is one.</p></li>
<li><p><code>filterIntensity</code>: filters each spectrum keeping only peaks with
intensities that are within the provided range or match the criteria of
the provided function. For the former, parameter <code>intensity</code> has to be a
<code>numeric</code> defining the intensity range, for the latter a <code>function</code> that
takes the intensity values of the spectrum and returns a <code>logical</code> whether
the peak should be retained or not (see examples below for details). To
remove only peaks with intensities below a certain threshold, say 100, use
<code>intensity = c(100, Inf)</code>. Note: also a single value can be passed with
the <code>intensity</code> parameter in which case an upper limit of <code>Inf</code> is used.
Note that this function removes also peaks with missing intensities
(i.e. an intensity of <code>NA</code>). Parameter <code>msLevel.</code> allows to restrict the
filtering to spectra of the specified MS level(s).</p></li>
<li><p><code>spectrapply</code>: apply a given function to each spectrum in a <code>Spectra</code>
object. The <code>Spectra</code> is splitted into individual spectra and on each of
them (i.e. <code>Spectra</code> of length 1) the function <code>FUN</code> is applied. Additional
parameters to <code>FUN</code> can be passed with the <code>...</code> argument. Parameter
<code>BPPARAM</code> allows to enable parallel processing, which however makes only
sense if <code>FUN</code> is computational intense. <code>spectrapply</code> returns a <code>list</code>
(same length than <code>object</code>) with the result from <code>FUN</code>. See examples for
more details.
Note that the result and its order depends on the factor <code>f</code> used for
splitting <code>object</code> with <code>split</code>, i.e. no re-ordering or <code>unsplit</code> is
performed on the result.</p></li>
<li><p><code>smooth</code>: smooth individual spectra using a moving window-based approach
(window size = <code>2 * halfWindowSize</code>). Currently, the
Moving-Average- (<code>method = "MovingAverage"</code>),
Weighted-Moving-Average- (<code>method = "WeightedMovingAverage")</code>,
weights depending on the distance of the center and calculated
<code>1/2^(-halfWindowSize:halfWindowSize)</code>) and
Savitzky-Golay-Smoothing (<code>method = "SavitzkyGolay"</code>) are supported.
For details how to choose the correct <code>halfWindowSize</code> please see
<code><a href='https://rdrr.io/pkg/MsCoreUtils/man/smooth.html'>MsCoreUtils::smooth()</a></code>.</p></li>
<li><p><code>pickPeaks</code>: picks peaks on individual spectra using a moving window-based
approach (window size = <code>2 * halfWindowSize</code>). For noisy spectra there
are currently two different noise estimators available,
the <em>M</em>edian <em>A</em>bsolute <em>D</em>eviation (<code>method = "MAD"</code>) and
Friedman's Super Smoother (<code>method = "SuperSmoother"</code>),
as implemented in the <code><a href='https://rdrr.io/pkg/MsCoreUtils/man/noise.html'>MsCoreUtils::noise()</a></code>.
The method supports also to optionally <em>refine</em> the m/z value of
the identified centroids by considering data points that belong (most
likely) to the same mass peak. Therefore the m/z value is calculated as an
intensity weighted average of the m/z values within the peak region.
The peak region is defined as the m/z values (and their respective
intensities) of the <code>2 * k</code> closest signals to the centroid or the closest
valleys (<code>descending = TRUE</code>) in the <code>2 * k</code> region. For the latter the <code>k</code>
has to be chosen general larger. See <code><a href='https://rdrr.io/pkg/MsCoreUtils/man/refineCentroids.html'>MsCoreUtils::refineCentroids()</a></code> for
details.
If the ratio of the signal to the highest intensity of the peak is below
<code>threshold</code> it will be ignored for the weighted average.</p></li>
<li><p><code>replaceIntensitiesBelow</code>: replaces intensities below a specified
threshold with the provided <code>value</code>. Parameter <code>threshold</code> can be either
a single numeric value or a function which is applied to all non-<code>NA</code>
intensities of each spectrum to determine a threshold value for each
spectrum. The default is <code>threshold = min</code> which replaces all values
which are &lt;= the minimum intensity in a spectrum with <code>value</code> (the
default for <code>value</code> is <code>0</code>). Note that the function specified with
<code>threshold</code> is expected to have a parameter <code>na.rm</code> since <code>na.rm = TRUE</code>
will be passed to the function. If the spectrum is in profile mode,
ranges of successive non-0 peaks &lt;= <code>threshold</code> are set to 0.
Parameter <code>msLevel.</code> allows to apply this to only spectra of certain MS
level(s).</p></li>
</ul>

    <h2 class="hasAnchor" id="author"><a class="anchor" href="#author"></a>Author</h2>

    <p>Sebastian Gibb, Johannes Rainer</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>
<span class='co'>## Create a Spectra providing a `DataFrame` containing the spectrum data.</span>

<span class='va'>spd</span> <span class='op'>&lt;-</span> <span class='fu'>DataFrame</span><span class='op'>(</span>msLevel <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1L</span>, <span class='fl'>2L</span><span class='op'>)</span>, rtime <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1.1</span>, <span class='fl'>1.2</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>spd</span><span class='op'>$</span><span class='va'>mz</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>100</span>, <span class='fl'>103.2</span>, <span class='fl'>104.3</span>, <span class='fl'>106.5</span><span class='op'>)</span>, <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>45.6</span>, <span class='fl'>120.4</span>, <span class='fl'>190.2</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>spd</span><span class='op'>$</span><span class='va'>intensity</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>200</span>, <span class='fl'>400</span>, <span class='fl'>34.2</span>, <span class='fl'>17</span><span class='op'>)</span>, <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>12.3</span>, <span class='fl'>15.2</span>, <span class='fl'>6.8</span><span class='op'>)</span><span class='op'>)</span>

<span class='va'>data</span> <span class='op'>&lt;-</span> <span class='fu'>Spectra</span><span class='op'>(</span><span class='va'>spd</span><span class='op'>)</span>
<span class='va'>data</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         1       1.1        NA
#&gt; 2         2       1.2        NA
#&gt;  ... 16 more variables/columns.</div><div class='input'>
<span class='co'>## Get the number of spectra</span>
<span class='fu'><a href='https://rdrr.io/r/base/length.html'>length</a></span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 2</div><div class='input'>
<span class='co'>## Get the number of peaks per spectrum</span>
<span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 4 3</div><div class='input'>
<span class='co'>## Create a Spectra from mzML files and use the `MsBackendMzR` on-disk</span>
<span class='co'>## backend.</span>
<span class='va'>sciex_file</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/list.files.html'>dir</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/system.file.html'>system.file</a></span><span class='op'>(</span><span class='st'>"sciex"</span>, package <span class='op'>=</span> <span class='st'>"msdata"</span><span class='op'>)</span>,
    full.names <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>
<span class='va'>sciex</span> <span class='op'>&lt;-</span> <span class='fu'>Spectra</span><span class='op'>(</span><span class='va'>sciex_file</span>, backend <span class='op'>=</span> <span class='fu'><a href='MsBackend.html'>MsBackendMzR</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>sciex</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:
#&gt;        msLevel     rtime scanIndex
#&gt;      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1            1     0.280         1
#&gt; 2            1     0.559         2
#&gt; 3            1     0.838         3
#&gt; 4            1     1.117         4
#&gt; 5            1     1.396         5
#&gt; ...        ...       ...       ...
#&gt; 1858         1   258.636       927
#&gt; 1859         1   258.915       928
#&gt; 1860         1   259.194       929
#&gt; 1861         1   259.473       930
#&gt; 1862         1   259.752       931
#&gt;  ... 33 more variables/columns.
#&gt; 
#&gt; file(s):
#&gt; 20171016_POOL_POS_1_105-134.mzML
#&gt; 20171016_POOL_POS_3_105-134.mzML</div><div class='input'>
<span class='co'>## The MS data is on disk and will be read into memory on-demand. We can</span>
<span class='co'>## however change the backend to a MsBackendDataFrame backend which will</span>
<span class='co'>## keep all of the data in memory.</span>
<span class='va'>sciex_im</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>setBackend</a></span><span class='op'>(</span><span class='va'>sciex</span>, <span class='fu'><a href='MsBackend.html'>MsBackendDataFrame</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>
<span class='va'>sciex_im</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 1862 spectra in a MsBackendDataFrame backend:
#&gt;        msLevel     rtime scanIndex
#&gt;      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1            1     0.280         1
#&gt; 2            1     0.559         2
#&gt; 3            1     0.838         3
#&gt; 4            1     1.117         4
#&gt; 5            1     1.396         5
#&gt; ...        ...       ...       ...
#&gt; 1858         1   258.636       927
#&gt; 1859         1   258.915       928
#&gt; 1860         1   259.194       929
#&gt; 1861         1   259.473       930
#&gt; 1862         1   259.752       931
#&gt;  ... 33 more variables/columns.
#&gt; Processing:
#&gt;  Switch backend from MsBackendMzR to MsBackendDataFrame [Thu Oct 29 12:36:10 2020] </div><div class='input'>
<span class='co'>## The on-disk object `sciex` is light-weight, because it does not keep the</span>
<span class='co'>## MS peak data in memory. The `sciex_im` object in contrast keeps all the</span>
<span class='co'>## data in memory and its size is thus much larger.</span>
<span class='fu'><a href='https://rdrr.io/r/utils/object.size.html'>object.size</a></span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span>
</div><div class='output co'>#&gt; 395352 bytes</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/utils/object.size.html'>object.size</a></span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>)</span>
</div><div class='output co'>#&gt; 54926576 bytes</div><div class='input'>
<span class='co'>## The spectra variable `dataStorage` returns for each spectrum the location</span>
<span class='co'>## where the data is stored. For in-memory objects:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='fu'>dataStorage</span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;"</div><div class='input'>
<span class='co'>## While objects that use an on-disk backend will list the files where the</span>
<span class='co'>## data is stored.</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='fu'>dataStorage</span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [2] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [3] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [4] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [5] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [6] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"</div><div class='input'>
<span class='co'>## The spectra variable `dataOrigin` returns for each spectrum the *origin*</span>
<span class='co'>## of the data. If the data is read from e.g. mzML files, this will be the</span>
<span class='co'>## original mzML file name:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='fu'>dataOrigin</span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [2] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [3] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [4] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [5] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [6] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='fu'>dataOrigin</span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [2] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [3] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [4] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [5] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [6] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"</div><div class='input'>
<span class='co'>## ---- ACCESSING AND ADDING DATA ----</span>

<span class='co'>## Get the MS level for each spectrum.</span>
<span class='fu'>msLevel</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 1 2</div><div class='input'>
<span class='co'>## Alternatively, we could also use $ to access a specific spectra variable.</span>
<span class='co'>## This could also be used to add additional spectra variables to the</span>
<span class='co'>## object (see further below).</span>
<span class='va'>data</span><span class='op'>$</span><span class='va'>msLevel</span>
</div><div class='output co'>#&gt; [1] 1 2</div><div class='input'>
<span class='co'>## Get the intensity and m/z values.</span>
<span class='fu'>intensity</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 2
#&gt; [[1]] 200 400 34.2 17
#&gt; [[2]] 12.3 15.2 6.8</div><div class='input'><span class='fu'>mz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 2
#&gt; [[1]] 100 103.2 104.3 106.5
#&gt; [[2]] 45.6 120.4 190.2</div><div class='input'>
<span class='co'>## Determine whether one of the spectra has a specific m/z value</span>
<span class='fu'><a href='hidden_aliases.html'>containsMz</a></span><span class='op'>(</span><span class='va'>data</span>, mz <span class='op'>=</span> <span class='fl'>120.4</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] FALSE  TRUE</div><div class='input'>
<span class='co'>## Accessing spectra variables works for all backends:</span>
<span class='fu'>intensity</span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 1862
#&gt; [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0
#&gt; [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0
#&gt; [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0
#&gt; [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0
#&gt; [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0
#&gt; [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0
#&gt; [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0
#&gt; [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0
#&gt; [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0
#&gt; [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0
#&gt; ...
#&gt; &lt;1852 more elements&gt;</div><div class='input'><span class='fu'>intensity</span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 1862
#&gt; [[1]] 0 412 0 0 412 0 0 412 0 0 412 0 0 ... 0 412 0 0 412 0 0 412 0 0 412 412 0
#&gt; [[2]] 0 140 0 0 140 0 0 419 0 0 140 0 0 ... 0 140 0 0 140 0 0 140 0 0 279 140 0
#&gt; [[3]] 0 132 263 263 132 132 0 0 132 132 0 0 ... 0 0 132 0 0 132 0 0 132 0 132 0
#&gt; [[4]] 0 139 139 0 0 139 0 0 139 139 0 139 0 ... 0 0 139 0 0 277 0 0 139 0 139 0
#&gt; [[5]] 0 164 0 0 328 0 164 0 0 164 0 0 164 ... 164 0 0 164 0 0 164 0 164 0 328 0
#&gt; [[6]] 0 146 146 146 0 0 146 0 0 146 0 0 ... 146 0 0 146 146 0 0 146 0 0 146 0
#&gt; [[7]] 0 296 0 296 0 0 148 0 0 148 0 0 148 ... 0 0 148 0 0 148 0 0 148 0 0 148 0
#&gt; [[8]] 0 170 0 170 170 170 0 170 0 0 170 0 ... 170 0 0 170 0 0 170 0 0 170 170 0
#&gt; [[9]] 0 157 0 314 0 0 157 0 0 157 0 0 314 ... 0 0 157 0 0 157 0 0 157 0 157 0
#&gt; [[10]] 0 151 302 302 604 0 302 0 0 151 0 0 ... 151 0 0 151 0 151 0 151 0 151 0
#&gt; ...
#&gt; &lt;1852 more elements&gt;</div><div class='input'>
<span class='co'>## Get the m/z for the first spectrum.</span>
<span class='fu'>mz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 100.0 103.2 104.3 106.5</div><div class='input'>
<span class='co'>## Get the peak data (m/z and intensity values).</span>
<span class='va'>pks</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>peaksData</a></span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
<span class='va'>pks</span>
</div><div class='output co'>#&gt; List of length 2</div><div class='input'><span class='va'>pks</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt;         mz intensity
#&gt; [1,] 100.0     200.0
#&gt; [2,] 103.2     400.0
#&gt; [3,] 104.3      34.2
#&gt; [4,] 106.5      17.0</div><div class='input'><span class='va'>pks</span><span class='op'>[[</span><span class='fl'>2</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt;         mz intensity
#&gt; [1,]  45.6      12.3
#&gt; [2,] 120.4      15.2
#&gt; [3,] 190.2       6.8</div><div class='input'>
<span class='co'>## Note that we could get the same resulb by coercing the `Spectra` to</span>
<span class='co'>## a `list` or `SimpleList`:</span>
<span class='fu'>as</span><span class='op'>(</span><span class='va'>data</span>, <span class='st'>"list"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt;         mz intensity
#&gt; [1,] 100.0     200.0
#&gt; [2,] 103.2     400.0
#&gt; [3,] 104.3      34.2
#&gt; [4,] 106.5      17.0
#&gt; 
#&gt; [[2]]
#&gt;         mz intensity
#&gt; [1,]  45.6      12.3
#&gt; [2,] 120.4      15.2
#&gt; [3,] 190.2       6.8
#&gt; </div><div class='input'><span class='fu'>as</span><span class='op'>(</span><span class='va'>data</span>, <span class='st'>"SimpleList"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; List of length 2</div><div class='input'>
<span class='co'>## List all available spectra variables (i.e. spectrum data and metadata).</span>
<span class='fu'>spectraVariables</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt;  [1] "msLevel"                 "rtime"                  
#&gt;  [3] "acquisitionNum"          "scanIndex"              
#&gt;  [5] "dataStorage"             "dataOrigin"             
#&gt;  [7] "centroided"              "smoothed"               
#&gt;  [9] "polarity"                "precScanNum"            
#&gt; [11] "precursorMz"             "precursorIntensity"     
#&gt; [13] "precursorCharge"         "collisionEnergy"        
#&gt; [15] "isolationWindowLowerMz"  "isolationWindowTargetMz"
#&gt; [17] "isolationWindowUpperMz" </div><div class='input'>
<span class='co'>## For all *core* spectrum variables accessor functions are available. These</span>
<span class='co'>## return NA if the variable was not set.</span>
<span class='fu'>centroided</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] NA NA</div><div class='input'><span class='fu'>dataStorage</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "&lt;memory&gt;" "&lt;memory&gt;"</div><div class='input'><span class='fu'>rtime</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 1.1 1.2</div><div class='input'><span class='fu'>precursorMz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] NA NA</div><div class='input'>
<span class='co'>## Add an additional metadata column.</span>
<span class='va'>data</span><span class='op'>$</span><span class='va'>spectrum_id</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"sp_1"</span>, <span class='st'>"sp_2"</span><span class='op'>)</span>

<span class='co'>## List spectra variables, "spectrum_id" is now also listed</span>
<span class='fu'>spectraVariables</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt;  [1] "msLevel"                 "rtime"                  
#&gt;  [3] "acquisitionNum"          "scanIndex"              
#&gt;  [5] "dataStorage"             "dataOrigin"             
#&gt;  [7] "centroided"              "smoothed"               
#&gt;  [9] "polarity"                "precScanNum"            
#&gt; [11] "precursorMz"             "precursorIntensity"     
#&gt; [13] "precursorCharge"         "collisionEnergy"        
#&gt; [15] "isolationWindowLowerMz"  "isolationWindowTargetMz"
#&gt; [17] "isolationWindowUpperMz"  "spectrum_id"            </div><div class='input'>
<span class='co'>## Get the values for the new spectra variable</span>
<span class='va'>data</span><span class='op'>$</span><span class='va'>spectrum_id</span>
</div><div class='output co'>#&gt; [1] "sp_1" "sp_2"</div><div class='input'>
<span class='co'>## Extract specific spectra variables.</span>
<span class='fu'>spectraData</span><span class='op'>(</span><span class='va'>data</span>, columns <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"spectrum_id"</span>, <span class='st'>"msLevel"</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; DataFrame with 2 rows and 2 columns
#&gt;   spectrum_id   msLevel
#&gt;   &lt;character&gt; &lt;integer&gt;
#&gt; 1        sp_1         1
#&gt; 2        sp_2         2</div><div class='input'>
<span class='co'>## Drop spectra variable data and/or columns.</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>selectSpectraVariables</a></span><span class='op'>(</span><span class='va'>data</span>, <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"mz"</span>, <span class='st'>"intensity"</span><span class='op'>)</span><span class='op'>)</span>

<span class='co'>## This removed the additional columns "spectrum_id" and deleted all values</span>
<span class='co'>## for all spectra variables, except "mz" and "intensity".</span>
<span class='fu'>spectraData</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
</div><div class='output co'>#&gt; DataFrame with 2 rows and 17 columns
#&gt;     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin
#&gt;   &lt;integer&gt; &lt;numeric&gt;      &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt;
#&gt; 1        NA        NA             NA        NA    &lt;memory&gt;          NA
#&gt; 2        NA        NA             NA        NA    &lt;memory&gt;          NA
#&gt;   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity
#&gt;    &lt;logical&gt; &lt;logical&gt; &lt;integer&gt;   &lt;integer&gt;   &lt;numeric&gt;          &lt;numeric&gt;
#&gt; 1         NA        NA        NA          NA          NA                 NA
#&gt; 2         NA        NA        NA          NA          NA                 NA
#&gt;   precursorCharge collisionEnergy isolationWindowLowerMz
#&gt;         &lt;integer&gt;       &lt;numeric&gt;              &lt;numeric&gt;
#&gt; 1              NA              NA                     NA
#&gt; 2              NA              NA                     NA
#&gt;   isolationWindowTargetMz isolationWindowUpperMz
#&gt;                 &lt;numeric&gt;              &lt;numeric&gt;
#&gt; 1                      NA                     NA
#&gt; 2                      NA                     NA</div><div class='input'>
<span class='co'>## Compared to the data before selectSpectraVariables.</span>
<span class='fu'>spectraData</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; DataFrame with 2 rows and 18 columns
#&gt;     msLevel     rtime acquisitionNum scanIndex dataStorage  dataOrigin
#&gt;   &lt;integer&gt; &lt;numeric&gt;      &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt;
#&gt; 1         1       1.1             NA        NA    &lt;memory&gt;          NA
#&gt; 2         2       1.2             NA        NA    &lt;memory&gt;          NA
#&gt;   centroided  smoothed  polarity precScanNum precursorMz precursorIntensity
#&gt;    &lt;logical&gt; &lt;logical&gt; &lt;integer&gt;   &lt;integer&gt;   &lt;numeric&gt;          &lt;numeric&gt;
#&gt; 1         NA        NA        NA          NA          NA                 NA
#&gt; 2         NA        NA        NA          NA          NA                 NA
#&gt;   precursorCharge collisionEnergy isolationWindowLowerMz
#&gt;         &lt;integer&gt;       &lt;numeric&gt;              &lt;numeric&gt;
#&gt; 1              NA              NA                     NA
#&gt; 2              NA              NA                     NA
#&gt;   isolationWindowTargetMz isolationWindowUpperMz spectrum_id
#&gt;                 &lt;numeric&gt;              &lt;numeric&gt; &lt;character&gt;
#&gt; 1                      NA                     NA        sp_1
#&gt; 2                      NA                     NA        sp_2</div><div class='input'>

<span class='co'>## ---- SUBSETTING, FILTERING AND COMBINING</span>

<span class='co'>## Subset to all MS2 spectra.</span>
<span class='va'>data</span><span class='op'>[</span><span class='fu'>msLevel</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span> <span class='op'>==</span> <span class='fl'>2</span><span class='op'>]</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         2       1.2        NA
#&gt;  ... 17 more variables/columns.</div><div class='input'>
<span class='co'>## Same with the filterMsLevel function</span>
<span class='fu'>filterMsLevel</span><span class='op'>(</span><span class='va'>data</span>, <span class='fl'>2</span><span class='op'>)</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         2       1.2        NA
#&gt;  ... 17 more variables/columns.
#&gt; Processing:
#&gt;  Filter: select MS level(s) 2 [Thu Oct 29 12:36:11 2020] </div><div class='input'>
<span class='co'>## Below we combine the `data` and `sciex_im` objects into a single one.</span>
<span class='va'>data_comb</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='va'>data</span>, <span class='va'>sciex_im</span><span class='op'>)</span>

<span class='co'>## The combined Spectra contains a union of all spectra variables:</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>data_comb</span><span class='op'>$</span><span class='va'>spectrum_id</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "sp_1" "sp_2" NA     NA     NA     NA    </div><div class='input'><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>data_comb</span><span class='op'>$</span><span class='va'>rtime</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 1.100 1.200 0.280 0.559 0.838 1.117</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>data_comb</span><span class='op'>$</span><span class='va'>dataStorage</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;" "&lt;memory&gt;"</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>data_comb</span><span class='op'>$</span><span class='va'>dataOrigin</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] NA                                                                                
#&gt; [2] NA                                                                                
#&gt; [3] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [4] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [5] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"
#&gt; [6] "/usr/local/lib/R/host-site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML"</div><div class='input'>
<span class='co'>## Filter a Spectra for a target precursor m/z with a tolerance of 10ppm</span>
<span class='va'>spd</span><span class='op'>$</span><span class='va'>precursorMz</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>323.4</span>, <span class='fl'>543.2302</span><span class='op'>)</span>
<span class='va'>data_filt</span> <span class='op'>&lt;-</span> <span class='fu'>Spectra</span><span class='op'>(</span><span class='va'>spd</span><span class='op'>)</span>
<span class='fu'>filterPrecursorMz</span><span class='op'>(</span><span class='va'>data_filt</span>, mz <span class='op'>=</span> <span class='fl'>543.23</span> <span class='op'>+</span> <span class='fu'><a href='hidden_aliases.html'>ppm</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='op'>-</span><span class='fl'>543.23</span>, <span class='fl'>543.23</span><span class='op'>)</span>, <span class='fl'>10</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 1 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         2       1.2        NA
#&gt;  ... 16 more variables/columns.
#&gt; Processing:
#&gt;  Filter: select spectra with a precursor m/z within [543.2245677, 543.2354323] [Thu Oct 29 12:36:12 2020] </div><div class='input'>
<span class='co'>## Filter a Spectra keeping only peaks matching certain m/z values</span>
<span class='va'>sps_sub</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>filterMzValues</a></span><span class='op'>(</span><span class='va'>data</span>, mz <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>103</span>, <span class='fl'>104</span><span class='op'>)</span>, tolerance <span class='op'>=</span> <span class='fl'>0.3</span><span class='op'>)</span>
<span class='fu'>mz</span><span class='op'>(</span><span class='va'>sps_sub</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 2
#&gt; [[1]] 103.2 104.3
#&gt; [[2]] numeric(0)</div><div class='input'>
<span class='co'>## Filter a Spectra keeping only peaks within a m/z range</span>
<span class='va'>sps_sub</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>filterMzRange</a></span><span class='op'>(</span><span class='va'>data</span>, mz <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>100</span>, <span class='fl'>300</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'>mz</span><span class='op'>(</span><span class='va'>sps_sub</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 2
#&gt; [[1]] 100 103.2 104.3 106.5
#&gt; [[2]] 120.4 190.2</div><div class='input'>
<span class='co'>## Remove empty spectra variables</span>
<span class='va'>sciex_noNA</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>dropNaSpectraVariables</a></span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span>

<span class='co'>## Available spectra variables before and after dropNaSpectraVariables</span>
<span class='fu'>spectraVariables</span><span class='op'>(</span><span class='va'>sciex</span><span class='op'>)</span>
</div><div class='output co'>#&gt;  [1] "msLevel"                  "rtime"                   
#&gt;  [3] "acquisitionNum"           "scanIndex"               
#&gt;  [5] "dataStorage"              "dataOrigin"              
#&gt;  [7] "centroided"               "smoothed"                
#&gt;  [9] "polarity"                 "precScanNum"             
#&gt; [11] "precursorMz"              "precursorIntensity"      
#&gt; [13] "precursorCharge"          "collisionEnergy"         
#&gt; [15] "isolationWindowLowerMz"   "isolationWindowTargetMz" 
#&gt; [17] "isolationWindowUpperMz"   "peaksCount"              
#&gt; [19] "totIonCurrent"            "basePeakMZ"              
#&gt; [21] "basePeakIntensity"        "ionisationEnergy"        
#&gt; [23] "lowMZ"                    "highMZ"                  
#&gt; [25] "mergedScan"               "mergedResultScanNum"     
#&gt; [27] "mergedResultStartScanNum" "mergedResultEndScanNum"  
#&gt; [29] "injectionTime"            "filterString"            
#&gt; [31] "spectrumId"               "ionMobilityDriftTime"    
#&gt; [33] "scanWindowLowerLimit"     "scanWindowUpperLimit"    </div><div class='input'><span class='fu'>spectraVariables</span><span class='op'>(</span><span class='va'>sciex_noNA</span><span class='op'>)</span>
</div><div class='output co'>#&gt;  [1] "msLevel"                 "rtime"                  
#&gt;  [3] "acquisitionNum"          "scanIndex"              
#&gt;  [5] "dataStorage"             "dataOrigin"             
#&gt;  [7] "centroided"              "smoothed"               
#&gt;  [9] "polarity"                "precScanNum"            
#&gt; [11] "precursorMz"             "precursorIntensity"     
#&gt; [13] "precursorCharge"         "collisionEnergy"        
#&gt; [15] "isolationWindowLowerMz"  "isolationWindowTargetMz"
#&gt; [17] "isolationWindowUpperMz"  "peaksCount"             
#&gt; [19] "totIonCurrent"           "basePeakMZ"             
#&gt; [21] "basePeakIntensity"       "ionisationEnergy"       
#&gt; [23] "lowMZ"                   "highMZ"                 
#&gt; [25] "injectionTime"           "spectrumId"             </div><div class='input'>

<span class='co'>## ---- DATA MANIPULATIONS AND OTHER OPERATIONS ----</span>

<span class='co'>## Set the data to be centroided</span>
<span class='fu'>centroided</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span> <span class='op'>&lt;-</span> <span class='cn'>TRUE</span>

<span class='co'>## Replace peak intensities below 40 with 3.</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>replaceIntensitiesBelow</a></span><span class='op'>(</span><span class='va'>data</span>, threshold <span class='op'>=</span> <span class='fl'>40</span>, value <span class='op'>=</span> <span class='fl'>3</span><span class='op'>)</span>
<span class='va'>res</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         1       1.1        NA
#&gt; 2         2       1.2        NA
#&gt;  ... 17 more variables/columns.
#&gt; Lazy evaluation queue: 1 processing step(s)
#&gt; Processing:
#&gt;  Signal &lt;= 40 in MS level(s) 1, 2 set to 0 [Thu Oct 29 12:36:12 2020] </div><div class='input'>
<span class='co'>## Get the intensities of the first and second spectrum.</span>
<span class='fu'>intensity</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 200 400   3   3</div><div class='input'><span class='fu'>intensity</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>2</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 3 3 3</div><div class='input'>
<span class='co'>## Remove all peaks with an intensity below 40.</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>filterIntensity</a></span><span class='op'>(</span><span class='va'>res</span>, intensity <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>40</span>, <span class='cn'>Inf</span><span class='op'>)</span><span class='op'>)</span>

<span class='co'>## Get the intensities of the first and second spectrum.</span>
<span class='fu'>intensity</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 200 400</div><div class='input'><span class='fu'>intensity</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>2</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; numeric(0)</div><div class='input'>
<span class='co'>## Lengths of spectra is now different</span>
<span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 2 0</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 4 3</div><div class='input'>
<span class='co'>## In addition it is possible to pass a function to `filterIntensity`: in</span>
<span class='co'>## the example below we want to keep only peaks that have an intensity which</span>
<span class='co'>## is larger than one third of the maximal peak intensity in that spectrum.</span>
<span class='va'>keep_peaks</span> <span class='op'>&lt;-</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='va'>x</span> <span class='op'>&gt;</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span><span class='op'>(</span><span class='va'>x</span>, na.rm <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span> <span class='op'>/</span> <span class='fl'>3</span>
<span class='op'>}</span>
<span class='va'>res2</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>filterIntensity</a></span><span class='op'>(</span><span class='va'>data</span>, intensity <span class='op'>=</span> <span class='va'>keep_peaks</span><span class='op'>)</span>
<span class='fu'>intensity</span><span class='op'>(</span><span class='va'>res2</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>1L</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 200 400</div><div class='input'><span class='fu'>intensity</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span><span class='op'>[[</span><span class='fl'>1L</span><span class='op'>]</span><span class='op'>]</span>
</div><div class='output co'>#&gt; [1] 200.0 400.0  34.2  17.0</div><div class='input'>

<span class='co'>## Since data manipulation operations are by default not directly applied to</span>
<span class='co'>## the data but only added to the internal lazy evaluation queue, it is also</span>
<span class='co'>## possible to remove these data manipulations with the `reset` function:</span>
<span class='va'>res_rest</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>reset</a></span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
<span class='va'>res_rest</span>
</div><div class='output co'>#&gt; MSn data (Spectra) with 2 spectra in a MsBackendDataFrame backend:
#&gt;     msLevel     rtime scanIndex
#&gt;   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;
#&gt; 1         1       1.1        NA
#&gt; 2         2       1.2        NA
#&gt;  ... 17 more variables/columns.
#&gt; Processing:
#&gt;  Signal &lt;= 40 in MS level(s) 1, 2 set to 0 [Thu Oct 29 12:36:12 2020]
#&gt;  Remove peaks with intensities outside [40, Inf] in spectra of MS level(s) 1, 2. [Thu Oct 29 12:36:12 2020]
#&gt;  Reset object. [Thu Oct 29 12:36:12 2020] </div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>res_rest</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 4 3</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 2 0</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 4 3</div><div class='input'>
<span class='co'>## `reset` after a `applyProcessing` can not restore the data, because the</span>
<span class='co'>## data in the backend was changed. Similarly, `reset` after any filter</span>
<span class='co'>## operations can not restore data for a `Spectra` with a</span>
<span class='co'>## `MsBackendDataFrame`.</span>
<span class='va'>res_2</span> <span class='op'>&lt;-</span> <span class='fu'>applyProcessing</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
<span class='va'>res_rest</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>reset</a></span><span class='op'>(</span><span class='va'>res_2</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 2 0</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/lengths.html'>lengths</a></span><span class='op'>(</span><span class='fu'>mz</span><span class='op'>(</span><span class='va'>res_rest</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 2 0</div><div class='input'>

<span class='co'>## Compare spectra: comparing spectra 2 and 3 against spectra 10:20 using</span>
<span class='co'>## the normalized dotproduct method.</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>compareSpectra</a></span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>2</span><span class='op'>:</span><span class='fl'>3</span><span class='op'>]</span>, <span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>10</span><span class='op'>:</span><span class='fl'>20</span><span class='op'>]</span><span class='op'>)</span>
<span class='co'>## first row contains comparisons of spectrum 2 with spectra 10 to 20 and</span>
<span class='co'>## the second row comparisons of spectrum 3 with spectra 10 to 20</span>
<span class='va'>res</span>
</div><div class='output co'>#&gt;           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
#&gt; [1,] 0.8583577 0.8603472 0.8588292 0.8434391 0.8581683 0.8515891 0.8568266
#&gt; [2,] 0.8620081 0.8609868 0.8604669 0.8481934 0.8637094 0.8586378 0.8618227
#&gt;           [,8]      [,9]     [,10]     [,11]
#&gt; [1,] 0.8563933 0.8559511 0.8546560 0.8538058
#&gt; [2,] 0.8559523 0.8652169 0.8585325 0.8639445</div><div class='input'>
<span class='co'>## To use a simple Pearson correlation instead we can define a function</span>
<span class='co'>## that takes the two peak matrices and calculates the correlation for</span>
<span class='co'>## their second columns (containing the intensity values).</span>
<span class='va'>correlateSpectra</span> <span class='op'>&lt;-</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>y</span>, <span class='va'>use</span> <span class='op'>=</span> <span class='st'>"pairwise.complete.obs"</span>, <span class='va'>...</span><span class='op'>)</span> <span class='op'>{</span>
    <span class='fu'><a href='https://rdrr.io/r/stats/cor.html'>cor</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>[</span>, <span class='fl'>2</span><span class='op'>]</span>, <span class='va'>y</span><span class='op'>[</span>, <span class='fl'>2</span><span class='op'>]</span>, use <span class='op'>=</span> <span class='va'>use</span>, <span class='va'>...</span><span class='op'>)</span>
<span class='op'>}</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>compareSpectra</a></span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>2</span><span class='op'>:</span><span class='fl'>3</span><span class='op'>]</span>, <span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>10</span><span class='op'>:</span><span class='fl'>20</span><span class='op'>]</span>,
    FUN <span class='op'>=</span> <span class='va'>correlateSpectra</span><span class='op'>)</span>
<span class='va'>res</span>
</div><div class='output co'>#&gt;           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
#&gt; [1,] 0.9974395 0.9989580 0.9973735 0.9974334 0.9987225 0.9992307 0.9978621
#&gt; [2,] 0.9986971 0.9976861 0.9964951 0.9965942 0.9982105 0.9984607 0.9982808
#&gt;           [,8]      [,9]     [,10]     [,11]
#&gt; [1,] 0.9950464 0.9987036 0.9988265 0.9970657
#&gt; [2,] 0.9921029 0.9990331 0.9975400 0.9955439</div><div class='input'>
<span class='co'>## Use compareSpectra to determine the number of common (matching) peaks</span>
<span class='co'>## with a ppm of 10:</span>
<span class='co'>## type = "inner" uses a *inner join* to match peaks, i.e. keeps only</span>
<span class='co'>## peaks that can be mapped betwen both spectra. The provided FUN returns</span>
<span class='co'>## simply the number of matching peaks.</span>
<span class='fu'><a href='hidden_aliases.html'>compareSpectra</a></span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>2</span><span class='op'>:</span><span class='fl'>3</span><span class='op'>]</span>, <span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>10</span><span class='op'>:</span><span class='fl'>20</span><span class='op'>]</span>, ppm <span class='op'>=</span> <span class='fl'>10</span>, type <span class='op'>=</span> <span class='st'>"inner"</span>,
    FUN <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>y</span>, <span class='va'>...</span><span class='op'>)</span> <span class='fu'><a href='https://rdrr.io/r/base/nrow.html'>nrow</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
#&gt; [1,]  530  501  484  576  592  515  549  578  539   542   550
#&gt; [2,]  526  548  524  592  639  502  589  571  575   564   613</div><div class='input'>
<span class='co'>## Apply an arbitrary function to each spectrum in a Spectra.</span>
<span class='co'>## In the example below we calculate the mean intensity for each spectrum</span>
<span class='co'>## in a subset of the sciex_im data. Note that we can access all variables</span>
<span class='co'>## of each individual spectrum either with the `$` operator or the</span>
<span class='co'>## corresponding method.</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='hidden_aliases.html'>spectrapply</a></span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>20</span><span class='op'>]</span>, FUN <span class='op'>=</span> <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='fu'><a href='https://rdrr.io/r/base/mean.html'>mean</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>$</span><span class='va'>intensity</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $`1`
#&gt; [1] 1553.953
#&gt; 
#&gt; $`2`
#&gt; [1] 678.2289
#&gt; 
#&gt; $`3`
#&gt; [1] 684.3569
#&gt; 
#&gt; $`4`
#&gt; [1] 682.1004
#&gt; 
#&gt; $`5`
#&gt; [1] 780.6867
#&gt; 
#&gt; $`6`
#&gt; [1] 737.5087
#&gt; </div><div class='input'>
<span class='co'>## It is however important to note that dedicated methods to access the</span>
<span class='co'>## data (such as `intensity`) are much more efficient than using `lapply`:</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='fu'>intensity</span><span class='op'>(</span><span class='va'>sciex_im</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>20</span><span class='op'>]</span><span class='op'>)</span>, <span class='va'>mean</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/utils/head.html'>head</a></span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [[1]]
#&gt; [1] 1553.953
#&gt; 
#&gt; [[2]]
#&gt; [1] 678.2289
#&gt; 
#&gt; [[3]]
#&gt; [1] 684.3569
#&gt; 
#&gt; [[4]]
#&gt; [1] 682.1004
#&gt; 
#&gt; [[5]]
#&gt; [1] 780.6867
#&gt; 
#&gt; [[6]]
#&gt; [1] 737.5087
#&gt; </div><div class='input'>

<span class='co'>## ---- DATA EXPORT ----</span>

<span class='co'>## Some `MsBackend` classes provide an `export` method to export the data to</span>
<span class='co'>## the file format supported by the backend. The `MsBackendMzR` for example</span>
<span class='co'>## allows to export MS data to mzML or mzXML file(s), the `MsBackendMgf`</span>
<span class='co'>## (defined in the MsBackendMgf R package) would allow to export the data</span>
<span class='co'>## in mgf file format. Below we export the MS data in `data`. We</span>
<span class='co'>## call the `export` method on this object, specify the backend that should</span>
<span class='co'>## be used to export the data (and which also defines the output format) and</span>
<span class='co'>## provide a file name.</span>
<span class='va'>fl</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempfile</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='fu'><a href='hidden_aliases.html'>export</a></span><span class='op'>(</span><span class='va'>data</span>, <span class='fu'><a href='MsBackend.html'>MsBackendMzR</a></span><span class='op'>(</span><span class='op'>)</span>, file <span class='op'>=</span> <span class='va'>fl</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Writing file file1d5b236f424b...</span></div><div class='output co'>#&gt; <span class='message'>OK</span></div><div class='input'>
<span class='co'>## This exported our data in mzML format. Below we read the first 6 lines</span>
<span class='co'>## from that file.</span>
<span class='fu'><a href='https://rdrr.io/r/base/readLines.html'>readLines</a></span><span class='op'>(</span><span class='va'>fl</span>, n <span class='op'>=</span> <span class='fl'>6</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"                                                                                                                                                                                            
#&gt; [2] "&lt;indexedmzML xmlns=\"http://psi.hupo.org/ms/mzml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.2_idx.xsd\"&gt;"                 
#&gt; [3] "  &lt;mzML xmlns=\"http://psi.hupo.org/ms/mzml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://psi.hupo.org/ms/mzml http://psidev.info/files/ms/mzML/xsd/mzML1.1.0.xsd\" id=\"\" version=\"1.1.0\"&gt;"
#&gt; [4] "    &lt;cvList count=\"2\"&gt;"                                                                                                                                                                                                              
#&gt; [5] "      &lt;cv id=\"MS\" fullName=\"Proteomics Standards Initiative Mass Spectrometry Ontology\" version=\"4.1.41\" URI=\"https://raw.githubusercontent.com/HUPO-PSI/psi-ms-CV/master/psi-ms.obo\"/&gt;"                                       
#&gt; [6] "      &lt;cv id=\"UO\" fullName=\"Unit Ontology\" version=\"09:04:2014\" URI=\"https://raw.githubusercontent.com/bio-ontology-research-group/unit-ontology/master/unit.obo\"/&gt;"                                                           </div><div class='input'>
<span class='co'>## If only a single file name is provided, all spectra are exported to that</span>
<span class='co'>## file. To export data with the `MsBackendMzR` backend to different files, a</span>
<span class='co'>## file name for each individual spectrum has to be provided.</span>
<span class='co'>## Below we export each spectrum to its own file.</span>
<span class='va'>fls</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempfile</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='fu'><a href='https://rdrr.io/r/base/tempfile.html'>tempfile</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='hidden_aliases.html'>export</a></span><span class='op'>(</span><span class='va'>data</span>, <span class='fu'><a href='MsBackend.html'>MsBackendMzR</a></span><span class='op'>(</span><span class='op'>)</span>, file <span class='op'>=</span> <span class='va'>fls</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Writing file file1d5b53615871...</span></div><div class='output co'>#&gt; <span class='message'>OK</span></div><div class='output co'>#&gt; <span class='message'>Writing file file1d5b10f02dc7...</span></div><div class='output co'>#&gt; <span class='message'>OK</span></div><div class='input'>
<span class='co'>## Reading the data from the first file</span>
<span class='va'>res</span> <span class='op'>&lt;-</span> <span class='fu'>Spectra</span><span class='op'>(</span><span class='fu'><a href='hidden_aliases.html'>backendInitialize</a></span><span class='op'>(</span><span class='fu'><a href='MsBackend.html'>MsBackendMzR</a></span><span class='op'>(</span><span class='op'>)</span>, <span class='va'>fls</span><span class='op'>[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>)</span><span class='op'>)</span>

<span class='fu'>mz</span><span class='op'>(</span><span class='va'>res</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 1
#&gt; [[1]] 100 103.2 104.3 106.5</div><div class='input'><span class='fu'>mz</span><span class='op'>(</span><span class='va'>data</span><span class='op'>)</span>
</div><div class='output co'>#&gt; NumericList of length 2
#&gt; [[1]] 100 103.2 104.3 106.5
#&gt; [[2]] 45.6 120.4 190.2</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by RforMassSpectrometry Package Maintainer, Laurent Gatto, Johannes Rainer, Sebastian Gibb.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


